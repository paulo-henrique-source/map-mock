"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ol";
exports.ids = ["vendor-chunks/ol"];
exports.modules = {

/***/ "(ssr)/./node_modules/ol/console.js":
/*!************************************!*\
  !*** ./node_modules/ol/console.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   error: () => (/* binding */ error),\n/* harmony export */   log: () => (/* binding */ log),\n/* harmony export */   setLevel: () => (/* binding */ setLevel),\n/* harmony export */   warn: () => (/* binding */ warn)\n/* harmony export */ });\n/**\n * @module ol/console\n */ /**\n * @typedef {'info'|'warn'|'error'|'none'} Level\n */ /**\n * @type {Object<Level, number>}\n */ const levels = {\n    info: 1,\n    warn: 2,\n    error: 3,\n    none: 4\n};\n/**\n * @type {number}\n */ let level = levels.info;\n/**\n * Set the logging level.  By default, the level is set to 'info' and all\n * messages will be logged.  Set to 'warn' to only display warnings and errors.\n * Set to 'error' to only display errors.  Set to 'none' to silence all messages.\n *\n * @param {Level} l The new level.\n */ function setLevel(l) {\n    level = levels[l];\n}\n/**\n * @param  {...any} args Arguments to log\n */ function log(...args) {\n    if (level > levels.info) {\n        return;\n    }\n    console.log(...args); // eslint-disable-line no-console\n}\n/**\n * @param  {...any} args Arguments to log\n */ function warn(...args) {\n    if (level > levels.warn) {\n        return;\n    }\n    console.warn(...args); // eslint-disable-line no-console\n}\n/**\n * @param  {...any} args Arguments to log\n */ function error(...args) {\n    if (level > levels.error) {\n        return;\n    }\n    console.error(...args); // eslint-disable-line no-console\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2wvY29uc29sZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0NBRUMsR0FFRDs7Q0FFQyxHQUVEOztDQUVDLEdBQ0QsTUFBTUEsU0FBUztJQUNiQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTztJQUNQQyxNQUFNO0FBQ1I7QUFFQTs7Q0FFQyxHQUNELElBQUlDLFFBQVFMLE9BQU9DLElBQUk7QUFFdkI7Ozs7OztDQU1DLEdBQ00sU0FBU0ssU0FBU0MsQ0FBQztJQUN4QkYsUUFBUUwsTUFBTSxDQUFDTyxFQUFFO0FBQ25CO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxJQUFJLEdBQUdDLElBQUk7SUFDekIsSUFBSUosUUFBUUwsT0FBT0MsSUFBSSxFQUFFO1FBQ3ZCO0lBQ0Y7SUFDQVMsUUFBUUYsR0FBRyxJQUFJQyxPQUFPLGlDQUFpQztBQUN6RDtBQUVBOztDQUVDLEdBQ00sU0FBU1AsS0FBSyxHQUFHTyxJQUFJO0lBQzFCLElBQUlKLFFBQVFMLE9BQU9FLElBQUksRUFBRTtRQUN2QjtJQUNGO0lBQ0FRLFFBQVFSLElBQUksSUFBSU8sT0FBTyxpQ0FBaUM7QUFDMUQ7QUFFQTs7Q0FFQyxHQUNNLFNBQVNOLE1BQU0sR0FBR00sSUFBSTtJQUMzQixJQUFJSixRQUFRTCxPQUFPRyxLQUFLLEVBQUU7UUFDeEI7SUFDRjtJQUNBTyxRQUFRUCxLQUFLLElBQUlNLE9BQU8saUNBQWlDO0FBQzNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFwLy4vbm9kZV9tb2R1bGVzL29sL2NvbnNvbGUuanM/ZDVkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvY29uc29sZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydpbmZvJ3wnd2Fybid8J2Vycm9yJ3wnbm9uZSd9IExldmVsXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PExldmVsLCBudW1iZXI+fVxuICovXG5jb25zdCBsZXZlbHMgPSB7XG4gIGluZm86IDEsXG4gIHdhcm46IDIsXG4gIGVycm9yOiAzLFxuICBub25lOiA0LFxufTtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5sZXQgbGV2ZWwgPSBsZXZlbHMuaW5mbztcblxuLyoqXG4gKiBTZXQgdGhlIGxvZ2dpbmcgbGV2ZWwuICBCeSBkZWZhdWx0LCB0aGUgbGV2ZWwgaXMgc2V0IHRvICdpbmZvJyBhbmQgYWxsXG4gKiBtZXNzYWdlcyB3aWxsIGJlIGxvZ2dlZC4gIFNldCB0byAnd2FybicgdG8gb25seSBkaXNwbGF5IHdhcm5pbmdzIGFuZCBlcnJvcnMuXG4gKiBTZXQgdG8gJ2Vycm9yJyB0byBvbmx5IGRpc3BsYXkgZXJyb3JzLiAgU2V0IHRvICdub25lJyB0byBzaWxlbmNlIGFsbCBtZXNzYWdlcy5cbiAqXG4gKiBAcGFyYW0ge0xldmVsfSBsIFRoZSBuZXcgbGV2ZWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRMZXZlbChsKSB7XG4gIGxldmVsID0gbGV2ZWxzW2xdO1xufVxuXG4vKipcbiAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBBcmd1bWVudHMgdG8gbG9nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2coLi4uYXJncykge1xuICBpZiAobGV2ZWwgPiBsZXZlbHMuaW5mbykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmxvZyguLi5hcmdzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG59XG5cbi8qKlxuICogQHBhcmFtICB7Li4uYW55fSBhcmdzIEFyZ3VtZW50cyB0byBsb2dcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhcm4oLi4uYXJncykge1xuICBpZiAobGV2ZWwgPiBsZXZlbHMud2Fybikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLndhcm4oLi4uYXJncyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxufVxuXG4vKipcbiAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBBcmd1bWVudHMgdG8gbG9nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvciguLi5hcmdzKSB7XG4gIGlmIChsZXZlbCA+IGxldmVscy5lcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmVycm9yKC4uLmFyZ3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbn1cbiJdLCJuYW1lcyI6WyJsZXZlbHMiLCJpbmZvIiwid2FybiIsImVycm9yIiwibm9uZSIsImxldmVsIiwic2V0TGV2ZWwiLCJsIiwibG9nIiwiYXJncyIsImNvbnNvbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/console.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ol/coordinate.js":
/*!***************************************!*\
  !*** ./node_modules/ol/coordinate.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   closestOnCircle: () => (/* binding */ closestOnCircle),\n/* harmony export */   closestOnSegment: () => (/* binding */ closestOnSegment),\n/* harmony export */   createStringXY: () => (/* binding */ createStringXY),\n/* harmony export */   degreesToStringHDMS: () => (/* binding */ degreesToStringHDMS),\n/* harmony export */   distance: () => (/* binding */ distance),\n/* harmony export */   equals: () => (/* binding */ equals),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   getWorldsAway: () => (/* binding */ getWorldsAway),\n/* harmony export */   rotate: () => (/* binding */ rotate),\n/* harmony export */   scale: () => (/* binding */ scale),\n/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),\n/* harmony export */   squaredDistanceToSegment: () => (/* binding */ squaredDistanceToSegment),\n/* harmony export */   toStringHDMS: () => (/* binding */ toStringHDMS),\n/* harmony export */   toStringXY: () => (/* binding */ toStringXY),\n/* harmony export */   wrapX: () => (/* binding */ wrapX)\n/* harmony export */ });\n/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent.js */ \"(ssr)/./node_modules/ol/extent.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/ol/math.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ \"(ssr)/./node_modules/ol/string.js\");\n/**\n * @module ol/coordinate\n */ \n\n\n/**\n * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.\n * Example: `[16, 48]`.\n * @typedef {Array<number>} Coordinate\n * @api\n */ /**\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\n * transforms it into a `{string}`.\n *\n * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\n * @api\n */ /**\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {add} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     add(coord, [-2, 4]);\n *     // coord is now [5.85, 51.983333]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {Coordinate} delta Delta.\n * @return {Coordinate} The input coordinate adjusted by\n * the given delta.\n * @api\n */ function add(coordinate, delta) {\n    coordinate[0] += +delta[0];\n    coordinate[1] += +delta[1];\n    return coordinate;\n}\n/**\n * Calculates the point closest to the passed coordinate on the passed circle.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {import(\"./geom/Circle.js\").default} circle The circle.\n * @return {Coordinate} Closest point on the circumference.\n */ function closestOnCircle(coordinate, circle) {\n    const r = circle.getRadius();\n    const center = circle.getCenter();\n    const x0 = center[0];\n    const y0 = center[1];\n    const x1 = coordinate[0];\n    const y1 = coordinate[1];\n    let dx = x1 - x0;\n    const dy = y1 - y0;\n    if (dx === 0 && dy === 0) {\n        dx = 1;\n    }\n    const d = Math.sqrt(dx * dx + dy * dy);\n    const x = x0 + r * dx / d;\n    const y = y0 + r * dy / d;\n    return [\n        x,\n        y\n    ];\n}\n/**\n * Calculates the point closest to the passed coordinate on the passed segment.\n * This is the foot of the perpendicular of the coordinate to the segment when\n * the foot is on the segment, or the closest segment coordinate when the foot\n * is outside the segment.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {Array<Coordinate>} segment The two coordinates\n * of the segment.\n * @return {Coordinate} The foot of the perpendicular of\n * the coordinate to the segment.\n */ function closestOnSegment(coordinate, segment) {\n    const x0 = coordinate[0];\n    const y0 = coordinate[1];\n    const start = segment[0];\n    const end = segment[1];\n    const x1 = start[0];\n    const y1 = start[1];\n    const x2 = end[0];\n    const y2 = end[1];\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\n    let x, y;\n    if (along <= 0) {\n        x = x1;\n        y = y1;\n    } else if (along >= 1) {\n        x = x2;\n        y = y2;\n    } else {\n        x = x1 + along * dx;\n        y = y1 + along * dy;\n    }\n    return [\n        x,\n        y\n    ];\n}\n/**\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\n * used to format\n * a {Coordinate} to a string.\n *\n * Example without specifying the fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const stringifyFunc = createStringXY();\n *     const out = stringifyFunc(coord);\n *     // out is now '8, 48'\n *\n * Example with explicitly specifying 2 fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const stringifyFunc = createStringXY(2);\n *     const out = stringifyFunc(coord);\n *     // out is now '7.85, 47.98'\n *\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {CoordinateFormat} Coordinate format.\n * @api\n */ function createStringXY(fractionDigits) {\n    return(/**\n     * @param {Coordinate} coordinate Coordinate.\n     * @return {string} String XY.\n     */ function(coordinate) {\n        return toStringXY(coordinate, fractionDigits);\n    });\n}\n/**\n * @param {string} hemispheres Hemispheres.\n * @param {number} degrees Degrees.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} String.\n */ function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {\n    const normalizedDegrees = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.modulo)(degrees + 180, 360) - 180;\n    const x = Math.abs(3600 * normalizedDegrees);\n    const decimals = fractionDigits || 0;\n    let deg = Math.floor(x / 3600);\n    let min = Math.floor((x - deg * 3600) / 60);\n    let sec = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toFixed)(x - deg * 3600 - min * 60, decimals);\n    if (sec >= 60) {\n        sec = 0;\n        min += 1;\n    }\n    if (min >= 60) {\n        min = 0;\n        deg += 1;\n    }\n    let hdms = deg + \"\\xb0\";\n    if (min !== 0 || sec !== 0) {\n        hdms += \" \" + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(min, 2) + \"′\";\n    }\n    if (sec !== 0) {\n        hdms += \" \" + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(sec, 2, decimals) + \"″\";\n    }\n    if (normalizedDegrees !== 0) {\n        hdms += \" \" + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);\n    }\n    return hdms;\n}\n/**\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\n * using the given string template. The strings `{x}` and `{y}` in the template\n * will be replaced with the first and second coordinate values respectively.\n *\n * Example without specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const template = 'Coordinate is ({x}|{y}).';\n *     const out = format(coord, template);\n *     // out is now 'Coordinate is (8|48).'\n *\n * Example explicitly specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const template = 'Coordinate is ({x}|{y}).';\n *     const out = format(coord, template, 2);\n *     // out is now 'Coordinate is (7.85|47.98).'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {string} template A template string with `{x}` and `{y}` placeholders\n *     that will be replaced by first and second coordinate values.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Formatted coordinate.\n * @api\n */ function format(coordinate, template, fractionDigits) {\n    if (coordinate) {\n        return template.replace(\"{x}\", coordinate[0].toFixed(fractionDigits)).replace(\"{y}\", coordinate[1].toFixed(fractionDigits));\n    }\n    return \"\";\n}\n/**\n * @param {Coordinate} coordinate1 First coordinate.\n * @param {Coordinate} coordinate2 Second coordinate.\n * @return {boolean} The two coordinates are equal.\n */ function equals(coordinate1, coordinate2) {\n    let equals = true;\n    for(let i = coordinate1.length - 1; i >= 0; --i){\n        if (coordinate1[i] != coordinate2[i]) {\n            equals = false;\n            break;\n        }\n    }\n    return equals;\n}\n/**\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\n * returned by the function.\n *\n * Example:\n *\n *     import {rotate} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const rotateRadians = Math.PI / 2; // 90 degrees\n *     rotate(coord, rotateRadians);\n *     // coord is now [-47.983333, 7.85]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} angle Angle in radian.\n * @return {Coordinate} Coordinate.\n * @api\n */ function rotate(coordinate, angle) {\n    const cosAngle = Math.cos(angle);\n    const sinAngle = Math.sin(angle);\n    const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n    const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n    coordinate[0] = x;\n    coordinate[1] = y;\n    return coordinate;\n}\n/**\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {scale as scaleCoordinate} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const scale = 1.2;\n *     scaleCoordinate(coord, scale);\n *     // coord is now [9.42, 57.5799996]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} scale Scale factor.\n * @return {Coordinate} Coordinate.\n */ function scale(coordinate, scale) {\n    coordinate[0] *= scale;\n    coordinate[1] *= scale;\n    return coordinate;\n}\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Squared distance between coord1 and coord2.\n */ function squaredDistance(coord1, coord2) {\n    const dx = coord1[0] - coord2[0];\n    const dy = coord1[1] - coord2[1];\n    return dx * dx + dy * dy;\n}\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Distance between coord1 and coord2.\n */ function distance(coord1, coord2) {\n    return Math.sqrt(squaredDistance(coord1, coord2));\n}\n/**\n * Calculate the squared distance from a coordinate to a line segment.\n *\n * @param {Coordinate} coordinate Coordinate of the point.\n * @param {Array<Coordinate>} segment Line segment (2\n * coordinates).\n * @return {number} Squared distance from the point to the line segment.\n */ function squaredDistanceToSegment(coordinate, segment) {\n    return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\n}\n/**\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\n * seconds.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringHDMS} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringHDMS(coord);\n *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringHDMS} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringHDMS(coord, 1);\n *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Hemisphere, degrees, minutes and seconds.\n * @api\n */ function toStringHDMS(coordinate, fractionDigits) {\n    if (coordinate) {\n        return degreesToStringHDMS(\"NS\", coordinate[1], fractionDigits) + \" \" + degreesToStringHDMS(\"EW\", coordinate[0], fractionDigits);\n    }\n    return \"\";\n}\n/**\n * Format a coordinate as a comma delimited string.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringXY(coord);\n *     // out is now '8, 48'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringXY(coord, 1);\n *     // out is now '7.8, 48.0'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} XY.\n * @api\n */ function toStringXY(coordinate, fractionDigits) {\n    return format(coordinate, \"{x}, {y}\", fractionDigits);\n}\n/**\n * Modifies the provided coordinate in-place to be within the real world\n * extent. The lower projection extent boundary is inclusive, the upper one\n * exclusive.\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {Coordinate} The coordinate within the real world extent.\n */ function wrapX(coordinate, projection) {\n    if (projection.canWrapX()) {\n        const worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projection.getExtent());\n        const worldsAway = getWorldsAway(coordinate, projection, worldWidth);\n        if (worldsAway) {\n            coordinate[0] -= worldsAway * worldWidth;\n        }\n    }\n    return coordinate;\n}\n/**\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {number} [sourceExtentWidth] Width of the source extent.\n * @return {number} Offset in world widths.\n */ function getWorldsAway(coordinate, projection, sourceExtentWidth) {\n    const projectionExtent = projection.getExtent();\n    let worldsAway = 0;\n    if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {\n        sourceExtentWidth = sourceExtentWidth || (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projectionExtent);\n        worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);\n    }\n    return worldsAway;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2wvY29vcmRpbmF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FDb0M7QUFDSztBQUNKO0FBRXRDOzs7OztDQUtDLEdBRUQ7Ozs7OztDQU1DLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBU0ksSUFBSUMsVUFBVSxFQUFFQyxLQUFLO0lBQ25DRCxVQUFVLENBQUMsRUFBRSxJQUFJLENBQUNDLEtBQUssQ0FBQyxFQUFFO0lBQzFCRCxVQUFVLENBQUMsRUFBRSxJQUFJLENBQUNDLEtBQUssQ0FBQyxFQUFFO0lBQzFCLE9BQU9EO0FBQ1Q7QUFFQTs7Ozs7O0NBTUMsR0FDTSxTQUFTRSxnQkFBZ0JGLFVBQVUsRUFBRUcsTUFBTTtJQUNoRCxNQUFNQyxJQUFJRCxPQUFPRSxTQUFTO0lBQzFCLE1BQU1DLFNBQVNILE9BQU9JLFNBQVM7SUFDL0IsTUFBTUMsS0FBS0YsTUFBTSxDQUFDLEVBQUU7SUFDcEIsTUFBTUcsS0FBS0gsTUFBTSxDQUFDLEVBQUU7SUFDcEIsTUFBTUksS0FBS1YsVUFBVSxDQUFDLEVBQUU7SUFDeEIsTUFBTVcsS0FBS1gsVUFBVSxDQUFDLEVBQUU7SUFFeEIsSUFBSVksS0FBS0YsS0FBS0Y7SUFDZCxNQUFNSyxLQUFLRixLQUFLRjtJQUNoQixJQUFJRyxPQUFPLEtBQUtDLE9BQU8sR0FBRztRQUN4QkQsS0FBSztJQUNQO0lBQ0EsTUFBTUUsSUFBSUMsS0FBS0MsSUFBSSxDQUFDSixLQUFLQSxLQUFLQyxLQUFLQTtJQUVuQyxNQUFNSSxJQUFJVCxLQUFLLElBQUtJLEtBQU1FO0lBQzFCLE1BQU1JLElBQUlULEtBQUssSUFBS0ksS0FBTUM7SUFFMUIsT0FBTztRQUFDRztRQUFHQztLQUFFO0FBQ2Y7QUFFQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNNLFNBQVNDLGlCQUFpQm5CLFVBQVUsRUFBRW9CLE9BQU87SUFDbEQsTUFBTVosS0FBS1IsVUFBVSxDQUFD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Q0FBQyxFQUFFLElBQUl0RSxVQUFVLENBQUMsRUFBRSxHQUFHc0UsZ0JBQWdCLENBQUMsRUFBRSxHQUMzRTtRQUNBRCxvQkFBb0JBLHFCQUFxQjFFLG9EQUFRQSxDQUFDMkU7UUFDbERILGFBQWFwRCxLQUFLcUIsS0FBSyxDQUNyQixDQUFDcEMsVUFBVSxDQUFDLEVBQUUsR0FBR3NFLGdCQUFnQixDQUFDLEVBQUUsSUFBSUQ7SUFFNUM7SUFDQSxPQUFPRjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFwLy4vbm9kZV9tb2R1bGVzL29sL2Nvb3JkaW5hdGUuanM/MzI3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvY29vcmRpbmF0ZVxuICovXG5pbXBvcnQge2dldFdpZHRofSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge21vZHVsbywgdG9GaXhlZH0gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7cGFkTnVtYmVyfSBmcm9tICcuL3N0cmluZy5qcyc7XG5cbi8qKlxuICogQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgYW4gYHh5YCwgYHh5emAgb3IgYHh5em1gIGNvb3JkaW5hdGUuXG4gKiBFeGFtcGxlOiBgWzE2LCA0OF1gLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IENvb3JkaW5hdGVcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhbmRcbiAqIHRyYW5zZm9ybXMgaXQgaW50byBhIGB7c3RyaW5nfWAuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChDb29yZGluYXRlfHVuZGVmaW5lZCkpOiBzdHJpbmd9IENvb3JkaW5hdGVGb3JtYXRcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEFkZCBgZGVsdGFgIHRvIGBjb29yZGluYXRlYC4gYGNvb3JkaW5hdGVgIGlzIG1vZGlmaWVkIGluIHBsYWNlIGFuZCByZXR1cm5lZFxuICogYnkgdGhlIGZ1bmN0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCB7YWRkfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBhZGQoY29vcmQsIFstMiwgNF0pO1xuICogICAgIC8vIGNvb3JkIGlzIG5vdyBbNS44NSwgNTEuOTgzMzMzXVxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBkZWx0YSBEZWx0YS5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IFRoZSBpbnB1dCBjb29yZGluYXRlIGFkanVzdGVkIGJ5XG4gKiB0aGUgZ2l2ZW4gZGVsdGEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQoY29vcmRpbmF0ZSwgZGVsdGEpIHtcbiAgY29vcmRpbmF0ZVswXSArPSArZGVsdGFbMF07XG4gIGNvb3JkaW5hdGVbMV0gKz0gK2RlbHRhWzFdO1xuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBvbiB0aGUgcGFzc2VkIGNpcmNsZS5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gY2lyY2xlIFRoZSBjaXJjbGUuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBDbG9zZXN0IHBvaW50IG9uIHRoZSBjaXJjdW1mZXJlbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdE9uQ2lyY2xlKGNvb3JkaW5hdGUsIGNpcmNsZSkge1xuICBjb25zdCByID0gY2lyY2xlLmdldFJhZGl1cygpO1xuICBjb25zdCBjZW50ZXIgPSBjaXJjbGUuZ2V0Q2VudGVyKCk7XG4gIGNvbnN0IHgwID0gY2VudGVyWzBdO1xuICBjb25zdCB5MCA9IGNlbnRlclsxXTtcbiAgY29uc3QgeDEgPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5MSA9IGNvb3JkaW5hdGVbMV07XG5cbiAgbGV0IGR4ID0geDEgLSB4MDtcbiAgY29uc3QgZHkgPSB5MSAtIHkwO1xuICBpZiAoZHggPT09IDAgJiYgZHkgPT09IDApIHtcbiAgICBkeCA9IDE7XG4gIH1cbiAgY29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgY29uc3QgeCA9IHgwICsgKHIgKiBkeCkgLyBkO1xuICBjb25zdCB5ID0geTAgKyAociAqIGR5KSAvIGQ7XG5cbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBvbiB0aGUgcGFzc2VkIHNlZ21lbnQuXG4gKiBUaGlzIGlzIHRoZSBmb290IG9mIHRoZSBwZXJwZW5kaWN1bGFyIG9mIHRoZSBjb29yZGluYXRlIHRvIHRoZSBzZWdtZW50IHdoZW5cbiAqIHRoZSBmb290IGlzIG9uIHRoZSBzZWdtZW50LCBvciB0aGUgY2xvc2VzdCBzZWdtZW50IGNvb3JkaW5hdGUgd2hlbiB0aGUgZm9vdFxuICogaXMgb3V0c2lkZSB0aGUgc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0FycmF5PENvb3JkaW5hdGU+fSBzZWdtZW50IFRoZSB0d28gY29vcmRpbmF0ZXNcbiAqIG9mIHRoZSBzZWdtZW50LlxuICogQHJldHVybiB7Q29vcmRpbmF0ZX0gVGhlIGZvb3Qgb2YgdGhlIHBlcnBlbmRpY3VsYXIgb2ZcbiAqIHRoZSBjb29yZGluYXRlIHRvIHRoZSBzZWdtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdE9uU2VnbWVudChjb29yZGluYXRlLCBzZWdtZW50KSB7XG4gIGNvbnN0IHgwID0gY29vcmRpbmF0ZVswXTtcbiAgY29uc3QgeTAgPSBjb29yZGluYXRlWzFdO1xuICBjb25zdCBzdGFydCA9IHNlZ21lbnRbMF07XG4gIGNvbnN0IGVuZCA9IHNlZ21lbnRbMV07XG4gIGNvbnN0IHgxID0gc3RhcnRbMF07XG4gIGNvbnN0IHkxID0gc3RhcnRbMV07XG4gIGNvbnN0IHgyID0gZW5kWzBdO1xuICBjb25zdCB5MiA9IGVuZFsxXTtcbiAgY29uc3QgZHggPSB4MiAtIHgxO1xuICBjb25zdCBkeSA9IHkyIC0geTE7XG4gIGNvbnN0IGFsb25nID1cbiAgICBkeCA9PT0gMCAmJiBkeSA9PT0gMFxuICAgICAgPyAwXG4gICAgICA6IChkeCAqICh4MCAtIHgxKSArIGR5ICogKHkwIC0geTEpKSAvIChkeCAqIGR4ICsgZHkgKiBkeSB8fCAwKTtcbiAgbGV0IHgsIHk7XG4gIGlmIChhbG9uZyA8PSAwKSB7XG4gICAgeCA9IHgxO1xuICAgIHkgPSB5MTtcbiAgfSBlbHNlIGlmIChhbG9uZyA+PSAxKSB7XG4gICAgeCA9IHgyO1xuICAgIHkgPSB5MjtcbiAgfSBlbHNlIHtcbiAgICB4ID0geDEgKyBhbG9uZyAqIGR4O1xuICAgIHkgPSB5MSArIGFsb25nICogZHk7XG4gIH1cbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGVGb3JtYXR9IGZ1bmN0aW9uIHRoYXQgY2FuIGJlXG4gKiB1c2VkIHRvIGZvcm1hdFxuICogYSB7Q29vcmRpbmF0ZX0gdG8gYSBzdHJpbmcuXG4gKlxuICogRXhhbXBsZSB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge2NyZWF0ZVN0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCBzdHJpbmdpZnlGdW5jID0gY3JlYXRlU3RyaW5nWFkoKTtcbiAqICAgICBjb25zdCBvdXQgPSBzdHJpbmdpZnlGdW5jKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc4LCA0OCdcbiAqXG4gKiBFeGFtcGxlIHdpdGggZXhwbGljaXRseSBzcGVjaWZ5aW5nIDIgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7Y3JlYXRlU3RyaW5nWFl9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHN0cmluZ2lmeUZ1bmMgPSBjcmVhdGVTdHJpbmdYWSgyKTtcbiAqICAgICBjb25zdCBvdXQgPSBzdHJpbmdpZnlGdW5jKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc3Ljg1LCA0Ny45OCdcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZyYWN0aW9uRGlnaXRzXSBUaGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBpbmNsdWRlXG4gKiAgICBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gRGVmYXVsdCBpcyBgMGAuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlRm9ybWF0fSBDb29yZGluYXRlIGZvcm1hdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1hZKGZyYWN0aW9uRGlnaXRzKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgWFkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNvb3JkaW5hdGUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZ1hZKGNvb3JkaW5hdGUsIGZyYWN0aW9uRGlnaXRzKTtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGhlbWlzcGhlcmVzIEhlbWlzcGhlcmVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgRGVncmVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJhY3Rpb25EaWdpdHNdIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVncmVlc1RvU3RyaW5nSERNUyhoZW1pc3BoZXJlcywgZGVncmVlcywgZnJhY3Rpb25EaWdpdHMpIHtcbiAgY29uc3Qgbm9ybWFsaXplZERlZ3JlZXMgPSBtb2R1bG8oZGVncmVlcyArIDE4MCwgMzYwKSAtIDE4MDtcbiAgY29uc3QgeCA9IE1hdGguYWJzKDM2MDAgKiBub3JtYWxpemVkRGVncmVlcyk7XG4gIGNvbnN0IGRlY2ltYWxzID0gZnJhY3Rpb25EaWdpdHMgfHwgMDtcblxuICBsZXQgZGVnID0gTWF0aC5mbG9vcih4IC8gMzYwMCk7XG4gIGxldCBtaW4gPSBNYXRoLmZsb29yKCh4IC0gZGVnICogMzYwMCkgLyA2MCk7XG4gIGxldCBzZWMgPSB0b0ZpeGVkKHggLSBkZWcgKiAzNjAwIC0gbWluICogNjAsIGRlY2ltYWxzKTtcblxuICBpZiAoc2VjID49IDYwKSB7XG4gICAgc2VjID0gMDtcbiAgICBtaW4gKz0gMTtcbiAgfVxuXG4gIGlmIChtaW4gPj0gNjApIHtcbiAgICBtaW4gPSAwO1xuICAgIGRlZyArPSAxO1xuICB9XG5cbiAgbGV0IGhkbXMgPSBkZWcgKyAnXFx1MDBiMCc7XG4gIGlmIChtaW4gIT09IDAgfHwgc2VjICE9PSAwKSB7XG4gICAgaGRtcyArPSAnICcgKyBwYWROdW1iZXIobWluLCAyKSArICdcXHUyMDMyJztcbiAgfVxuICBpZiAoc2VjICE9PSAwKSB7XG4gICAgaGRtcyArPSAnICcgKyBwYWROdW1iZXIoc2VjLCAyLCBkZWNpbWFscykgKyAnXFx1MjAzMyc7XG4gIH1cbiAgaWYgKG5vcm1hbGl6ZWREZWdyZWVzICE9PSAwKSB7XG4gICAgaGRtcyArPSAnICcgKyBoZW1pc3BoZXJlcy5jaGFyQXQobm9ybWFsaXplZERlZ3JlZXMgPCAwID8gMSA6IDApO1xuICB9XG5cbiAgcmV0dXJuIGhkbXM7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IHRvIGEgc3RyaW5nXG4gKiB1c2luZyB0aGUgZ2l2ZW4gc3RyaW5nIHRlbXBsYXRlLiBUaGUgc3RyaW5ncyBge3h9YCBhbmQgYHt5fWAgaW4gdGhlIHRlbXBsYXRlXG4gKiB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGZpcnN0IGFuZCBzZWNvbmQgY29vcmRpbmF0ZSB2YWx1ZXMgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEV4YW1wbGUgd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHtmb3JtYXR9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHRlbXBsYXRlID0gJ0Nvb3JkaW5hdGUgaXMgKHt4fXx7eX0pLic7XG4gKiAgICAgY29uc3Qgb3V0ID0gZm9ybWF0KGNvb3JkLCB0ZW1wbGF0ZSk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnQ29vcmRpbmF0ZSBpcyAoOHw0OCkuJ1xuICpcbiAqIEV4YW1wbGUgZXhwbGljaXRseSBzcGVjaWZ5aW5nIHRoZSBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHtmb3JtYXR9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHRlbXBsYXRlID0gJ0Nvb3JkaW5hdGUgaXMgKHt4fXx7eX0pLic7XG4gKiAgICAgY29uc3Qgb3V0ID0gZm9ybWF0KGNvb3JkLCB0ZW1wbGF0ZSwgMik7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnQ29vcmRpbmF0ZSBpcyAoNy44NXw0Ny45OCkuJ1xuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIEEgdGVtcGxhdGUgc3RyaW5nIHdpdGggYHt4fWAgYW5kIGB7eX1gIHBsYWNlaG9sZGVyc1xuICogICAgIHRoYXQgd2lsbCBiZSByZXBsYWNlZCBieSBmaXJzdCBhbmQgc2Vjb25kIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcmFjdGlvbkRpZ2l0c10gVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7c3RyaW5nfSBGb3JtYXR0ZWQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChjb29yZGluYXRlLCB0ZW1wbGF0ZSwgZnJhY3Rpb25EaWdpdHMpIHtcbiAgaWYgKGNvb3JkaW5hdGUpIHtcbiAgICByZXR1cm4gdGVtcGxhdGVcbiAgICAgIC5yZXBsYWNlKCd7eH0nLCBjb29yZGluYXRlWzBdLnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpKVxuICAgICAgLnJlcGxhY2UoJ3t5fScsIGNvb3JkaW5hdGVbMV0udG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUxIEZpcnN0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUyIFNlY29uZCBjb29yZGluYXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHR3byBjb29yZGluYXRlcyBhcmUgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoY29vcmRpbmF0ZTEsIGNvb3JkaW5hdGUyKSB7XG4gIGxldCBlcXVhbHMgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gY29vcmRpbmF0ZTEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAoY29vcmRpbmF0ZTFbaV0gIT0gY29vcmRpbmF0ZTJbaV0pIHtcbiAgICAgIGVxdWFscyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlcXVhbHM7XG59XG5cbi8qKlxuICogUm90YXRlIGBjb29yZGluYXRlYCBieSBgYW5nbGVgLiBgY29vcmRpbmF0ZWAgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kXG4gKiByZXR1cm5lZCBieSB0aGUgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHtyb3RhdGV9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHJvdGF0ZVJhZGlhbnMgPSBNYXRoLlBJIC8gMjsgLy8gOTAgZGVncmVlc1xuICogICAgIHJvdGF0ZShjb29yZCwgcm90YXRlUmFkaWFucyk7XG4gKiAgICAgLy8gY29vcmQgaXMgbm93IFstNDcuOTgzMzMzLCA3Ljg1XVxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIEFuZ2xlIGluIHJhZGlhbi5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUoY29vcmRpbmF0ZSwgYW5nbGUpIHtcbiAgY29uc3QgY29zQW5nbGUgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIGNvbnN0IHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpO1xuICBjb25zdCB4ID0gY29vcmRpbmF0ZVswXSAqIGNvc0FuZ2xlIC0gY29vcmRpbmF0ZVsxXSAqIHNpbkFuZ2xlO1xuICBjb25zdCB5ID0gY29vcmRpbmF0ZVsxXSAqIGNvc0FuZ2xlICsgY29vcmRpbmF0ZVswXSAqIHNpbkFuZ2xlO1xuICBjb29yZGluYXRlWzBdID0geDtcbiAgY29vcmRpbmF0ZVsxXSA9IHk7XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG4vKipcbiAqIFNjYWxlIGBjb29yZGluYXRlYCBieSBgc2NhbGVgLiBgY29vcmRpbmF0ZWAgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kIHJldHVybmVkXG4gKiBieSB0aGUgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHtzY2FsZSBhcyBzY2FsZUNvb3JkaW5hdGV9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHNjYWxlID0gMS4yO1xuICogICAgIHNjYWxlQ29vcmRpbmF0ZShjb29yZCwgc2NhbGUpO1xuICogICAgIC8vIGNvb3JkIGlzIG5vdyBbOS40MiwgNTcuNTc5OTk5Nl1cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBTY2FsZSBmYWN0b3IuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUoY29vcmRpbmF0ZSwgc2NhbGUpIHtcbiAgY29vcmRpbmF0ZVswXSAqPSBzY2FsZTtcbiAgY29vcmRpbmF0ZVsxXSAqPSBzY2FsZTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZDEgRmlyc3QgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmQyIFNlY29uZCBjb29yZGluYXRlLlxuICogQHJldHVybiB7bnVtYmVyfSBTcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gY29vcmQxIGFuZCBjb29yZDIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoY29vcmQxLCBjb29yZDIpIHtcbiAgY29uc3QgZHggPSBjb29yZDFbMF0gLSBjb29yZDJbMF07XG4gIGNvbnN0IGR5ID0gY29vcmQxWzFdIC0gY29vcmQyWzFdO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZDEgRmlyc3QgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmQyIFNlY29uZCBjb29yZGluYXRlLlxuICogQHJldHVybiB7bnVtYmVyfSBEaXN0YW5jZSBiZXR3ZWVuIGNvb3JkMSBhbmQgY29vcmQyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoY29vcmQxLCBjb29yZDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzcXVhcmVkRGlzdGFuY2UoY29vcmQxLCBjb29yZDIpKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHNxdWFyZWQgZGlzdGFuY2UgZnJvbSBhIGNvb3JkaW5hdGUgdG8gYSBsaW5lIHNlZ21lbnQuXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICogQHBhcmFtIHtBcnJheTxDb29yZGluYXRlPn0gc2VnbWVudCBMaW5lIHNlZ21lbnQgKDJcbiAqIGNvb3JkaW5hdGVzKS5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgbGluZSBzZWdtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlVG9TZWdtZW50KGNvb3JkaW5hdGUsIHNlZ21lbnQpIHtcbiAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZShjb29yZGluYXRlLCBjbG9zZXN0T25TZWdtZW50KGNvb3JkaW5hdGUsIHNlZ21lbnQpKTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBnZW9ncmFwaGljIGNvb3JkaW5hdGUgd2l0aCB0aGUgaGVtaXNwaGVyZSwgZGVncmVlcywgbWludXRlcywgYW5kXG4gKiBzZWNvbmRzLlxuICpcbiAqIEV4YW1wbGUgd2l0aG91dCBzcGVjaWZ5aW5nIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge3RvU3RyaW5nSERNU30gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgY29uc3Qgb3V0ID0gdG9TdHJpbmdIRE1TKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc0N8KwIDU44oCyIDYw4oCzIE4gN8KwIDUw4oCyIDYw4oCzIEUnXG4gKlxuICogRXhhbXBsZSBleHBsaWNpdGx5IHNwZWNpZnlpbmcgMSBmcmFjdGlvbmFsIGRpZ2l0OlxuICpcbiAqICAgICBpbXBvcnQge3RvU3RyaW5nSERNU30gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgY29uc3Qgb3V0ID0gdG9TdHJpbmdIRE1TKGNvb3JkLCAxKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc0N8KwIDU44oCyIDYwLjDigLMgTiA3wrAgNTDigLIgNjAuMOKAsyBFJ1xuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcmFjdGlvbkRpZ2l0c10gVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7c3RyaW5nfSBIZW1pc3BoZXJlLCBkZWdyZWVzLCBtaW51dGVzIGFuZCBzZWNvbmRzLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdIRE1TKGNvb3JkaW5hdGUsIGZyYWN0aW9uRGlnaXRzKSB7XG4gIGlmIChjb29yZGluYXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGRlZ3JlZXNUb1N0cmluZ0hETVMoJ05TJywgY29vcmRpbmF0ZVsxXSwgZnJhY3Rpb25EaWdpdHMpICtcbiAgICAgICcgJyArXG4gICAgICBkZWdyZWVzVG9TdHJpbmdIRE1TKCdFVycsIGNvb3JkaW5hdGVbMF0sIGZyYWN0aW9uRGlnaXRzKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIGNvb3JkaW5hdGUgYXMgYSBjb21tYSBkZWxpbWl0ZWQgc3RyaW5nLlxuICpcbiAqIEV4YW1wbGUgd2l0aG91dCBzcGVjaWZ5aW5nIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge3RvU3RyaW5nWFl9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IG91dCA9IHRvU3RyaW5nWFkoY29vcmQpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzgsIDQ4J1xuICpcbiAqIEV4YW1wbGUgZXhwbGljaXRseSBzcGVjaWZ5aW5nIDEgZnJhY3Rpb25hbCBkaWdpdDpcbiAqXG4gKiAgICAgaW1wb3J0IHt0b1N0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCBvdXQgPSB0b1N0cmluZ1hZKGNvb3JkLCAxKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc3LjgsIDQ4LjAnXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZyYWN0aW9uRGlnaXRzXSBUaGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBpbmNsdWRlXG4gKiAgICBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gRGVmYXVsdCBpcyBgMGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFhZLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdYWShjb29yZGluYXRlLCBmcmFjdGlvbkRpZ2l0cykge1xuICByZXR1cm4gZm9ybWF0KGNvb3JkaW5hdGUsICd7eH0sIHt5fScsIGZyYWN0aW9uRGlnaXRzKTtcbn1cblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZSBpbi1wbGFjZSB0byBiZSB3aXRoaW4gdGhlIHJlYWwgd29ybGRcbiAqIGV4dGVudC4gVGhlIGxvd2VyIHByb2plY3Rpb24gZXh0ZW50IGJvdW5kYXJ5IGlzIGluY2x1c2l2ZSwgdGhlIHVwcGVyIG9uZVxuICogZXhjbHVzaXZlLlxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBUaGUgY29vcmRpbmF0ZSB3aXRoaW4gdGhlIHJlYWwgd29ybGQgZXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcFgoY29vcmRpbmF0ZSwgcHJvamVjdGlvbikge1xuICBpZiAocHJvamVjdGlvbi5jYW5XcmFwWCgpKSB7XG4gICAgY29uc3Qgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb24uZ2V0RXh0ZW50KCkpO1xuICAgIGNvbnN0IHdvcmxkc0F3YXkgPSBnZXRXb3JsZHNBd2F5KGNvb3JkaW5hdGUsIHByb2plY3Rpb24sIHdvcmxkV2lkdGgpO1xuICAgIGlmICh3b3JsZHNBd2F5KSB7XG4gICAgICBjb29yZGluYXRlWzBdIC09IHdvcmxkc0F3YXkgKiB3b3JsZFdpZHRoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cbi8qKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc291cmNlRXh0ZW50V2lkdGhdIFdpZHRoIG9mIHRoZSBzb3VyY2UgZXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBPZmZzZXQgaW4gd29ybGQgd2lkdGhzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V29ybGRzQXdheShjb29yZGluYXRlLCBwcm9qZWN0aW9uLCBzb3VyY2VFeHRlbnRXaWR0aCkge1xuICBjb25zdCBwcm9qZWN0aW9uRXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgbGV0IHdvcmxkc0F3YXkgPSAwO1xuICBpZiAoXG4gICAgcHJvamVjdGlvbi5jYW5XcmFwWCgpICYmXG4gICAgKGNvb3JkaW5hdGVbMF0gPCBwcm9qZWN0aW9uRXh0ZW50WzBdIHx8IGNvb3JkaW5hdGVbMF0gPiBwcm9qZWN0aW9uRXh0ZW50WzJdKVxuICApIHtcbiAgICBzb3VyY2VFeHRlbnRXaWR0aCA9IHNvdXJjZUV4dGVudFdpZHRoIHx8IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuICAgIHdvcmxkc0F3YXkgPSBNYXRoLmZsb29yKFxuICAgICAgKGNvb3JkaW5hdGVbMF0gLSBwcm9qZWN0aW9uRXh0ZW50WzBdKSAvIHNvdXJjZUV4dGVudFdpZHRoXG4gICAgKTtcbiAgfVxuICByZXR1cm4gd29ybGRzQXdheTtcbn1cbiJdLCJuYW1lcyI6WyJnZXRXaWR0aCIsIm1vZHVsbyIsInRvRml4ZWQiLCJwYWROdW1iZXIiLCJhZGQiLCJjb29yZGluYXRlIiwiZGVsdGEiLCJjbG9zZXN0T25DaXJjbGUiLCJjaXJjbGUiLCJyIiwiZ2V0UmFkaXVzIiwiY2VudGVyIiwiZ2V0Q2VudGVyIiwieDAiLCJ5MCIsIngxIiwieTEiLCJkeCIsImR5IiwiZCIsIk1hdGgiLCJzcXJ0IiwieCIsInkiLCJjbG9zZXN0T25TZWdtZW50Iiwic2VnbWVudCIsInN0YXJ0IiwiZW5kIiwieDIiLCJ5MiIsImFsb25nIiwiY3JlYXRlU3RyaW5nWFkiLCJmcmFjdGlvbkRpZ2l0cyIsInRvU3RyaW5nWFkiLCJkZWdyZWVzVG9TdHJpbmdIRE1TIiwiaGVtaXNwaGVyZXMiLCJkZWdyZWVzIiwibm9ybWFsaXplZERlZ3JlZXMiLCJhYnMiLCJkZWNpbWFscyIsImRlZyIsImZsb29yIiwibWluIiwic2VjIiwiaGRtcyIsImNoYXJBdCIsImZvcm1hdCIsInRlbXBsYXRlIiwicmVwbGFjZSIsImVxdWFscyIsImNvb3JkaW5hdGUxIiwiY29vcmRpbmF0ZTIiLCJpIiwibGVuZ3RoIiwicm90YXRlIiwiYW5nbGUiLCJjb3NBbmdsZSIsImNvcyIsInNpbkFuZ2xlIiwic2luIiwic2NhbGUiLCJzcXVhcmVkRGlzdGFuY2UiLCJjb29yZDEiLCJjb29yZDIiLCJkaXN0YW5jZSIsInNxdWFyZWREaXN0YW5jZVRvU2VnbWVudCIsInRvU3RyaW5nSERNUyIsIndyYXBYIiwicHJvamVjdGlvbiIsImNhbldyYXBYIiwid29ybGRXaWR0aCIsImdldEV4dGVudCIsIndvcmxkc0F3YXkiLCJnZXRXb3JsZHNBd2F5Iiwic291cmNlRXh0ZW50V2lkdGgiLCJwcm9qZWN0aW9uRXh0ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/coordinate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ol/extent.js":
/*!***********************************!*\
  !*** ./node_modules/ol/extent.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyTransform: () => (/* binding */ applyTransform),\n/* harmony export */   approximatelyEquals: () => (/* binding */ approximatelyEquals),\n/* harmony export */   boundingExtent: () => (/* binding */ boundingExtent),\n/* harmony export */   buffer: () => (/* binding */ buffer),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   closestSquaredDistanceXY: () => (/* binding */ closestSquaredDistanceXY),\n/* harmony export */   containsCoordinate: () => (/* binding */ containsCoordinate),\n/* harmony export */   containsExtent: () => (/* binding */ containsExtent),\n/* harmony export */   containsXY: () => (/* binding */ containsXY),\n/* harmony export */   coordinateRelationship: () => (/* binding */ coordinateRelationship),\n/* harmony export */   createEmpty: () => (/* binding */ createEmpty),\n/* harmony export */   createOrUpdate: () => (/* binding */ createOrUpdate),\n/* harmony export */   createOrUpdateEmpty: () => (/* binding */ createOrUpdateEmpty),\n/* harmony export */   createOrUpdateFromCoordinate: () => (/* binding */ createOrUpdateFromCoordinate),\n/* harmony export */   createOrUpdateFromCoordinates: () => (/* binding */ createOrUpdateFromCoordinates),\n/* harmony export */   createOrUpdateFromFlatCoordinates: () => (/* binding */ createOrUpdateFromFlatCoordinates),\n/* harmony export */   createOrUpdateFromRings: () => (/* binding */ createOrUpdateFromRings),\n/* harmony export */   equals: () => (/* binding */ equals),\n/* harmony export */   extend: () => (/* binding */ extend),\n/* harmony export */   extendCoordinate: () => (/* binding */ extendCoordinate),\n/* harmony export */   extendCoordinates: () => (/* binding */ extendCoordinates),\n/* harmony export */   extendFlatCoordinates: () => (/* binding */ extendFlatCoordinates),\n/* harmony export */   extendRings: () => (/* binding */ extendRings),\n/* harmony export */   extendXY: () => (/* binding */ extendXY),\n/* harmony export */   forEachCorner: () => (/* binding */ forEachCorner),\n/* harmony export */   getArea: () => (/* binding */ getArea),\n/* harmony export */   getBottomLeft: () => (/* binding */ getBottomLeft),\n/* harmony export */   getBottomRight: () => (/* binding */ getBottomRight),\n/* harmony export */   getCenter: () => (/* binding */ getCenter),\n/* harmony export */   getCorner: () => (/* binding */ getCorner),\n/* harmony export */   getEnlargedArea: () => (/* binding */ getEnlargedArea),\n/* harmony export */   getForViewAndSize: () => (/* binding */ getForViewAndSize),\n/* harmony export */   getHeight: () => (/* binding */ getHeight),\n/* harmony export */   getIntersection: () => (/* binding */ getIntersection),\n/* harmony export */   getIntersectionArea: () => (/* binding */ getIntersectionArea),\n/* harmony export */   getMargin: () => (/* binding */ getMargin),\n/* harmony export */   getRotatedViewport: () => (/* binding */ getRotatedViewport),\n/* harmony export */   getSize: () => (/* binding */ getSize),\n/* harmony export */   getTopLeft: () => (/* binding */ getTopLeft),\n/* harmony export */   getTopRight: () => (/* binding */ getTopRight),\n/* harmony export */   getWidth: () => (/* binding */ getWidth),\n/* harmony export */   intersects: () => (/* binding */ intersects),\n/* harmony export */   intersectsSegment: () => (/* binding */ intersectsSegment),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   returnOrUpdate: () => (/* binding */ returnOrUpdate),\n/* harmony export */   scaleFromCenter: () => (/* binding */ scaleFromCenter),\n/* harmony export */   wrapAndSliceX: () => (/* binding */ wrapAndSliceX),\n/* harmony export */   wrapX: () => (/* binding */ wrapX)\n/* harmony export */ });\n/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extent/Relationship.js */ \"(ssr)/./node_modules/ol/extent/Relationship.js\");\n/**\n * @module ol/extent\n */ \n/**\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\n * @typedef {Array<number>} Extent\n * @api\n */ /**\n * Extent corner.\n * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner\n */ /**\n * Build an extent that includes all given coordinates.\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Bounding extent.\n * @api\n */ function boundingExtent(coordinates) {\n    const extent = createEmpty();\n    for(let i = 0, ii = coordinates.length; i < ii; ++i){\n        extendCoordinate(extent, coordinates[i]);\n    }\n    return extent;\n}\n/**\n * @param {Array<number>} xs Xs.\n * @param {Array<number>} ys Ys.\n * @param {Extent} [dest] Destination extent.\n * @private\n * @return {Extent} Extent.\n */ function _boundingExtentXYs(xs, ys, dest) {\n    const minX = Math.min.apply(null, xs);\n    const minY = Math.min.apply(null, ys);\n    const maxX = Math.max.apply(null, xs);\n    const maxY = Math.max.apply(null, ys);\n    return createOrUpdate(minX, minY, maxX, maxY, dest);\n}\n/**\n * Return extent increased by the provided value.\n * @param {Extent} extent Extent.\n * @param {number} value The amount by which the extent should be buffered.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n * @api\n */ function buffer(extent, value, dest) {\n    if (dest) {\n        dest[0] = extent[0] - value;\n        dest[1] = extent[1] - value;\n        dest[2] = extent[2] + value;\n        dest[3] = extent[3] + value;\n        return dest;\n    }\n    return [\n        extent[0] - value,\n        extent[1] - value,\n        extent[2] + value,\n        extent[3] + value\n    ];\n}\n/**\n * Creates a clone of an extent.\n *\n * @param {Extent} extent Extent to clone.\n * @param {Extent} [dest] Extent.\n * @return {Extent} The clone.\n */ function clone(extent, dest) {\n    if (dest) {\n        dest[0] = extent[0];\n        dest[1] = extent[1];\n        dest[2] = extent[2];\n        dest[3] = extent[3];\n        return dest;\n    }\n    return extent.slice();\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {number} Closest squared distance.\n */ function closestSquaredDistanceXY(extent, x, y) {\n    let dx, dy;\n    if (x < extent[0]) {\n        dx = extent[0] - x;\n    } else if (extent[2] < x) {\n        dx = x - extent[2];\n    } else {\n        dx = 0;\n    }\n    if (y < extent[1]) {\n        dy = extent[1] - y;\n    } else if (extent[3] < y) {\n        dy = y - extent[3];\n    } else {\n        dy = 0;\n    }\n    return dx * dx + dy * dy;\n}\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @return {boolean} The coordinate is contained in the extent.\n * @api\n */ function containsCoordinate(extent, coordinate) {\n    return containsXY(extent, coordinate[0], coordinate[1]);\n}\n/**\n * Check if one extent contains another.\n *\n * An extent is deemed contained if it lies completely within the other extent,\n * including if they share one or more edges.\n *\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The second extent is contained by or on the edge of the\n *     first.\n * @api\n */ function containsExtent(extent1, extent2) {\n    return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];\n}\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n * @return {boolean} The x, y values are contained in the extent.\n * @api\n */ function containsXY(extent, x, y) {\n    return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n}\n/**\n * Get the relationship between a coordinate and extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\n *     import(\"./extent/Relationship.js\").Relationship).\n */ function coordinateRelationship(extent, coordinate) {\n    const minX = extent[0];\n    const minY = extent[1];\n    const maxX = extent[2];\n    const maxY = extent[3];\n    const x = coordinate[0];\n    const y = coordinate[1];\n    let relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UNKNOWN;\n    if (x < minX) {\n        relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEFT;\n    } else if (x > maxX) {\n        relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].RIGHT;\n    }\n    if (y < minY) {\n        relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BELOW;\n    } else if (y > maxY) {\n        relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ABOVE;\n    }\n    if (relationship === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].UNKNOWN) {\n        relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].INTERSECTING;\n    }\n    return relationship;\n}\n/**\n * Create an empty extent.\n * @return {Extent} Empty extent.\n * @api\n */ function createEmpty() {\n    return [\n        Infinity,\n        Infinity,\n        -Infinity,\n        -Infinity\n    ];\n}\n/**\n * Create a new extent or update the provided extent.\n * @param {number} minX Minimum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxX Maximum X.\n * @param {number} maxY Maximum Y.\n * @param {Extent} [dest] Destination extent.\n * @return {Extent} Extent.\n */ function createOrUpdate(minX, minY, maxX, maxY, dest) {\n    if (dest) {\n        dest[0] = minX;\n        dest[1] = minY;\n        dest[2] = maxX;\n        dest[3] = maxY;\n        return dest;\n    }\n    return [\n        minX,\n        minY,\n        maxX,\n        maxY\n    ];\n}\n/**\n * Create a new empty extent or make the provided one empty.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */ function createOrUpdateEmpty(dest) {\n    return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */ function createOrUpdateFromCoordinate(coordinate, dest) {\n    const x = coordinate[0];\n    const y = coordinate[1];\n    return createOrUpdate(x, y, x, y, dest);\n}\n/**\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */ function createOrUpdateFromCoordinates(coordinates, dest) {\n    const extent = createOrUpdateEmpty(dest);\n    return extendCoordinates(extent, coordinates);\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */ function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {\n    const extent = createOrUpdateEmpty(dest);\n    return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\n}\n/**\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */ function createOrUpdateFromRings(rings, dest) {\n    const extent = createOrUpdateEmpty(dest);\n    return extendRings(extent, rings);\n}\n/**\n * Determine if two extents are equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The two extents are equivalent.\n * @api\n */ function equals(extent1, extent2) {\n    return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];\n}\n/**\n * Determine if two extents are approximately equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {number} tolerance Tolerance in extent coordinate units.\n * @return {boolean} The two extents differ by less than the tolerance.\n */ function approximatelyEquals(extent1, extent2, tolerance) {\n    return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;\n}\n/**\n * Modify an extent to include another extent.\n * @param {Extent} extent1 The extent to be modified.\n * @param {Extent} extent2 The extent that will be included in the first.\n * @return {Extent} A reference to the first (extended) extent.\n * @api\n */ function extend(extent1, extent2) {\n    if (extent2[0] < extent1[0]) {\n        extent1[0] = extent2[0];\n    }\n    if (extent2[2] > extent1[2]) {\n        extent1[2] = extent2[2];\n    }\n    if (extent2[1] < extent1[1]) {\n        extent1[1] = extent2[1];\n    }\n    if (extent2[3] > extent1[3]) {\n        extent1[3] = extent2[3];\n    }\n    return extent1;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n */ function extendCoordinate(extent, coordinate) {\n    if (coordinate[0] < extent[0]) {\n        extent[0] = coordinate[0];\n    }\n    if (coordinate[0] > extent[2]) {\n        extent[2] = coordinate[0];\n    }\n    if (coordinate[1] < extent[1]) {\n        extent[1] = coordinate[1];\n    }\n    if (coordinate[1] > extent[3]) {\n        extent[3] = coordinate[1];\n    }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Extent.\n */ function extendCoordinates(extent, coordinates) {\n    for(let i = 0, ii = coordinates.length; i < ii; ++i){\n        extendCoordinate(extent, coordinates[i]);\n    }\n    return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Extent} Extent.\n */ function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {\n    for(; offset < end; offset += stride){\n        extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n    }\n    return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @return {Extent} Extent.\n */ function extendRings(extent, rings) {\n    for(let i = 0, ii = rings.length; i < ii; ++i){\n        extendCoordinates(extent, rings[i]);\n    }\n    return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n */ function extendXY(extent, x, y) {\n    extent[0] = Math.min(extent[0], x);\n    extent[1] = Math.min(extent[1], y);\n    extent[2] = Math.max(extent[2], x);\n    extent[3] = Math.max(extent[3], y);\n}\n/**\n * This function calls `callback` for each corner of the extent. If the\n * callback returns a truthy value the function returns that value\n * immediately. Otherwise the function returns `false`.\n * @param {Extent} extent Extent.\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\n * @return {S|boolean} Value.\n * @template S\n */ function forEachCorner(extent, callback) {\n    let val;\n    val = callback(getBottomLeft(extent));\n    if (val) {\n        return val;\n    }\n    val = callback(getBottomRight(extent));\n    if (val) {\n        return val;\n    }\n    val = callback(getTopRight(extent));\n    if (val) {\n        return val;\n    }\n    val = callback(getTopLeft(extent));\n    if (val) {\n        return val;\n    }\n    return false;\n}\n/**\n * Get the size of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Area.\n * @api\n */ function getArea(extent) {\n    let area = 0;\n    if (!isEmpty(extent)) {\n        area = getWidth(extent) * getHeight(extent);\n    }\n    return area;\n}\n/**\n * Get the bottom left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\n * @api\n */ function getBottomLeft(extent) {\n    return [\n        extent[0],\n        extent[1]\n    ];\n}\n/**\n * Get the bottom right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\n * @api\n */ function getBottomRight(extent) {\n    return [\n        extent[2],\n        extent[1]\n    ];\n}\n/**\n * Get the center coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Center.\n * @api\n */ function getCenter(extent) {\n    return [\n        (extent[0] + extent[2]) / 2,\n        (extent[1] + extent[3]) / 2\n    ];\n}\n/**\n * Get a corner coordinate of an extent.\n * @param {Extent} extent Extent.\n * @param {Corner} corner Corner.\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\n */ function getCorner(extent, corner) {\n    let coordinate;\n    if (corner === \"bottom-left\") {\n        coordinate = getBottomLeft(extent);\n    } else if (corner === \"bottom-right\") {\n        coordinate = getBottomRight(extent);\n    } else if (corner === \"top-left\") {\n        coordinate = getTopLeft(extent);\n    } else if (corner === \"top-right\") {\n        coordinate = getTopRight(extent);\n    } else {\n        throw new Error(\"Invalid corner\");\n    }\n    return coordinate;\n}\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Enlarged area.\n */ function getEnlargedArea(extent1, extent2) {\n    const minX = Math.min(extent1[0], extent2[0]);\n    const minY = Math.min(extent1[1], extent2[1]);\n    const maxX = Math.max(extent1[2], extent2[2]);\n    const maxY = Math.max(extent1[3], extent2[3]);\n    return (maxX - minX) * (maxY - minY);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @param {Extent} [dest] Destination extent.\n * @return {Extent} Extent.\n */ function getForViewAndSize(center, resolution, rotation, size, dest) {\n    const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(center, resolution, rotation, size);\n    return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), dest);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @return {Array<number>} Linear ring representing the viewport.\n */ function getRotatedViewport(center, resolution, rotation, size) {\n    const dx = resolution * size[0] / 2;\n    const dy = resolution * size[1] / 2;\n    const cosRotation = Math.cos(rotation);\n    const sinRotation = Math.sin(rotation);\n    const xCos = dx * cosRotation;\n    const xSin = dx * sinRotation;\n    const yCos = dy * cosRotation;\n    const ySin = dy * sinRotation;\n    const x = center[0];\n    const y = center[1];\n    return [\n        x - xCos + ySin,\n        y - xSin - yCos,\n        x - xCos - ySin,\n        y - xSin + yCos,\n        x + xCos - ySin,\n        y + xSin + yCos,\n        x + xCos + ySin,\n        y + xSin - yCos,\n        x - xCos + ySin,\n        y - xSin - yCos\n    ];\n}\n/**\n * Get the height of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Height.\n * @api\n */ function getHeight(extent) {\n    return extent[3] - extent[1];\n}\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Intersection area.\n */ function getIntersectionArea(extent1, extent2) {\n    const intersection = getIntersection(extent1, extent2);\n    return getArea(intersection);\n}\n/**\n * Get the intersection of two extents.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {Extent} [dest] Optional extent to populate with intersection.\n * @return {Extent} Intersecting extent.\n * @api\n */ function getIntersection(extent1, extent2, dest) {\n    const intersection = dest ? dest : createEmpty();\n    if (intersects(extent1, extent2)) {\n        if (extent1[0] > extent2[0]) {\n            intersection[0] = extent1[0];\n        } else {\n            intersection[0] = extent2[0];\n        }\n        if (extent1[1] > extent2[1]) {\n            intersection[1] = extent1[1];\n        } else {\n            intersection[1] = extent2[1];\n        }\n        if (extent1[2] < extent2[2]) {\n            intersection[2] = extent1[2];\n        } else {\n            intersection[2] = extent2[2];\n        }\n        if (extent1[3] < extent2[3]) {\n            intersection[3] = extent1[3];\n        } else {\n            intersection[3] = extent2[3];\n        }\n    } else {\n        createOrUpdateEmpty(intersection);\n    }\n    return intersection;\n}\n/**\n * @param {Extent} extent Extent.\n * @return {number} Margin.\n */ function getMargin(extent) {\n    return getWidth(extent) + getHeight(extent);\n}\n/**\n * Get the size (width, height) of an extent.\n * @param {Extent} extent The extent.\n * @return {import(\"./size.js\").Size} The extent size.\n * @api\n */ function getSize(extent) {\n    return [\n        extent[2] - extent[0],\n        extent[3] - extent[1]\n    ];\n}\n/**\n * Get the top left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\n * @api\n */ function getTopLeft(extent) {\n    return [\n        extent[0],\n        extent[3]\n    ];\n}\n/**\n * Get the top right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\n * @api\n */ function getTopRight(extent) {\n    return [\n        extent[2],\n        extent[3]\n    ];\n}\n/**\n * Get the width of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Width.\n * @api\n */ function getWidth(extent) {\n    return extent[2] - extent[0];\n}\n/**\n * Determine if one extent intersects another.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent.\n * @return {boolean} The two extents intersect.\n * @api\n */ function intersects(extent1, extent2) {\n    return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];\n}\n/**\n * Determine if an extent is empty.\n * @param {Extent} extent Extent.\n * @return {boolean} Is empty.\n * @api\n */ function isEmpty(extent) {\n    return extent[2] < extent[0] || extent[3] < extent[1];\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */ function returnOrUpdate(extent, dest) {\n    if (dest) {\n        dest[0] = extent[0];\n        dest[1] = extent[1];\n        dest[2] = extent[2];\n        dest[3] = extent[3];\n        return dest;\n    }\n    return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} value Value.\n */ function scaleFromCenter(extent, value) {\n    const deltaX = (extent[2] - extent[0]) / 2 * (value - 1);\n    const deltaY = (extent[3] - extent[1]) / 2 * (value - 1);\n    extent[0] -= deltaX;\n    extent[2] += deltaX;\n    extent[1] -= deltaY;\n    extent[3] += deltaY;\n}\n/**\n * Determine if the segment between two coordinates intersects (crosses,\n * touches, or is contained by) the provided extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\n * @return {boolean} The segment intersects the extent.\n */ function intersectsSegment(extent, start, end) {\n    let intersects = false;\n    const startRel = coordinateRelationship(extent, start);\n    const endRel = coordinateRelationship(extent, end);\n    if (startRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].INTERSECTING || endRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].INTERSECTING) {\n        intersects = true;\n    } else {\n        const minX = extent[0];\n        const minY = extent[1];\n        const maxX = extent[2];\n        const maxY = extent[3];\n        const startX = start[0];\n        const startY = start[1];\n        const endX = end[0];\n        const endY = end[1];\n        const slope = (endY - startY) / (endX - startX);\n        let x, y;\n        if (!!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ABOVE) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ABOVE)) {\n            // potentially intersects top\n            x = endX - (endY - maxY) / slope;\n            intersects = x >= minX && x <= maxX;\n        }\n        if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].RIGHT) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].RIGHT)) {\n            // potentially intersects right\n            y = endY - (endX - maxX) * slope;\n            intersects = y >= minY && y <= maxY;\n        }\n        if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BELOW) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BELOW)) {\n            // potentially intersects bottom\n            x = endX - (endY - minY) / slope;\n            intersects = x >= minX && x <= maxX;\n        }\n        if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEFT) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEFT)) {\n            // potentially intersects left\n            y = endY - (endX - minX) * slope;\n            intersects = y >= minY && y <= maxY;\n        }\n    }\n    return intersects;\n}\n/**\n * Apply a transform function to the extent.\n * @param {Extent} extent Extent.\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\n * @param {Extent} [dest] Destination extent.\n * @param {number} [stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {Extent} Extent.\n * @api\n */ function applyTransform(extent, transformFn, dest, stops) {\n    if (isEmpty(extent)) {\n        return createOrUpdateEmpty(dest);\n    }\n    let coordinates = [];\n    if (stops > 1) {\n        const width = extent[2] - extent[0];\n        const height = extent[3] - extent[1];\n        for(let i = 0; i < stops; ++i){\n            coordinates.push(extent[0] + width * i / stops, extent[1], extent[2], extent[1] + height * i / stops, extent[2] - width * i / stops, extent[3], extent[0], extent[3] - height * i / stops);\n        }\n    } else {\n        coordinates = [\n            extent[0],\n            extent[1],\n            extent[2],\n            extent[1],\n            extent[2],\n            extent[3],\n            extent[0],\n            extent[3]\n        ];\n    }\n    transformFn(coordinates, coordinates, 2);\n    const xs = [];\n    const ys = [];\n    for(let i = 0, l = coordinates.length; i < l; i += 2){\n        xs.push(coordinates[i]);\n        ys.push(coordinates[i + 1]);\n    }\n    return _boundingExtentXYs(xs, ys, dest);\n}\n/**\n * Modifies the provided extent in-place to be within the real world\n * extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Extent} The extent within the real world extent.\n */ function wrapX(extent, projection) {\n    const projectionExtent = projection.getExtent();\n    const center = getCenter(extent);\n    if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {\n        const worldWidth = getWidth(projectionExtent);\n        const worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);\n        const offset = worldsAway * worldWidth;\n        extent[0] -= offset;\n        extent[2] -= offset;\n    }\n    return extent;\n}\n/**\n * Fits the extent to the real world\n *\n * If the extent does not cross the anti meridian, this will return the extent in an array\n * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the\n * real world\n *\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Array<Extent>} The extent within the real world extent.\n */ function wrapAndSliceX(extent, projection) {\n    if (projection.canWrapX()) {\n        const projectionExtent = projection.getExtent();\n        if (!isFinite(extent[0]) || !isFinite(extent[2])) {\n            return [\n                [\n                    projectionExtent[0],\n                    extent[1],\n                    projectionExtent[2],\n                    extent[3]\n                ]\n            ];\n        }\n        wrapX(extent, projection);\n        const worldWidth = getWidth(projectionExtent);\n        if (getWidth(extent) > worldWidth) {\n            // the extent wraps around on itself\n            return [\n                [\n                    projectionExtent[0],\n                    extent[1],\n                    projectionExtent[2],\n                    extent[3]\n                ]\n            ];\n        }\n        if (extent[0] < projectionExtent[0]) {\n            // the extent crosses the anti meridian, so it needs to be sliced\n            return [\n                [\n                    extent[0] + worldWidth,\n                    extent[1],\n                    projectionExtent[2],\n                    extent[3]\n                ],\n                [\n                    projectionExtent[0],\n                    extent[1],\n                    extent[2],\n                    extent[3]\n                ]\n            ];\n        }\n        if (extent[2] > projectionExtent[2]) {\n            // the extent crosses the anti meridian, so it needs to be sliced\n            return [\n                [\n                    extent[0],\n                    extent[1],\n                    projectionExtent[2],\n                    extent[3]\n                ],\n                [\n                    projectionExtent[0],\n                    extent[1],\n                    extent[2] - worldWidth,\n                    extent[3]\n                ]\n            ];\n        }\n    }\n    return [\n        extent\n    ];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUNtRDtBQUVwRDs7OztDQUlDLEdBRUQ7OztDQUdDLEdBRUQ7Ozs7OztDQU1DLEdBQ00sU0FBU0MsZUFBZUMsV0FBVztJQUN4QyxNQUFNQyxTQUFTQztJQUNmLElBQUssSUFBSUMsSUFBSSxHQUFHQyxLQUFLSixZQUFZSyxNQUFNLEVBQUVGLElBQUlDLElBQUksRUFBRUQsRUFBRztRQUNwREcsaUJBQWlCTCxRQUFRRCxXQUFXLENBQUNHLEVBQUU7SUFDekM7SUFDQSxPQUFPRjtBQUNUO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU00sbUJBQW1CQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsSUFBSTtJQUN0QyxNQUFNQyxPQUFPQyxLQUFLQyxHQUFHLENBQUNDLEtBQUssQ0FBQyxNQUFNTjtJQUNsQyxNQUFNTyxPQUFPSCxLQUFLQyxHQUFHLENBQUNDLEtBQUssQ0FBQyxNQUFNTDtJQUNsQyxNQUFNTyxPQUFPSixLQUFLSyxHQUFHLENBQUNILEtBQUssQ0FBQyxNQUFNTjtJQUNsQyxNQUFNVSxPQUFPTixLQUFLSyxHQUFHLENBQUNILEtBQUssQ0FBQyxNQUFNTDtJQUNsQyxPQUFPVSxlQUFlUixNQUFNSSxNQUFNQyxNQUFNRSxNQUFNUjtBQUNoRDtBQUVBOzs7Ozs7O0NBT0MsR0FDTSxTQUFTVSxPQUFPbkIsTUFBTSxFQUFFb0IsS0FBSyxFQUFFWCxJQUFJO0lBQ3hDLElBQUlBLE1BQU07UUFDUkEsSUFBSSxDQUFDLEVBQUUsR0FBR1QsTUFBTSxDQUFDLEVBQUUsR0FBR29CO1FBQ3RCWCxJQUFJLENBQUMsRUFBRSxHQUFHVCxNQUFNLENBQUMsRUFBRSxHQUFHb0I7UUFDdEJYLElBQUksQ0FBQyxFQUFFLEdBQUdULE1BQU0sQ0FBQyxFQUFFLEdBQUdvQjtRQUN0QlgsSUFB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bkU7b0JBQUNpSSxnQkFBZ0IsQ0FBQyxFQUFFO29CQUFFakksTUFBTSxDQUFDLEVBQUU7b0JBQUVBLE1BQU0sQ0FBQyxFQUFFO29CQUFFQSxNQUFNLENBQUMsRUFBRTtpQkFBQzthQUN2RDtRQUNIO1FBQ0EsSUFBSUEsTUFBTSxDQUFDLEVBQUUsR0FBR2lJLGdCQUFnQixDQUFDLEVBQUUsRUFBRTtZQUNuQyxpRUFBaUU7WUFDakUsT0FBTztnQkFDTDtvQkFBQ2pJLE1BQU0sQ0FBQyxFQUFFO29CQUFFQSxNQUFNLENBQUMsRUFBRTtvQkFBRWlJLGdCQUFnQixDQUFDLEVBQUU7b0JBQUVqSSxNQUFNLENBQUMsRUFBRTtpQkFBQztnQkFDdEQ7b0JBQUNpSSxnQkFBZ0IsQ0FBQyxFQUFFO29CQUFFakksTUFBTSxDQUFDLEVBQUU7b0JBQUVBLE1BQU0sQ0FBQyxFQUFFLEdBQUdvSTtvQkFBWXBJLE1BQU0sQ0FBQyxFQUFFO2lCQUFDO2FBQ3BFO1FBQ0g7SUFDRjtJQUVBLE9BQU87UUFBQ0E7S0FBTztBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL21hcC8uL25vZGVfbW9kdWxlcy9vbC9leHRlbnQuanM/YmE4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvZXh0ZW50XG4gKi9cbmltcG9ydCBSZWxhdGlvbnNoaXAgZnJvbSAnLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzJztcblxuLyoqXG4gKiBBbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBhbiBleHRlbnQ6IGBbbWlueCwgbWlueSwgbWF4eCwgbWF4eV1gLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IEV4dGVudFxuICogQGFwaVxuICovXG5cbi8qKlxuICogRXh0ZW50IGNvcm5lci5cbiAqIEB0eXBlZGVmIHsnYm90dG9tLWxlZnQnIHwgJ2JvdHRvbS1yaWdodCcgfCAndG9wLWxlZnQnIHwgJ3RvcC1yaWdodCd9IENvcm5lclxuICovXG5cbi8qKlxuICogQnVpbGQgYW4gZXh0ZW50IHRoYXQgaW5jbHVkZXMgYWxsIGdpdmVuIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0V4dGVudH0gQm91bmRpbmcgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYm91bmRpbmdFeHRlbnQoY29vcmRpbmF0ZXMpIHtcbiAgY29uc3QgZXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHhzIFhzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB5cyBZcy5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5mdW5jdGlvbiBfYm91bmRpbmdFeHRlbnRYWXMoeHMsIHlzLCBkZXN0KSB7XG4gIGNvbnN0IG1pblggPSBNYXRoLm1pbi5hcHBseShudWxsLCB4cyk7XG4gIGNvbnN0IG1pblkgPSBNYXRoLm1pbi5hcHBseShudWxsLCB5cyk7XG4gIGNvbnN0IG1heFggPSBNYXRoLm1heC5hcHBseShudWxsLCB4cyk7XG4gIGNvbnN0IG1heFkgPSBNYXRoLm1heC5hcHBseShudWxsLCB5cyk7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBkZXN0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gZXh0ZW50IGluY3JlYXNlZCBieSB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRoZSBleHRlbnQgc2hvdWxkIGJlIGJ1ZmZlcmVkLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcihleHRlbnQsIHZhbHVlLCBkZXN0KSB7XG4gIGlmIChkZXN0KSB7XG4gICAgZGVzdFswXSA9IGV4dGVudFswXSAtIHZhbHVlO1xuICAgIGRlc3RbMV0gPSBleHRlbnRbMV0gLSB2YWx1ZTtcbiAgICBkZXN0WzJdID0gZXh0ZW50WzJdICsgdmFsdWU7XG4gICAgZGVzdFszXSA9IGV4dGVudFszXSArIHZhbHVlO1xuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHJldHVybiBbXG4gICAgZXh0ZW50WzBdIC0gdmFsdWUsXG4gICAgZXh0ZW50WzFdIC0gdmFsdWUsXG4gICAgZXh0ZW50WzJdICsgdmFsdWUsXG4gICAgZXh0ZW50WzNdICsgdmFsdWUsXG4gIF07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGFuIGV4dGVudC5cbiAqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBUaGUgY2xvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShleHRlbnQsIGRlc3QpIHtcbiAgaWYgKGRlc3QpIHtcbiAgICBkZXN0WzBdID0gZXh0ZW50WzBdO1xuICAgIGRlc3RbMV0gPSBleHRlbnRbMV07XG4gICAgZGVzdFsyXSA9IGV4dGVudFsyXTtcbiAgICBkZXN0WzNdID0gZXh0ZW50WzNdO1xuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHJldHVybiBleHRlbnQuc2xpY2UoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHJldHVybiB7bnVtYmVyfSBDbG9zZXN0IHNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkoZXh0ZW50LCB4LCB5KSB7XG4gIGxldCBkeCwgZHk7XG4gIGlmICh4IDwgZXh0ZW50WzBdKSB7XG4gICAgZHggPSBleHRlbnRbMF0gLSB4O1xuICB9IGVsc2UgaWYgKGV4dGVudFsyXSA8IHgpIHtcbiAgICBkeCA9IHggLSBleHRlbnRbMl07XG4gIH0gZWxzZSB7XG4gICAgZHggPSAwO1xuICB9XG4gIGlmICh5IDwgZXh0ZW50WzFdKSB7XG4gICAgZHkgPSBleHRlbnRbMV0gLSB5O1xuICB9IGVsc2UgaWYgKGV4dGVudFszXSA8IHkpIHtcbiAgICBkeSA9IHkgLSBleHRlbnRbM107XG4gIH0gZWxzZSB7XG4gICAgZHkgPSAwO1xuICB9XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIG9yIG9uIHRoZSBlZGdlIG9mIHRoZSBleHRlbnQuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgY29vcmRpbmF0ZSBpcyBjb250YWluZWQgaW4gdGhlIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zWFkoZXh0ZW50LCBjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBvbmUgZXh0ZW50IGNvbnRhaW5zIGFub3RoZXIuXG4gKlxuICogQW4gZXh0ZW50IGlzIGRlZW1lZCBjb250YWluZWQgaWYgaXQgbGllcyBjb21wbGV0ZWx5IHdpdGhpbiB0aGUgb3RoZXIgZXh0ZW50LFxuICogaW5jbHVkaW5nIGlmIHRoZXkgc2hhcmUgb25lIG9yIG1vcmUgZWRnZXMuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzZWNvbmQgZXh0ZW50IGlzIGNvbnRhaW5lZCBieSBvciBvbiB0aGUgZWRnZSBvZiB0aGVcbiAqICAgICBmaXJzdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zRXh0ZW50KGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIChcbiAgICBleHRlbnQxWzBdIDw9IGV4dGVudDJbMF0gJiZcbiAgICBleHRlbnQyWzJdIDw9IGV4dGVudDFbMl0gJiZcbiAgICBleHRlbnQxWzFdIDw9IGV4dGVudDJbMV0gJiZcbiAgICBleHRlbnQyWzNdIDw9IGV4dGVudDFbM11cbiAgKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIG9yIG9uIHRoZSBlZGdlIG9mIHRoZSBleHRlbnQuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBZIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgeCwgeSB2YWx1ZXMgYXJlIGNvbnRhaW5lZCBpbiB0aGUgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNYWShleHRlbnQsIHgsIHkpIHtcbiAgcmV0dXJuIGV4dGVudFswXSA8PSB4ICYmIHggPD0gZXh0ZW50WzJdICYmIGV4dGVudFsxXSA8PSB5ICYmIHkgPD0gZXh0ZW50WzNdO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gYSBjb29yZGluYXRlIGFuZCBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzXCIpLmRlZmF1bHR9IFRoZSByZWxhdGlvbnNoaXAgKGJpdHdpc2UgY29tcGFyZSB3aXRoXG4gKiAgICAgaW1wb3J0KFwiLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzXCIpLlJlbGF0aW9uc2hpcCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb29yZGluYXRlUmVsYXRpb25zaGlwKGV4dGVudCwgY29vcmRpbmF0ZSkge1xuICBjb25zdCBtaW5YID0gZXh0ZW50WzBdO1xuICBjb25zdCBtaW5ZID0gZXh0ZW50WzFdO1xuICBjb25zdCBtYXhYID0gZXh0ZW50WzJdO1xuICBjb25zdCBtYXhZID0gZXh0ZW50WzNdO1xuICBjb25zdCB4ID0gY29vcmRpbmF0ZVswXTtcbiAgY29uc3QgeSA9IGNvb3JkaW5hdGVbMV07XG4gIGxldCByZWxhdGlvbnNoaXAgPSBSZWxhdGlvbnNoaXAuVU5LTk9XTjtcbiAgaWYgKHggPCBtaW5YKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLkxFRlQ7XG4gIH0gZWxzZSBpZiAoeCA+IG1heFgpIHtcbiAgICByZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXAgfCBSZWxhdGlvbnNoaXAuUklHSFQ7XG4gIH1cbiAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLkJFTE9XO1xuICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLkFCT1ZFO1xuICB9XG4gIGlmIChyZWxhdGlvbnNoaXAgPT09IFJlbGF0aW9uc2hpcC5VTktOT1dOKSB7XG4gICAgcmVsYXRpb25zaGlwID0gUmVsYXRpb25zaGlwLklOVEVSU0VDVElORztcbiAgfVxuICByZXR1cm4gcmVsYXRpb25zaGlwO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlbXB0eSBleHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEVtcHR5IGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVtcHR5KCkge1xuICByZXR1cm4gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBleHRlbnQgb3IgdXBkYXRlIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluWCBNaW5pbXVtIFguXG4gKiBAcGFyYW0ge251bWJlcn0gbWluWSBNaW5pbXVtIFkuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4WCBNYXhpbXVtIFguXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4WSBNYXhpbXVtIFkuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgZGVzdCkge1xuICBpZiAoZGVzdCkge1xuICAgIGRlc3RbMF0gPSBtaW5YO1xuICAgIGRlc3RbMV0gPSBtaW5ZO1xuICAgIGRlc3RbMl0gPSBtYXhYO1xuICAgIGRlc3RbM10gPSBtYXhZO1xuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHJldHVybiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGVtcHR5IGV4dGVudCBvciBtYWtlIHRoZSBwcm92aWRlZCBvbmUgZW1wdHkuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVFbXB0eShkZXN0KSB7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5LCBkZXN0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZShjb29yZGluYXRlLCBkZXN0KSB7XG4gIGNvbnN0IHggPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5ID0gY29vcmRpbmF0ZVsxXTtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKHgsIHksIHgsIHksIGRlc3QpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlcyhjb29yZGluYXRlcywgZGVzdCkge1xuICBjb25zdCBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZUVtcHR5KGRlc3QpO1xuICByZXR1cm4gZXh0ZW5kQ29vcmRpbmF0ZXMoZXh0ZW50LCBjb29yZGluYXRlcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXMoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgZGVzdFxuKSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkoZGVzdCk7XG4gIHJldHVybiBleHRlbmRGbGF0Q29vcmRpbmF0ZXMoZXh0ZW50LCBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gcmluZ3MgUmluZ3MuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tUmluZ3MocmluZ3MsIGRlc3QpIHtcbiAgY29uc3QgZXh0ZW50ID0gY3JlYXRlT3JVcGRhdGVFbXB0eShkZXN0KTtcbiAgcmV0dXJuIGV4dGVuZFJpbmdzKGV4dGVudCwgcmluZ3MpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0d28gZXh0ZW50cyBhcmUgZXF1aXZhbGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdHdvIGV4dGVudHMgYXJlIGVxdWl2YWxlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoZXh0ZW50MSwgZXh0ZW50Mikge1xuICByZXR1cm4gKFxuICAgIGV4dGVudDFbMF0gPT0gZXh0ZW50MlswXSAmJlxuICAgIGV4dGVudDFbMl0gPT0gZXh0ZW50MlsyXSAmJlxuICAgIGV4dGVudDFbMV0gPT0gZXh0ZW50MlsxXSAmJlxuICAgIGV4dGVudDFbM10gPT0gZXh0ZW50MlszXVxuICApO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0d28gZXh0ZW50cyBhcmUgYXBwcm94aW1hdGVseSBlcXVpdmFsZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlIGluIGV4dGVudCBjb29yZGluYXRlIHVuaXRzLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHR3byBleHRlbnRzIGRpZmZlciBieSBsZXNzIHRoYW4gdGhlIHRvbGVyYW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcHJveGltYXRlbHlFcXVhbHMoZXh0ZW50MSwgZXh0ZW50MiwgdG9sZXJhbmNlKSB7XG4gIHJldHVybiAoXG4gICAgTWF0aC5hYnMoZXh0ZW50MVswXSAtIGV4dGVudDJbMF0pIDwgdG9sZXJhbmNlICYmXG4gICAgTWF0aC5hYnMoZXh0ZW50MVsyXSAtIGV4dGVudDJbMl0pIDwgdG9sZXJhbmNlICYmXG4gICAgTWF0aC5hYnMoZXh0ZW50MVsxXSAtIGV4dGVudDJbMV0pIDwgdG9sZXJhbmNlICYmXG4gICAgTWF0aC5hYnMoZXh0ZW50MVszXSAtIGV4dGVudDJbM10pIDwgdG9sZXJhbmNlXG4gICk7XG59XG5cbi8qKlxuICogTW9kaWZ5IGFuIGV4dGVudCB0byBpbmNsdWRlIGFub3RoZXIgZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgVGhlIGV4dGVudCB0byBiZSBtb2RpZmllZC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIFRoZSBleHRlbnQgdGhhdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBmaXJzdC5cbiAqIEByZXR1cm4ge0V4dGVudH0gQSByZWZlcmVuY2UgdG8gdGhlIGZpcnN0IChleHRlbmRlZCkgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgaWYgKGV4dGVudDJbMF0gPCBleHRlbnQxWzBdKSB7XG4gICAgZXh0ZW50MVswXSA9IGV4dGVudDJbMF07XG4gIH1cbiAgaWYgKGV4dGVudDJbMl0gPiBleHRlbnQxWzJdKSB7XG4gICAgZXh0ZW50MVsyXSA9IGV4dGVudDJbMl07XG4gIH1cbiAgaWYgKGV4dGVudDJbMV0gPCBleHRlbnQxWzFdKSB7XG4gICAgZXh0ZW50MVsxXSA9IGV4dGVudDJbMV07XG4gIH1cbiAgaWYgKGV4dGVudDJbM10gPiBleHRlbnQxWzNdKSB7XG4gICAgZXh0ZW50MVszXSA9IGV4dGVudDJbM107XG4gIH1cbiAgcmV0dXJuIGV4dGVudDE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgY29vcmRpbmF0ZSkge1xuICBpZiAoY29vcmRpbmF0ZVswXSA8IGV4dGVudFswXSkge1xuICAgIGV4dGVudFswXSA9IGNvb3JkaW5hdGVbMF07XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVbMF0gPiBleHRlbnRbMl0pIHtcbiAgICBleHRlbnRbMl0gPSBjb29yZGluYXRlWzBdO1xuICB9XG4gIGlmIChjb29yZGluYXRlWzFdIDwgZXh0ZW50WzFdKSB7XG4gICAgZXh0ZW50WzFdID0gY29vcmRpbmF0ZVsxXTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZVsxXSA+IGV4dGVudFszXSkge1xuICAgIGV4dGVudFszXSA9IGNvb3JkaW5hdGVbMV07XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kQ29vcmRpbmF0ZXMoZXh0ZW50LCBjb29yZGluYXRlcykge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kRmxhdENvb3JkaW5hdGVzKFxuICBleHRlbnQsXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZVxuKSB7XG4gIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICBleHRlbmRYWShleHRlbnQsIGZsYXRDb29yZGluYXRlc1tvZmZzZXRdLCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0pO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IHJpbmdzIFJpbmdzLlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRSaW5ncyhleHRlbnQsIHJpbmdzKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHJpbmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBleHRlbmRDb29yZGluYXRlcyhleHRlbnQsIHJpbmdzW2ldKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRYWShleHRlbnQsIHgsIHkpIHtcbiAgZXh0ZW50WzBdID0gTWF0aC5taW4oZXh0ZW50WzBdLCB4KTtcbiAgZXh0ZW50WzFdID0gTWF0aC5taW4oZXh0ZW50WzFdLCB5KTtcbiAgZXh0ZW50WzJdID0gTWF0aC5tYXgoZXh0ZW50WzJdLCB4KTtcbiAgZXh0ZW50WzNdID0gTWF0aC5tYXgoZXh0ZW50WzNdLCB5KTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGxzIGBjYWxsYmFja2AgZm9yIGVhY2ggY29ybmVyIG9mIHRoZSBleHRlbnQuIElmIHRoZVxuICogY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSB0aGUgZnVuY3Rpb24gcmV0dXJucyB0aGF0IHZhbHVlXG4gKiBpbW1lZGlhdGVseS4gT3RoZXJ3aXNlIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBTfSBjYWxsYmFjayBDYWxsYmFjay5cbiAqIEByZXR1cm4ge1N8Ym9vbGVhbn0gVmFsdWUuXG4gKiBAdGVtcGxhdGUgU1xuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaENvcm5lcihleHRlbnQsIGNhbGxiYWNrKSB7XG4gIGxldCB2YWw7XG4gIHZhbCA9IGNhbGxiYWNrKGdldEJvdHRvbUxlZnQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHZhbCA9IGNhbGxiYWNrKGdldEJvdHRvbVJpZ2h0KGV4dGVudCkpO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB2YWwgPSBjYWxsYmFjayhnZXRUb3BSaWdodChleHRlbnQpKTtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdmFsID0gY2FsbGJhY2soZ2V0VG9wTGVmdChleHRlbnQpKTtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gQXJlYS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFyZWEoZXh0ZW50KSB7XG4gIGxldCBhcmVhID0gMDtcbiAgaWYgKCFpc0VtcHR5KGV4dGVudCkpIHtcbiAgICBhcmVhID0gZ2V0V2lkdGgoZXh0ZW50KSAqIGdldEhlaWdodChleHRlbnQpO1xuICB9XG4gIHJldHVybiBhcmVhO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYm90dG9tIGxlZnQgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBCb3R0b20gbGVmdCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm90dG9tTGVmdChleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMF0sIGV4dGVudFsxXV07XG59XG5cbi8qKlxuICogR2V0IHRoZSBib3R0b20gcmlnaHQgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBCb3R0b20gcmlnaHQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJvdHRvbVJpZ2h0KGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFsyXSwgZXh0ZW50WzFdXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNlbnRlciBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENlbnRlci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENlbnRlcihleHRlbnQpIHtcbiAgcmV0dXJuIFsoZXh0ZW50WzBdICsgZXh0ZW50WzJdKSAvIDIsIChleHRlbnRbMV0gKyBleHRlbnRbM10pIC8gMl07XG59XG5cbi8qKlxuICogR2V0IGEgY29ybmVyIGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge0Nvcm5lcn0gY29ybmVyIENvcm5lci5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb3JuZXIgY29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvcm5lcihleHRlbnQsIGNvcm5lcikge1xuICBsZXQgY29vcmRpbmF0ZTtcbiAgaWYgKGNvcm5lciA9PT0gJ2JvdHRvbS1sZWZ0Jykge1xuICAgIGNvb3JkaW5hdGUgPSBnZXRCb3R0b21MZWZ0KGV4dGVudCk7XG4gIH0gZWxzZSBpZiAoY29ybmVyID09PSAnYm90dG9tLXJpZ2h0Jykge1xuICAgIGNvb3JkaW5hdGUgPSBnZXRCb3R0b21SaWdodChleHRlbnQpO1xuICB9IGVsc2UgaWYgKGNvcm5lciA9PT0gJ3RvcC1sZWZ0Jykge1xuICAgIGNvb3JkaW5hdGUgPSBnZXRUb3BMZWZ0KGV4dGVudCk7XG4gIH0gZWxzZSBpZiAoY29ybmVyID09PSAndG9wLXJpZ2h0Jykge1xuICAgIGNvb3JkaW5hdGUgPSBnZXRUb3BSaWdodChleHRlbnQpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb3JuZXInKTtcbiAgfVxuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHJldHVybiB7bnVtYmVyfSBFbmxhcmdlZCBhcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW5sYXJnZWRBcmVhKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgY29uc3QgbWluWCA9IE1hdGgubWluKGV4dGVudDFbMF0sIGV4dGVudDJbMF0pO1xuICBjb25zdCBtaW5ZID0gTWF0aC5taW4oZXh0ZW50MVsxXSwgZXh0ZW50MlsxXSk7XG4gIGNvbnN0IG1heFggPSBNYXRoLm1heChleHRlbnQxWzJdLCBleHRlbnQyWzJdKTtcbiAgY29uc3QgbWF4WSA9IE1hdGgubWF4KGV4dGVudDFbM10sIGV4dGVudDJbM10pO1xuICByZXR1cm4gKG1heFggLSBtaW5YKSAqIChtYXhZIC0gbWluWSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIFNpemUuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9yVmlld0FuZFNpemUoY2VudGVyLCByZXNvbHV0aW9uLCByb3RhdGlvbiwgc2l6ZSwgZGVzdCkge1xuICBjb25zdCBbeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzXSA9IGdldFJvdGF0ZWRWaWV3cG9ydChcbiAgICBjZW50ZXIsXG4gICAgcmVzb2x1dGlvbixcbiAgICByb3RhdGlvbixcbiAgICBzaXplXG4gICk7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShcbiAgICBNYXRoLm1pbih4MCwgeDEsIHgyLCB4MyksXG4gICAgTWF0aC5taW4oeTAsIHkxLCB5MiwgeTMpLFxuICAgIE1hdGgubWF4KHgwLCB4MSwgeDIsIHgzKSxcbiAgICBNYXRoLm1heCh5MCwgeTEsIHkyLCB5MyksXG4gICAgZGVzdFxuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBTaXplLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gTGluZWFyIHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2aWV3cG9ydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdGF0ZWRWaWV3cG9ydChjZW50ZXIsIHJlc29sdXRpb24sIHJvdGF0aW9uLCBzaXplKSB7XG4gIGNvbnN0IGR4ID0gKHJlc29sdXRpb24gKiBzaXplWzBdKSAvIDI7XG4gIGNvbnN0IGR5ID0gKHJlc29sdXRpb24gKiBzaXplWzFdKSAvIDI7XG4gIGNvbnN0IGNvc1JvdGF0aW9uID0gTWF0aC5jb3Mocm90YXRpb24pO1xuICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKHJvdGF0aW9uKTtcbiAgY29uc3QgeENvcyA9IGR4ICogY29zUm90YXRpb247XG4gIGNvbnN0IHhTaW4gPSBkeCAqIHNpblJvdGF0aW9uO1xuICBjb25zdCB5Q29zID0gZHkgKiBjb3NSb3RhdGlvbjtcbiAgY29uc3QgeVNpbiA9IGR5ICogc2luUm90YXRpb247XG4gIGNvbnN0IHggPSBjZW50ZXJbMF07XG4gIGNvbnN0IHkgPSBjZW50ZXJbMV07XG4gIHJldHVybiBbXG4gICAgeCAtIHhDb3MgKyB5U2luLFxuICAgIHkgLSB4U2luIC0geUNvcyxcbiAgICB4IC0geENvcyAtIHlTaW4sXG4gICAgeSAtIHhTaW4gKyB5Q29zLFxuICAgIHggKyB4Q29zIC0geVNpbixcbiAgICB5ICsgeFNpbiArIHlDb3MsXG4gICAgeCArIHhDb3MgKyB5U2luLFxuICAgIHkgKyB4U2luIC0geUNvcyxcbiAgICB4IC0geENvcyArIHlTaW4sXG4gICAgeSAtIHhTaW4gLSB5Q29zLFxuICBdO1xufVxuXG4vKipcbiAqIEdldCB0aGUgaGVpZ2h0IG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBIZWlnaHQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIZWlnaHQoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbM10gLSBleHRlbnRbMV07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge251bWJlcn0gSW50ZXJzZWN0aW9uIGFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25BcmVhKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgY29uc3QgaW50ZXJzZWN0aW9uID0gZ2V0SW50ZXJzZWN0aW9uKGV4dGVudDEsIGV4dGVudDIpO1xuICByZXR1cm4gZ2V0QXJlYShpbnRlcnNlY3Rpb24pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgaW50ZXJzZWN0aW9uIG9mIHR3byBleHRlbnRzLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gT3B0aW9uYWwgZXh0ZW50IHRvIHBvcHVsYXRlIHdpdGggaW50ZXJzZWN0aW9uLlxuICogQHJldHVybiB7RXh0ZW50fSBJbnRlcnNlY3RpbmcgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uKGV4dGVudDEsIGV4dGVudDIsIGRlc3QpIHtcbiAgY29uc3QgaW50ZXJzZWN0aW9uID0gZGVzdCA/IGRlc3QgOiBjcmVhdGVFbXB0eSgpO1xuICBpZiAoaW50ZXJzZWN0cyhleHRlbnQxLCBleHRlbnQyKSkge1xuICAgIGlmIChleHRlbnQxWzBdID4gZXh0ZW50MlswXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzBdID0gZXh0ZW50MVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzBdID0gZXh0ZW50MlswXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudDFbMV0gPiBleHRlbnQyWzFdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMV0gPSBleHRlbnQxWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMV0gPSBleHRlbnQyWzFdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50MVsyXSA8IGV4dGVudDJbMl0pIHtcbiAgICAgIGludGVyc2VjdGlvblsyXSA9IGV4dGVudDFbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblsyXSA9IGV4dGVudDJbMl07XG4gICAgfVxuICAgIGlmIChleHRlbnQxWzNdIDwgZXh0ZW50MlszXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzNdID0gZXh0ZW50MVszXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzNdID0gZXh0ZW50MlszXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY3JlYXRlT3JVcGRhdGVFbXB0eShpbnRlcnNlY3Rpb24pO1xuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb247XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1hcmdpbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmdpbihleHRlbnQpIHtcbiAgcmV0dXJuIGdldFdpZHRoKGV4dGVudCkgKyBnZXRIZWlnaHQoZXh0ZW50KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgKHdpZHRoLCBoZWlnaHQpIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBUaGUgZXh0ZW50IHNpemUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaXplKGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFsyXSAtIGV4dGVudFswXSwgZXh0ZW50WzNdIC0gZXh0ZW50WzFdXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRvcCBsZWZ0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVG9wIGxlZnQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvcExlZnQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzBdLCBleHRlbnRbM11dO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdG9wIHJpZ2h0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVG9wIHJpZ2h0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BSaWdodChleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMl0sIGV4dGVudFszXV07XG59XG5cbi8qKlxuICogR2V0IHRoZSB3aWR0aCBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gV2lkdGguXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXaWR0aChleHRlbnQpIHtcbiAgcmV0dXJuIGV4dGVudFsyXSAtIGV4dGVudFswXTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgb25lIGV4dGVudCBpbnRlcnNlY3RzIGFub3RoZXIuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0d28gZXh0ZW50cyBpbnRlcnNlY3QuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIChcbiAgICBleHRlbnQxWzBdIDw9IGV4dGVudDJbMl0gJiZcbiAgICBleHRlbnQxWzJdID49IGV4dGVudDJbMF0gJiZcbiAgICBleHRlbnQxWzFdIDw9IGV4dGVudDJbM10gJiZcbiAgICBleHRlbnQxWzNdID49IGV4dGVudDJbMV1cbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gZXh0ZW50IGlzIGVtcHR5LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbMl0gPCBleHRlbnRbMF0gfHwgZXh0ZW50WzNdIDwgZXh0ZW50WzFdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldHVybk9yVXBkYXRlKGV4dGVudCwgZGVzdCkge1xuICBpZiAoZGVzdCkge1xuICAgIGRlc3RbMF0gPSBleHRlbnRbMF07XG4gICAgZGVzdFsxXSA9IGV4dGVudFsxXTtcbiAgICBkZXN0WzJdID0gZXh0ZW50WzJdO1xuICAgIGRlc3RbM10gPSBleHRlbnRbM107XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlRnJvbUNlbnRlcihleHRlbnQsIHZhbHVlKSB7XG4gIGNvbnN0IGRlbHRhWCA9ICgoZXh0ZW50WzJdIC0gZXh0ZW50WzBdKSAvIDIpICogKHZhbHVlIC0gMSk7XG4gIGNvbnN0IGRlbHRhWSA9ICgoZXh0ZW50WzNdIC0gZXh0ZW50WzFdKSAvIDIpICogKHZhbHVlIC0gMSk7XG4gIGV4dGVudFswXSAtPSBkZWx0YVg7XG4gIGV4dGVudFsyXSArPSBkZWx0YVg7XG4gIGV4dGVudFsxXSAtPSBkZWx0YVk7XG4gIGV4dGVudFszXSArPSBkZWx0YVk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBzZWdtZW50IGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzIGludGVyc2VjdHMgKGNyb3NzZXMsXG4gKiB0b3VjaGVzLCBvciBpcyBjb250YWluZWQgYnkpIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBzdGFydCBTZWdtZW50IHN0YXJ0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBlbmQgU2VnbWVudCBlbmQgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzZWdtZW50IGludGVyc2VjdHMgdGhlIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNTZWdtZW50KGV4dGVudCwgc3RhcnQsIGVuZCkge1xuICBsZXQgaW50ZXJzZWN0cyA9IGZhbHNlO1xuICBjb25zdCBzdGFydFJlbCA9IGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBzdGFydCk7XG4gIGNvbnN0IGVuZFJlbCA9IGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBlbmQpO1xuICBpZiAoXG4gICAgc3RhcnRSZWwgPT09IFJlbGF0aW9uc2hpcC5JTlRFUlNFQ1RJTkcgfHxcbiAgICBlbmRSZWwgPT09IFJlbGF0aW9uc2hpcC5JTlRFUlNFQ1RJTkdcbiAgKSB7XG4gICAgaW50ZXJzZWN0cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWluWCA9IGV4dGVudFswXTtcbiAgICBjb25zdCBtaW5ZID0gZXh0ZW50WzFdO1xuICAgIGNvbnN0IG1heFggPSBleHRlbnRbMl07XG4gICAgY29uc3QgbWF4WSA9IGV4dGVudFszXTtcbiAgICBjb25zdCBzdGFydFggPSBzdGFydFswXTtcbiAgICBjb25zdCBzdGFydFkgPSBzdGFydFsxXTtcbiAgICBjb25zdCBlbmRYID0gZW5kWzBdO1xuICAgIGNvbnN0IGVuZFkgPSBlbmRbMV07XG4gICAgY29uc3Qgc2xvcGUgPSAoZW5kWSAtIHN0YXJ0WSkgLyAoZW5kWCAtIHN0YXJ0WCk7XG4gICAgbGV0IHgsIHk7XG4gICAgaWYgKCEhKGVuZFJlbCAmIFJlbGF0aW9uc2hpcC5BQk9WRSkgJiYgIShzdGFydFJlbCAmIFJlbGF0aW9uc2hpcC5BQk9WRSkpIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgdG9wXG4gICAgICB4ID0gZW5kWCAtIChlbmRZIC0gbWF4WSkgLyBzbG9wZTtcbiAgICAgIGludGVyc2VjdHMgPSB4ID49IG1pblggJiYgeCA8PSBtYXhYO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAhaW50ZXJzZWN0cyAmJlxuICAgICAgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLlJJR0hUKSAmJlxuICAgICAgIShzdGFydFJlbCAmIFJlbGF0aW9uc2hpcC5SSUdIVClcbiAgICApIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgcmlnaHRcbiAgICAgIHkgPSBlbmRZIC0gKGVuZFggLSBtYXhYKSAqIHNsb3BlO1xuICAgICAgaW50ZXJzZWN0cyA9IHkgPj0gbWluWSAmJiB5IDw9IG1heFk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFpbnRlcnNlY3RzICYmXG4gICAgICAhIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuQkVMT1cpICYmXG4gICAgICAhKHN0YXJ0UmVsICYgUmVsYXRpb25zaGlwLkJFTE9XKVxuICAgICkge1xuICAgICAgLy8gcG90ZW50aWFsbHkgaW50ZXJzZWN0cyBib3R0b21cbiAgICAgIHggPSBlbmRYIC0gKGVuZFkgLSBtaW5ZKSAvIHNsb3BlO1xuICAgICAgaW50ZXJzZWN0cyA9IHggPj0gbWluWCAmJiB4IDw9IG1heFg7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFpbnRlcnNlY3RzICYmXG4gICAgICAhIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuTEVGVCkgJiZcbiAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuTEVGVClcbiAgICApIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgbGVmdFxuICAgICAgeSA9IGVuZFkgLSAoZW5kWCAtIG1pblgpICogc2xvcGU7XG4gICAgICBpbnRlcnNlY3RzID0geSA+PSBtaW5ZICYmIHkgPD0gbWF4WTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdHM7XG59XG5cbi8qKlxuICogQXBwbHkgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gdGhlIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IHRyYW5zZm9ybUZuIFRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqIENhbGxlZCB3aXRoIGBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV1gIGV4dGVudCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wc10gTnVtYmVyIG9mIHN0b3BzIHBlciBzaWRlIHVzZWQgZm9yIHRoZSB0cmFuc2Zvcm0uXG4gKiBCeSBkZWZhdWx0IG9ubHkgdGhlIGNvcm5lcnMgYXJlIHVzZWQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKGV4dGVudCwgdHJhbnNmb3JtRm4sIGRlc3QsIHN0b3BzKSB7XG4gIGlmIChpc0VtcHR5KGV4dGVudCkpIHtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVFbXB0eShkZXN0KTtcbiAgfVxuICBsZXQgY29vcmRpbmF0ZXMgPSBbXTtcbiAgaWYgKHN0b3BzID4gMSkge1xuICAgIGNvbnN0IHdpZHRoID0gZXh0ZW50WzJdIC0gZXh0ZW50WzBdO1xuICAgIGNvbnN0IGhlaWdodCA9IGV4dGVudFszXSAtIGV4dGVudFsxXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0b3BzOyArK2kpIHtcbiAgICAgIGNvb3JkaW5hdGVzLnB1c2goXG4gICAgICAgIGV4dGVudFswXSArICh3aWR0aCAqIGkpIC8gc3RvcHMsXG4gICAgICAgIGV4dGVudFsxXSxcbiAgICAgICAgZXh0ZW50WzJdLFxuICAgICAgICBleHRlbnRbMV0gKyAoaGVpZ2h0ICogaSkgLyBzdG9wcyxcbiAgICAgICAgZXh0ZW50WzJdIC0gKHdpZHRoICogaSkgLyBzdG9wcyxcbiAgICAgICAgZXh0ZW50WzNdLFxuICAgICAgICBleHRlbnRbMF0sXG4gICAgICAgIGV4dGVudFszXSAtIChoZWlnaHQgKiBpKSAvIHN0b3BzXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb29yZGluYXRlcyA9IFtcbiAgICAgIGV4dGVudFswXSxcbiAgICAgIGV4dGVudFsxXSxcbiAgICAgIGV4dGVudFsyXSxcbiAgICAgIGV4dGVudFsxXSxcbiAgICAgIGV4dGVudFsyXSxcbiAgICAgIGV4dGVudFszXSxcbiAgICAgIGV4dGVudFswXSxcbiAgICAgIGV4dGVudFszXSxcbiAgICBdO1xuICB9XG4gIHRyYW5zZm9ybUZuKGNvb3JkaW5hdGVzLCBjb29yZGluYXRlcywgMik7XG4gIGNvbnN0IHhzID0gW107XG4gIGNvbnN0IHlzID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBsID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgeHMucHVzaChjb29yZGluYXRlc1tpXSk7XG4gICAgeXMucHVzaChjb29yZGluYXRlc1tpICsgMV0pO1xuICB9XG4gIHJldHVybiBfYm91bmRpbmdFeHRlbnRYWXMoeHMsIHlzLCBkZXN0KTtcbn1cblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcHJvdmlkZWQgZXh0ZW50IGluLXBsYWNlIHRvIGJlIHdpdGhpbiB0aGUgcmVhbCB3b3JsZFxuICogZXh0ZW50LlxuICpcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb25cbiAqIEByZXR1cm4ge0V4dGVudH0gVGhlIGV4dGVudCB3aXRoaW4gdGhlIHJlYWwgd29ybGQgZXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcFgoZXh0ZW50LCBwcm9qZWN0aW9uKSB7XG4gIGNvbnN0IHByb2plY3Rpb25FeHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuICBjb25zdCBjZW50ZXIgPSBnZXRDZW50ZXIoZXh0ZW50KTtcbiAgaWYgKFxuICAgIHByb2plY3Rpb24uY2FuV3JhcFgoKSAmJlxuICAgIChjZW50ZXJbMF0gPCBwcm9qZWN0aW9uRXh0ZW50WzBdIHx8IGNlbnRlclswXSA+PSBwcm9qZWN0aW9uRXh0ZW50WzJdKVxuICApIHtcbiAgICBjb25zdCB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG4gICAgY29uc3Qgd29ybGRzQXdheSA9IE1hdGguZmxvb3IoXG4gICAgICAoY2VudGVyWzBdIC0gcHJvamVjdGlvbkV4dGVudFswXSkgLyB3b3JsZFdpZHRoXG4gICAgKTtcbiAgICBjb25zdCBvZmZzZXQgPSB3b3JsZHNBd2F5ICogd29ybGRXaWR0aDtcbiAgICBleHRlbnRbMF0gLT0gb2Zmc2V0O1xuICAgIGV4dGVudFsyXSAtPSBvZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuLyoqXG4gKiBGaXRzIHRoZSBleHRlbnQgdG8gdGhlIHJlYWwgd29ybGRcbiAqXG4gKiBJZiB0aGUgZXh0ZW50IGRvZXMgbm90IGNyb3NzIHRoZSBhbnRpIG1lcmlkaWFuLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBleHRlbnQgaW4gYW4gYXJyYXlcbiAqIElmIHRoZSBleHRlbnQgY3Jvc3NlcyB0aGUgYW50aSBtZXJpZGlhbiwgdGhlIGV4dGVudCB3aWxsIGJlIHNsaWNlZCwgc28gZWFjaCBwYXJ0IGZpdHMgd2l0aGluIHRoZVxuICogcmVhbCB3b3JsZFxuICpcbiAqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uXG4gKiBAcmV0dXJuIHtBcnJheTxFeHRlbnQ+fSBUaGUgZXh0ZW50IHdpdGhpbiB0aGUgcmVhbCB3b3JsZCBleHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQW5kU2xpY2VYKGV4dGVudCwgcHJvamVjdGlvbikge1xuICBpZiAocHJvamVjdGlvbi5jYW5XcmFwWCgpKSB7XG4gICAgY29uc3QgcHJvamVjdGlvbkV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG5cbiAgICBpZiAoIWlzRmluaXRlKGV4dGVudFswXSkgfHwgIWlzRmluaXRlKGV4dGVudFsyXSkpIHtcbiAgICAgIHJldHVybiBbW3Byb2plY3Rpb25FeHRlbnRbMF0sIGV4dGVudFsxXSwgcHJvamVjdGlvbkV4dGVudFsyXSwgZXh0ZW50WzNdXV07XG4gICAgfVxuXG4gICAgd3JhcFgoZXh0ZW50LCBwcm9qZWN0aW9uKTtcbiAgICBjb25zdCB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG5cbiAgICBpZiAoZ2V0V2lkdGgoZXh0ZW50KSA+IHdvcmxkV2lkdGgpIHtcbiAgICAgIC8vIHRoZSBleHRlbnQgd3JhcHMgYXJvdW5kIG9uIGl0c2VsZlxuICAgICAgcmV0dXJuIFtbcHJvamVjdGlvbkV4dGVudFswXSwgZXh0ZW50WzFdLCBwcm9qZWN0aW9uRXh0ZW50WzJdLCBleHRlbnRbM11dXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudFswXSA8IHByb2plY3Rpb25FeHRlbnRbMF0pIHtcbiAgICAgIC8vIHRoZSBleHRlbnQgY3Jvc3NlcyB0aGUgYW50aSBtZXJpZGlhbiwgc28gaXQgbmVlZHMgdG8gYmUgc2xpY2VkXG4gICAgICByZXR1cm4gW1xuICAgICAgICBbZXh0ZW50WzBdICsgd29ybGRXaWR0aCwgZXh0ZW50WzFdLCBwcm9qZWN0aW9uRXh0ZW50WzJdLCBleHRlbnRbM11dLFxuICAgICAgICBbcHJvamVjdGlvbkV4dGVudFswXSwgZXh0ZW50WzFdLCBleHRlbnRbMl0sIGV4dGVudFszXV0sXG4gICAgICBdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50WzJdID4gcHJvamVjdGlvbkV4dGVudFsyXSkge1xuICAgICAgLy8gdGhlIGV4dGVudCBjcm9zc2VzIHRoZSBhbnRpIG1lcmlkaWFuLCBzbyBpdCBuZWVkcyB0byBiZSBzbGljZWRcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFtleHRlbnRbMF0sIGV4dGVudFsxXSwgcHJvamVjdGlvbkV4dGVudFsyXSwgZXh0ZW50WzNdXSxcbiAgICAgICAgW3Byb2plY3Rpb25FeHRlbnRbMF0sIGV4dGVudFsxXSwgZXh0ZW50WzJdIC0gd29ybGRXaWR0aCwgZXh0ZW50WzNdXSxcbiAgICAgIF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtleHRlbnRdO1xufVxuIl0sIm5hbWVzIjpbIlJlbGF0aW9uc2hpcCIsImJvdW5kaW5nRXh0ZW50IiwiY29vcmRpbmF0ZXMiLCJleHRlbnQiLCJjcmVhdGVFbXB0eSIsImkiLCJpaSIsImxlbmd0aCIsImV4dGVuZENvb3JkaW5hdGUiLCJfYm91bmRpbmdFeHRlbnRYWXMiLCJ4cyIsInlzIiwiZGVzdCIsIm1pblgiLCJNYXRoIiwibWluIiwiYXBwbHkiLCJtaW5ZIiwibWF4WCIsIm1heCIsIm1heFkiLCJjcmVhdGVPclVwZGF0ZSIsImJ1ZmZlciIsInZhbHVlIiwiY2xvbmUiLCJzbGljZSIsImNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSIsIngiLCJ5IiwiZHgiLCJkeSIsImNvbnRhaW5zQ29vcmRpbmF0ZSIsImNvb3JkaW5hdGUiLCJjb250YWluc1hZIiwiY29udGFpbnNFeHRlbnQiLCJleHRlbnQxIiwiZXh0ZW50MiIsImNvb3JkaW5hdGVSZWxhdGlvbnNoaXAiLCJyZWxhdGlvbnNoaXAiLCJVTktOT1dOIiwiTEVGVCIsIlJJR0hUIiwiQkVMT1ciLCJBQk9WRSIsIklOVEVSU0VDVElORyIsIkluZmluaXR5IiwiY3JlYXRlT3JVcGRhdGVFbXB0eSIsImNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUiLCJjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlcyIsImV4dGVuZENvb3JkaW5hdGVzIiwiY3JlYXRlT3JVcGRhdGVGcm9tRmxhdENvb3JkaW5hdGVzIiwiZmxhdENvb3JkaW5hdGVzIiwib2Zmc2V0IiwiZW5kIiwic3RyaWRlIiwiZXh0ZW5kRmxhdENvb3JkaW5hdGVzIiwiY3JlYXRlT3JVcGRhdGVGcm9tUmluZ3MiLCJyaW5ncyIsImV4dGVuZFJpbmdzIiwiZXF1YWxzIiwiYXBwcm94aW1hdGVseUVxdWFscyIsInRvbGVyYW5jZSIsImFicyIsImV4dGVuZCIsImV4dGVuZFhZIiwiZm9yRWFjaENvcm5lciIsImNhbGxiYWNrIiwidmFsIiwiZ2V0Qm90dG9tTGVmdCIsImdldEJvdHRvbVJpZ2h0IiwiZ2V0VG9wUmlnaHQiLCJnZXRUb3BMZWZ0IiwiZ2V0QXJlYSIsImFyZWEiLCJpc0VtcHR5IiwiZ2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJnZXRDZW50ZXIiLCJnZXRDb3JuZXIiLCJjb3JuZXIiLCJFcnJvciIsImdldEVubGFyZ2VkQXJlYSIsImdldEZvclZpZXdBbmRTaXplIiwiY2VudGVyIiwicmVzb2x1dGlvbiIsInJvdGF0aW9uIiwic2l6ZSIsIngwIiwieTAiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIngzIiwieTMiLCJnZXRSb3RhdGVkVmlld3BvcnQiLCJjb3NSb3RhdGlvbiIsImNvcyIsInNpblJvdGF0aW9uIiwic2luIiwieENvcyIsInhTaW4iLCJ5Q29zIiwieVNpbiIsImdldEludGVyc2VjdGlvbkFyZWEiLCJpbnRlcnNlY3Rpb24iLCJnZXRJbnRlcnNlY3Rpb24iLCJpbnRlcnNlY3RzIiwiZ2V0TWFyZ2luIiwiZ2V0U2l6ZSIsInJldHVybk9yVXBkYXRlIiwic2NhbGVGcm9tQ2VudGVyIiwiZGVsdGFYIiwiZGVsdGFZIiwiaW50ZXJzZWN0c1NlZ21lbnQiLCJzdGFydCIsInN0YXJ0UmVsIiwiZW5kUmVsIiwic3RhcnRYIiwic3RhcnRZIiwiZW5kWCIsImVuZFkiLCJzbG9wZSIsImFwcGx5VHJhbnNmb3JtIiwidHJhbnNmb3JtRm4iLCJzdG9wcyIsIndpZHRoIiwiaGVpZ2h0IiwicHVzaCIsImwiLCJ3cmFwWCIsInByb2plY3Rpb24iLCJwcm9qZWN0aW9uRXh0ZW50IiwiZ2V0RXh0ZW50IiwiY2FuV3JhcFgiLCJ3b3JsZFdpZHRoIiwid29ybGRzQXdheSIsImZsb29yIiwid3JhcEFuZFNsaWNlWCIsImlzRmluaXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/extent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ol/extent/Relationship.js":
/*!************************************************!*\
  !*** ./node_modules/ol/extent/Relationship.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @module ol/extent/Relationship\n */ /**\n * Relationship to an extent.\n * @enum {number}\n */ /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    UNKNOWN: 0,\n    INTERSECTING: 1,\n    ABOVE: 2,\n    RIGHT: 4,\n    BELOW: 8,\n    LEFT: 16\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50L1JlbGF0aW9uc2hpcC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FFRDs7O0NBR0MsR0FDRCxpRUFBZTtJQUNiQSxTQUFTO0lBQ1RDLGNBQWM7SUFDZEMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsTUFBTTtBQUNSLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcC8uL25vZGVfbW9kdWxlcy9vbC9leHRlbnQvUmVsYXRpb25zaGlwLmpzPzM0NzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2V4dGVudC9SZWxhdGlvbnNoaXBcbiAqL1xuXG4vKipcbiAqIFJlbGF0aW9uc2hpcCB0byBhbiBleHRlbnQuXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFVOS05PV046IDAsXG4gIElOVEVSU0VDVElORzogMSxcbiAgQUJPVkU6IDIsXG4gIFJJR0hUOiA0LFxuICBCRUxPVzogOCxcbiAgTEVGVDogMTYsXG59O1xuIl0sIm5hbWVzIjpbIlVOS05PV04iLCJJTlRFUlNFQ1RJTkciLCJBQk9WRSIsIlJJR0hUIiwiQkVMT1ciLCJMRUZUIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/extent/Relationship.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ol/math.js":
/*!*********************************!*\
  !*** ./node_modules/ol/math.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ceil: () => (/* binding */ ceil),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   lerp: () => (/* binding */ lerp),\n/* harmony export */   modulo: () => (/* binding */ modulo),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   solveLinearSystem: () => (/* binding */ solveLinearSystem),\n/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),\n/* harmony export */   squaredSegmentDistance: () => (/* binding */ squaredSegmentDistance),\n/* harmony export */   toDegrees: () => (/* binding */ toDegrees),\n/* harmony export */   toFixed: () => (/* binding */ toFixed),\n/* harmony export */   toRadians: () => (/* binding */ toRadians)\n/* harmony export */ });\n/**\n * @module ol/math\n */ /**\n * Takes a number and clamps it to within the provided bounds.\n * @param {number} value The input number.\n * @param {number} min The minimum value to return.\n * @param {number} max The maximum value to return.\n * @return {number} The input number if it is within bounds, or the nearest\n *     number within the bounds.\n */ function clamp(value, min, max) {\n    return Math.min(Math.max(value, min), max);\n}\n/**\n * Returns the square of the closest distance between the point (x, y) and the\n * line segment (x1, y1) to (x2, y2).\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */ function squaredSegmentDistance(x, y, x1, y1, x2, y2) {\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    if (dx !== 0 || dy !== 0) {\n        const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n        if (t > 1) {\n            x1 = x2;\n            y1 = y2;\n        } else if (t > 0) {\n            x1 += dx * t;\n            y1 += dy * t;\n        }\n    }\n    return squaredDistance(x, y, x1, y1);\n}\n/**\n * Returns the square of the distance between the points (x1, y1) and (x2, y2).\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */ function squaredDistance(x1, y1, x2, y2) {\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    return dx * dx + dy * dy;\n}\n/**\n * Solves system of linear equations using Gaussian elimination method.\n *\n * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)\n *                                     in row-major order.\n * @return {Array<number>|null} The resulting vector.\n */ function solveLinearSystem(mat) {\n    const n = mat.length;\n    for(let i = 0; i < n; i++){\n        // Find max in the i-th column (ignoring i - 1 first rows)\n        let maxRow = i;\n        let maxEl = Math.abs(mat[i][i]);\n        for(let r = i + 1; r < n; r++){\n            const absValue = Math.abs(mat[r][i]);\n            if (absValue > maxEl) {\n                maxEl = absValue;\n                maxRow = r;\n            }\n        }\n        if (maxEl === 0) {\n            return null; // matrix is singular\n        }\n        // Swap max row with i-th (current) row\n        const tmp = mat[maxRow];\n        mat[maxRow] = mat[i];\n        mat[i] = tmp;\n        // Subtract the i-th row to make all the remaining rows 0 in the i-th column\n        for(let j = i + 1; j < n; j++){\n            const coef = -mat[j][i] / mat[i][i];\n            for(let k = i; k < n + 1; k++){\n                if (i == k) {\n                    mat[j][k] = 0;\n                } else {\n                    mat[j][k] += coef * mat[i][k];\n                }\n            }\n        }\n    }\n    // Solve Ax=b for upper triangular matrix A (mat)\n    const x = new Array(n);\n    for(let l = n - 1; l >= 0; l--){\n        x[l] = mat[l][n] / mat[l][l];\n        for(let m = l - 1; m >= 0; m--){\n            mat[m][n] -= mat[m][l] * x[l];\n        }\n    }\n    return x;\n}\n/**\n * Converts radians to to degrees.\n *\n * @param {number} angleInRadians Angle in radians.\n * @return {number} Angle in degrees.\n */ function toDegrees(angleInRadians) {\n    return angleInRadians * 180 / Math.PI;\n}\n/**\n * Converts degrees to radians.\n *\n * @param {number} angleInDegrees Angle in degrees.\n * @return {number} Angle in radians.\n */ function toRadians(angleInDegrees) {\n    return angleInDegrees * Math.PI / 180;\n}\n/**\n * Returns the modulo of a / b, depending on the sign of b.\n *\n * @param {number} a Dividend.\n * @param {number} b Divisor.\n * @return {number} Modulo.\n */ function modulo(a, b) {\n    const r = a % b;\n    return r * b < 0 ? r + b : r;\n}\n/**\n * Calculates the linearly interpolated value of x between a and b.\n *\n * @param {number} a Number\n * @param {number} b Number\n * @param {number} x Value to be interpolated.\n * @return {number} Interpolated value.\n */ function lerp(a, b, x) {\n    return a + x * (b - a);\n}\n/**\n * Returns a number with a limited number of decimal digits.\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The input number with a limited number of decimal digits.\n */ function toFixed(n, decimals) {\n    const factor = Math.pow(10, decimals);\n    return Math.round(n * factor) / factor;\n}\n/**\n * Rounds a number to the nearest integer value considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The nearest integer.\n */ function round(n, decimals) {\n    return Math.round(toFixed(n, decimals));\n}\n/**\n * Rounds a number to the next smaller integer considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The next smaller integer.\n */ function floor(n, decimals) {\n    return Math.floor(toFixed(n, decimals));\n}\n/**\n * Rounds a number to the next bigger integer considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The next bigger integer.\n */ function ceil(n, decimals) {\n    return Math.ceil(toFixed(n, decimals));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUswQyxLQUFLLENBQUNKLFFBQVF4QixHQUFHeUI7QUFDL0I7QUFFQTs7Ozs7O0NBTUMsR0FDTSxTQUFTSSxNQUFNN0IsQ0FBQyxFQUFFeUIsUUFBUTtJQUMvQixPQUFPdkMsS0FBSzJDLEtBQUssQ0FBQ0wsUUFBUXhCLEdBQUd5QjtBQUMvQjtBQUVBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNLLEtBQUs5QixDQUFDLEVBQUV5QixRQUFRO0lBQzlCLE9BQU92QyxLQUFLNEMsSUFBSSxDQUFDTixRQUFReEIsR0FBR3lCO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFwLy4vbm9kZV9tb2R1bGVzL29sL21hdGguanM/OWVmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvbWF0aFxuICovXG5cbi8qKlxuICogVGFrZXMgYSBudW1iZXIgYW5kIGNsYW1wcyBpdCB0byB3aXRoaW4gdGhlIHByb3ZpZGVkIGJvdW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgaW5wdXQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSB2YWx1ZSB0byByZXR1cm4uXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHZhbHVlIHRvIHJldHVybi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGlucHV0IG51bWJlciBpZiBpdCBpcyB3aXRoaW4gYm91bmRzLCBvciB0aGUgbmVhcmVzdFxuICogICAgIG51bWJlciB3aXRoaW4gdGhlIGJvdW5kcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3F1YXJlIG9mIHRoZSBjbG9zZXN0IGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50ICh4LCB5KSBhbmQgdGhlXG4gKiBsaW5lIHNlZ21lbnQgKHgxLCB5MSkgdG8gKHgyLCB5MikuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSBYMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MSBZMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MiBYMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MiBZMi5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRTZWdtZW50RGlzdGFuY2UoeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgY29uc3QgZHggPSB4MiAtIHgxO1xuICBjb25zdCBkeSA9IHkyIC0geTE7XG4gIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuICAgIGNvbnN0IHQgPSAoKHggLSB4MSkgKiBkeCArICh5IC0geTEpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICBpZiAodCA+IDEpIHtcbiAgICAgIHgxID0geDI7XG4gICAgICB5MSA9IHkyO1xuICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgIHgxICs9IGR4ICogdDtcbiAgICAgIHkxICs9IGR5ICogdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZSh4LCB5LCB4MSwgeTEpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSBYMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MSBZMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MiBYMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MiBZMi5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICBjb25zdCBkeCA9IHgyIC0geDE7XG4gIGNvbnN0IGR5ID0geTIgLSB5MTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG4vKipcbiAqIFNvbHZlcyBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucyB1c2luZyBHYXVzc2lhbiBlbGltaW5hdGlvbiBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gbWF0IEF1Z21lbnRlZCBtYXRyaXggKG4geCBuICsgMSBjb2x1bW4pXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiByb3ctbWFqb3Igb3JkZXIuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fG51bGx9IFRoZSByZXN1bHRpbmcgdmVjdG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc29sdmVMaW5lYXJTeXN0ZW0obWF0KSB7XG4gIGNvbnN0IG4gPSBtYXQubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgLy8gRmluZCBtYXggaW4gdGhlIGktdGggY29sdW1uIChpZ25vcmluZyBpIC0gMSBmaXJzdCByb3dzKVxuICAgIGxldCBtYXhSb3cgPSBpO1xuICAgIGxldCBtYXhFbCA9IE1hdGguYWJzKG1hdFtpXVtpXSk7XG4gICAgZm9yIChsZXQgciA9IGkgKyAxOyByIDwgbjsgcisrKSB7XG4gICAgICBjb25zdCBhYnNWYWx1ZSA9IE1hdGguYWJzKG1hdFtyXVtpXSk7XG4gICAgICBpZiAoYWJzVmFsdWUgPiBtYXhFbCkge1xuICAgICAgICBtYXhFbCA9IGFic1ZhbHVlO1xuICAgICAgICBtYXhSb3cgPSByO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhFbCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIG1hdHJpeCBpcyBzaW5ndWxhclxuICAgIH1cblxuICAgIC8vIFN3YXAgbWF4IHJvdyB3aXRoIGktdGggKGN1cnJlbnQpIHJvd1xuICAgIGNvbnN0IHRtcCA9IG1hdFttYXhSb3ddO1xuICAgIG1hdFttYXhSb3ddID0gbWF0W2ldO1xuICAgIG1hdFtpXSA9IHRtcDtcblxuICAgIC8vIFN1YnRyYWN0IHRoZSBpLXRoIHJvdyB0byBtYWtlIGFsbCB0aGUgcmVtYWluaW5nIHJvd3MgMCBpbiB0aGUgaS10aCBjb2x1bW5cbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgIGNvbnN0IGNvZWYgPSAtbWF0W2pdW2ldIC8gbWF0W2ldW2ldO1xuICAgICAgZm9yIChsZXQgayA9IGk7IGsgPCBuICsgMTsgaysrKSB7XG4gICAgICAgIGlmIChpID09IGspIHtcbiAgICAgICAgICBtYXRbal1ba10gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdFtqXVtrXSArPSBjb2VmICogbWF0W2ldW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU29sdmUgQXg9YiBmb3IgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggQSAobWF0KVxuICBjb25zdCB4ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKGxldCBsID0gbiAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgeFtsXSA9IG1hdFtsXVtuXSAvIG1hdFtsXVtsXTtcbiAgICBmb3IgKGxldCBtID0gbCAtIDE7IG0gPj0gMDsgbS0tKSB7XG4gICAgICBtYXRbbV1bbl0gLT0gbWF0W21dW2xdICogeFtsXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbi8qKlxuICogQ29udmVydHMgcmFkaWFucyB0byB0byBkZWdyZWVzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBBbmdsZSBpbiByYWRpYW5zLlxuICogQHJldHVybiB7bnVtYmVyfSBBbmdsZSBpbiBkZWdyZWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EZWdyZWVzKGFuZ2xlSW5SYWRpYW5zKSB7XG4gIHJldHVybiAoYW5nbGVJblJhZGlhbnMgKiAxODApIC8gTWF0aC5QSTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBkZWdyZWVzIHRvIHJhZGlhbnMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5EZWdyZWVzIEFuZ2xlIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuZ2xlIGluIHJhZGlhbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JhZGlhbnMoYW5nbGVJbkRlZ3JlZXMpIHtcbiAgcmV0dXJuIChhbmdsZUluRGVncmVlcyAqIE1hdGguUEkpIC8gMTgwO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1vZHVsbyBvZiBhIC8gYiwgZGVwZW5kaW5nIG9uIHRoZSBzaWduIG9mIGIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGEgRGl2aWRlbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gYiBEaXZpc29yLlxuICogQHJldHVybiB7bnVtYmVyfSBNb2R1bG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb2R1bG8oYSwgYikge1xuICBjb25zdCByID0gYSAlIGI7XG4gIHJldHVybiByICogYiA8IDAgPyByICsgYiA6IHI7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGluZWFybHkgaW50ZXJwb2xhdGVkIHZhbHVlIG9mIHggYmV0d2VlbiBhIGFuZCBiLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIE51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGIgTnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0geCBWYWx1ZSB0byBiZSBpbnRlcnBvbGF0ZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEludGVycG9sYXRlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAoYSwgYiwgeCkge1xuICByZXR1cm4gYSArIHggKiAoYiAtIGEpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgd2l0aCBhIGxpbWl0ZWQgbnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGlucHV0IG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFscyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBkaWdpdHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnB1dCBudW1iZXIgd2l0aCBhIGxpbWl0ZWQgbnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9GaXhlZChuLCBkZWNpbWFscykge1xuICBjb25zdCBmYWN0b3IgPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICByZXR1cm4gTWF0aC5yb3VuZChuICogZmFjdG9yKSAvIGZhY3Rvcjtcbn1cblxuLyoqXG4gKiBSb3VuZHMgYSBudW1iZXIgdG8gdGhlIG5lYXJlc3QgaW50ZWdlciB2YWx1ZSBjb25zaWRlcmluZyBvbmx5IHRoZSBnaXZlbiBudW1iZXJcbiAqIG9mIGRlY2ltYWwgZGlnaXRzICh3aXRoIHJvdW5kaW5nIG9uIHRoZSBmaW5hbCBkaWdpdCkuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgaW5wdXQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxzIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG5lYXJlc3QgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG4sIGRlY2ltYWxzKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHRvRml4ZWQobiwgZGVjaW1hbHMpKTtcbn1cblxuLyoqXG4gKiBSb3VuZHMgYSBudW1iZXIgdG8gdGhlIG5leHQgc21hbGxlciBpbnRlZ2VyIGNvbnNpZGVyaW5nIG9ubHkgdGhlIGdpdmVuIG51bWJlclxuICogb2YgZGVjaW1hbCBkaWdpdHMgKHdpdGggcm91bmRpbmcgb24gdGhlIGZpbmFsIGRpZ2l0KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbnB1dCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbHMgVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmV4dCBzbWFsbGVyIGludGVnZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihuLCBkZWNpbWFscykge1xuICByZXR1cm4gTWF0aC5mbG9vcih0b0ZpeGVkKG4sIGRlY2ltYWxzKSk7XG59XG5cbi8qKlxuICogUm91bmRzIGEgbnVtYmVyIHRvIHRoZSBuZXh0IGJpZ2dlciBpbnRlZ2VyIGNvbnNpZGVyaW5nIG9ubHkgdGhlIGdpdmVuIG51bWJlclxuICogb2YgZGVjaW1hbCBkaWdpdHMgKHdpdGggcm91bmRpbmcgb24gdGhlIGZpbmFsIGRpZ2l0KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbnB1dCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbHMgVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmV4dCBiaWdnZXIgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlaWwobiwgZGVjaW1hbHMpIHtcbiAgcmV0dXJuIE1hdGguY2VpbCh0b0ZpeGVkKG4sIGRlY2ltYWxzKSk7XG59XG4iXSwibmFtZXMiOlsiY2xhbXAiLCJ2YWx1ZSIsIm1pbiIsIm1heCIsIk1hdGgiLCJzcXVhcmVkU2VnbWVudERpc3RhbmNlIiwieCIsInkiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImR4IiwiZHkiLCJ0Iiwic3F1YXJlZERpc3RhbmNlIiwic29sdmVMaW5lYXJTeXN0ZW0iLCJtYXQiLCJuIiwibGVuZ3RoIiwiaSIsIm1heFJvdyIsIm1heEVsIiwiYWJzIiwiciIsImFic1ZhbHVlIiwidG1wIiwiaiIsImNvZWYiLCJrIiwiQXJyYXkiLCJsIiwibSIsInRvRGVncmVlcyIsImFuZ2xlSW5SYWRpYW5zIiwiUEkiLCJ0b1JhZGlhbnMiLCJhbmdsZUluRGVncmVlcyIsIm1vZHVsbyIsImEiLCJiIiwibGVycCIsInRvRml4ZWQiLCJkZWNpbWFscyIsImZhY3RvciIsInBvdyIsInJvdW5kIiwiZmxvb3IiLCJjZWlsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/math.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ol/obj.js":
/*!********************************!*\
  !*** ./node_modules/ol/obj.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clear: () => (/* binding */ clear),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty)\n/* harmony export */ });\n/**\n * @module ol/obj\n */ /**\n * Removes all properties from an object.\n * @param {Object<string, unknown>} object The object to clear.\n */ function clear(object) {\n    for(const property in object){\n        delete object[property];\n    }\n}\n/**\n * Determine if an object has any properties.\n * @param {Object} object The object to check.\n * @return {boolean} The object is empty.\n */ function isEmpty(object) {\n    let property;\n    for(property in object){\n        return false;\n    }\n    return !property;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2wvb2JqLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0NBRUMsR0FFRDs7O0NBR0MsR0FDTSxTQUFTQSxNQUFNQyxNQUFNO0lBQzFCLElBQUssTUFBTUMsWUFBWUQsT0FBUTtRQUM3QixPQUFPQSxNQUFNLENBQUNDLFNBQVM7SUFDekI7QUFDRjtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTQyxRQUFRRixNQUFNO0lBQzVCLElBQUlDO0lBQ0osSUFBS0EsWUFBWUQsT0FBUTtRQUN2QixPQUFPO0lBQ1Q7SUFDQSxPQUFPLENBQUNDO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXAvLi9ub2RlX21vZHVsZXMvb2wvb2JqLmpzPzk4NDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL29ialxuICovXG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgcHJvcGVydGllcyBmcm9tIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgdW5rbm93bj59IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsZWFyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIob2JqZWN0KSB7XG4gIGZvciAoY29uc3QgcHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGhhcyBhbnkgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBvYmplY3QgaXMgZW1wdHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KG9iamVjdCkge1xuICBsZXQgcHJvcGVydHk7XG4gIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhcHJvcGVydHk7XG59XG4iXSwibmFtZXMiOlsiY2xlYXIiLCJvYmplY3QiLCJwcm9wZXJ0eSIsImlzRW1wdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/obj.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ol/proj.js":
/*!*********************************!*\
  !*** ./node_modules/ol/proj.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   METERS_PER_UNIT: () => (/* reexport safe */ _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT),\n/* harmony export */   Projection: () => (/* reexport safe */ _proj_Projection_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   addCommon: () => (/* binding */ addCommon),\n/* harmony export */   addCoordinateTransforms: () => (/* binding */ addCoordinateTransforms),\n/* harmony export */   addEquivalentProjections: () => (/* binding */ addEquivalentProjections),\n/* harmony export */   addEquivalentTransforms: () => (/* binding */ addEquivalentTransforms),\n/* harmony export */   addProjection: () => (/* binding */ addProjection),\n/* harmony export */   addProjections: () => (/* binding */ addProjections),\n/* harmony export */   clearAllProjections: () => (/* binding */ clearAllProjections),\n/* harmony export */   clearUserProjection: () => (/* binding */ clearUserProjection),\n/* harmony export */   cloneTransform: () => (/* binding */ cloneTransform),\n/* harmony export */   createProjection: () => (/* binding */ createProjection),\n/* harmony export */   createSafeCoordinateTransform: () => (/* binding */ createSafeCoordinateTransform),\n/* harmony export */   createTransformFromCoordinateTransform: () => (/* binding */ createTransformFromCoordinateTransform),\n/* harmony export */   disableCoordinateWarning: () => (/* binding */ disableCoordinateWarning),\n/* harmony export */   equivalent: () => (/* binding */ equivalent),\n/* harmony export */   fromLonLat: () => (/* binding */ fromLonLat),\n/* harmony export */   fromUserCoordinate: () => (/* binding */ fromUserCoordinate),\n/* harmony export */   fromUserExtent: () => (/* binding */ fromUserExtent),\n/* harmony export */   fromUserResolution: () => (/* binding */ fromUserResolution),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getPointResolution: () => (/* binding */ getPointResolution),\n/* harmony export */   getTransform: () => (/* binding */ getTransform),\n/* harmony export */   getTransformFromProjections: () => (/* binding */ getTransformFromProjections),\n/* harmony export */   getUserProjection: () => (/* binding */ getUserProjection),\n/* harmony export */   identityTransform: () => (/* binding */ identityTransform),\n/* harmony export */   setUserProjection: () => (/* binding */ setUserProjection),\n/* harmony export */   toLonLat: () => (/* binding */ toLonLat),\n/* harmony export */   toUserCoordinate: () => (/* binding */ toUserCoordinate),\n/* harmony export */   toUserExtent: () => (/* binding */ toUserExtent),\n/* harmony export */   toUserResolution: () => (/* binding */ toUserResolution),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   transformExtent: () => (/* binding */ transformExtent),\n/* harmony export */   transformWithProjections: () => (/* binding */ transformWithProjections),\n/* harmony export */   useGeographic: () => (/* binding */ useGeographic)\n/* harmony export */ });\n/* harmony import */ var _proj_Projection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./proj/Projection.js */ \"(ssr)/./node_modules/ol/proj/Projection.js\");\n/* harmony import */ var _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./proj/epsg3857.js */ \"(ssr)/./node_modules/ol/proj/epsg3857.js\");\n/* harmony import */ var _proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./proj/epsg4326.js */ \"(ssr)/./node_modules/ol/proj/epsg4326.js\");\n/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj/Units.js */ \"(ssr)/./node_modules/ol/proj/Units.js\");\n/* harmony import */ var _proj_projections_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proj/projections.js */ \"(ssr)/./node_modules/ol/proj/projections.js\");\n/* harmony import */ var _proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proj/transforms.js */ \"(ssr)/./node_modules/ol/proj/transforms.js\");\n/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extent.js */ \"(ssr)/./node_modules/ol/extent.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/ol/math.js\");\n/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coordinate.js */ \"(ssr)/./node_modules/ol/coordinate.js\");\n/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sphere.js */ \"(ssr)/./node_modules/ol/sphere.js\");\n/* harmony import */ var _console_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./console.js */ \"(ssr)/./node_modules/ol/console.js\");\n/**\n * @module ol/proj\n */ /**\n * The ol/proj module stores:\n * * a list of {@link module:ol/proj/Projection~Projection}\n * objects, one for each projection supported by the application\n * * a list of transform functions needed to convert coordinates in one projection\n * into another.\n *\n * The static functions are the methods used to maintain these.\n * Each transform function can handle not only simple coordinate pairs, but also\n * large arrays of coordinates such as vector geometries.\n *\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\n * for example by Bing Maps or OpenStreetMap), together with the relevant\n * transform functions.\n *\n * Additional transforms may be added by using the http://proj4js.org/\n * library (version 2.2 or later). You can use the full build supplied by\n * Proj4js, or create a custom build to support those projections you need; see\n * the Proj4js website for how to do this. You also need the Proj4js definitions\n * for the required projections. These definitions can be obtained from\n * https://epsg.io/, and are a JS function, so can be loaded in a script\n * tag (as in the examples) or pasted into your application.\n *\n * After all required projection definitions are added to proj4's registry (by\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\n * package. Existing transforms are not changed by this function. See\n * examples/wms-image-custom-proj for an example of this.\n *\n * Additional projection definitions can be registered with `proj4.defs()` any\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't\n * know in advance what projections are needed, you can initially load minimal\n * support and then load whichever are requested.\n *\n * Note that Proj4js does not support projection extents. If you want to add\n * one for creating default tile grids, you can add it after the Projection\n * object has been created with `setExtent`, for example,\n * `get('EPSG:1234').setExtent(extent)`.\n *\n * In addition to Proj4js support, any transform functions can be added with\n * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create\n * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with\n * {@link module:ol/proj.addProjection}. You can then add the forward and inverse\n * functions with {@link module:ol/proj.addCoordinateTransforms}. See\n * examples/wms-custom-proj for an example of this.\n *\n * Note that if no transforms are needed and you only need to define the\n * projection, just add a {@link module:ol/proj/Projection~Projection} with\n * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of\n * this.\n */ \n\n\n\n\n\n\n\n\n\n\n/**\n * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier\n * string or undefined.\n * @typedef {Projection|string|undefined} ProjectionLike\n * @api\n */ /**\n * A transform function accepts an array of input coordinate values, an optional\n * output array, and an optional dimension (default should be 2).  The function\n * transforms the input coordinate values, populates the output array, and\n * returns the output array.\n *\n * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction\n * @api\n */ \n\nlet showCoordinateWarning = true;\n/**\n * @param {boolean} [disable = true] Disable console info about `useGeographic()`\n */ function disableCoordinateWarning(disable) {\n    const hide = disable === undefined ? true : disable;\n    showCoordinateWarning = !hide;\n}\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @return {Array<number>} Output coordinate array (new array, same coordinate\n *     values).\n */ function cloneTransform(input, output) {\n    if (output !== undefined) {\n        for(let i = 0, ii = input.length; i < ii; ++i){\n            output[i] = input[i];\n        }\n        output = output;\n    } else {\n        output = input.slice();\n    }\n    return output;\n}\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @return {Array<number>} Input coordinate array (same array as input).\n */ function identityTransform(input, output) {\n    if (output !== undefined && input !== output) {\n        for(let i = 0, ii = input.length; i < ii; ++i){\n            output[i] = input[i];\n        }\n        input = output;\n    }\n    return input;\n}\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {Projection} projection Projection instance.\n * @api\n */ function addProjection(projection) {\n    (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_2__.add)(projection.getCode(), projection);\n    (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(projection, projection, cloneTransform);\n}\n/**\n * @param {Array<Projection>} projections Projections.\n */ function addProjections(projections) {\n    projections.forEach(addProjection);\n}\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {Projection|null} Projection object, or null if not in list.\n * @api\n */ function get(projectionLike) {\n    return typeof projectionLike === \"string\" ? (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_2__.get)(/** @type {string} */ projectionLike) : /** @type {Projection} */ projectionLike || null;\n}\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the `point` pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link module:ol/proj/Projection~Projection} constructor or by using\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {import(\"./coordinate.js\").Coordinate} point Point to find adjusted resolution at.\n * @param {import(\"./proj/Units.js\").Units} [units] Units to get the point resolution in.\n * Default is the projection's units.\n * @return {number} Point resolution.\n * @api\n */ function getPointResolution(projection, resolution, point, units) {\n    projection = get(projection);\n    let pointResolution;\n    const getter = projection.getPointResolutionFunc();\n    if (getter) {\n        pointResolution = getter(resolution, point);\n        if (units && units !== projection.getUnits()) {\n            const metersPerUnit = projection.getMetersPerUnit();\n            if (metersPerUnit) {\n                pointResolution = pointResolution * metersPerUnit / _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[units];\n            }\n        }\n    } else {\n        const projUnits = projection.getUnits();\n        if (projUnits == \"degrees\" && !units || units == \"degrees\") {\n            pointResolution = resolution;\n        } else {\n            // Estimate point resolution by transforming the center pixel to EPSG:4326,\n            // measuring its width and height on the normal sphere, and taking the\n            // average of the width and height.\n            const toEPSG4326 = getTransformFromProjections(projection, get(\"EPSG:4326\"));\n            if (toEPSG4326 === identityTransform && projUnits !== \"degrees\") {\n                // no transform is available\n                pointResolution = resolution * projection.getMetersPerUnit();\n            } else {\n                let vertices = [\n                    point[0] - resolution / 2,\n                    point[1],\n                    point[0] + resolution / 2,\n                    point[1],\n                    point[0],\n                    point[1] - resolution / 2,\n                    point[0],\n                    point[1] + resolution / 2\n                ];\n                vertices = toEPSG4326(vertices, vertices, 2);\n                const width = (0,_sphere_js__WEBPACK_IMPORTED_MODULE_4__.getDistance)(vertices.slice(0, 2), vertices.slice(2, 4));\n                const height = (0,_sphere_js__WEBPACK_IMPORTED_MODULE_4__.getDistance)(vertices.slice(4, 6), vertices.slice(6, 8));\n                pointResolution = (width + height) / 2;\n            }\n            const metersPerUnit = units ? _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[units] : projection.getMetersPerUnit();\n            if (metersPerUnit !== undefined) {\n                pointResolution /= metersPerUnit;\n            }\n        }\n    }\n    return pointResolution;\n}\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array<Projection>} projections Projections.\n * @api\n */ function addEquivalentProjections(projections) {\n    addProjections(projections);\n    projections.forEach(function(source) {\n        projections.forEach(function(destination) {\n            if (source !== destination) {\n                (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(source, destination, cloneTransform);\n            }\n        });\n    });\n}\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array<Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array<Projection>} projections2 Projections with equal\n *     meaning.\n * @param {TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */ function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {\n    projections1.forEach(function(projection1) {\n        projections2.forEach(function(projection2) {\n            (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(projection1, projection2, forwardTransform);\n            (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(projection2, projection1, inverseTransform);\n        });\n    });\n}\n/**\n * Clear all cached projections and transforms.\n */ function clearAllProjections() {\n    (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_2__.clear)();\n    (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.clear)();\n}\n/**\n * @param {Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {Projection} Projection.\n */ function createProjection(projection, defaultCode) {\n    if (!projection) {\n        return get(defaultCode);\n    }\n    if (typeof projection === \"string\") {\n        return get(projection);\n    }\n    return /** @type {Projection} */ projection;\n}\n/**\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} coordTransform Coordinate\n *     transform.\n * @return {TransformFunction} Transform function.\n */ function createTransformFromCoordinateTransform(coordTransform) {\n    return(/**\n     * @param {Array<number>} input Input.\n     * @param {Array<number>} [output] Output.\n     * @param {number} [dimension] Dimension.\n     * @return {Array<number>} Output.\n     */ function(input, output, dimension) {\n        const length = input.length;\n        dimension = dimension !== undefined ? dimension : 2;\n        output = output !== undefined ? output : new Array(length);\n        for(let i = 0; i < length; i += dimension){\n            const point = coordTransform(input.slice(i, i + dimension));\n            const pointLength = point.length;\n            for(let j = 0, jj = dimension; j < jj; ++j){\n                output[i + j] = j >= pointLength ? input[i + j] : point[j];\n            }\n        }\n        return output;\n    });\n}\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ProjectionLike} source Source projection.\n * @param {ProjectionLike} destination Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only\n *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate\n *     with only the length it can transform. The other dimensions will be taken unchanged from the\n *     source.\n * @api\n */ function addCoordinateTransforms(source, destination, forward, inverse) {\n    const sourceProj = get(source);\n    const destProj = get(destination);\n    (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(sourceProj, destProj, createTransformFromCoordinateTransform(forward));\n    (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));\n}\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ProjectionLike} [projection] Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate projected to the target projection.\n * @api\n */ function fromLonLat(coordinate, projection) {\n    disableCoordinateWarning();\n    return transform(coordinate, \"EPSG:4326\", projection !== undefined ? projection : \"EPSG:3857\");\n}\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Projected coordinate.\n * @param {ProjectionLike} [projection] Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */ function toLonLat(coordinate, projection) {\n    const lonLat = transform(coordinate, projection !== undefined ? projection : \"EPSG:3857\", \"EPSG:4326\");\n    const lon = lonLat[0];\n    if (lon < -180 || lon > 180) {\n        lonLat[0] = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.modulo)(lon + 180, 360) - 180;\n    }\n    return lonLat;\n}\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {Projection} projection1 Projection 1.\n * @param {Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */ function equivalent(projection1, projection2) {\n    if (projection1 === projection2) {\n        return true;\n    }\n    const equalUnits = projection1.getUnits() === projection2.getUnits();\n    if (projection1.getCode() === projection2.getCode()) {\n        return equalUnits;\n    }\n    const transformFunc = getTransformFromProjections(projection1, projection2);\n    return transformFunc === cloneTransform && equalUnits;\n}\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {Projection} sourceProjection Source Projection object.\n * @param {Projection} destinationProjection Destination Projection\n *     object.\n * @return {TransformFunction} Transform function.\n */ function getTransformFromProjections(sourceProjection, destinationProjection) {\n    const sourceCode = sourceProjection.getCode();\n    const destinationCode = destinationProjection.getCode();\n    let transformFunc = (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.get)(sourceCode, destinationCode);\n    if (!transformFunc) {\n        transformFunc = identityTransform;\n    }\n    return transformFunc;\n}\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ProjectionLike} source Source.\n * @param {ProjectionLike} destination Destination.\n * @return {TransformFunction} Transform function.\n * @api\n */ function getTransform(source, destination) {\n    const sourceProjection = get(source);\n    const destinationProjection = get(destination);\n    return getTransformFromProjections(sourceProjection, destinationProjection);\n}\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link module:ol/proj.transformExtent} for extent transformation.\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\n * subclasses for geometry transforms.\n *\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n * @api\n */ function transform(coordinate, source, destination) {\n    const transformFunc = getTransform(source, destination);\n    return transformFunc(coordinate, undefined, coordinate.length);\n}\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {import(\"./extent.js\").Extent} extent The extent to transform.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @param {number} [stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {import(\"./extent.js\").Extent} The transformed extent.\n * @api\n */ function transformExtent(extent, source, destination, stops) {\n    const transformFunc = getTransform(source, destination);\n    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.applyTransform)(extent, transformFunc, undefined, stops);\n}\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {import(\"./coordinate.js\").Coordinate} point Point.\n * @param {Projection} sourceProjection Source projection.\n * @param {Projection} destinationProjection Destination projection.\n * @return {import(\"./coordinate.js\").Coordinate} Point.\n */ function transformWithProjections(point, sourceProjection, destinationProjection) {\n    const transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);\n    return transformFunc(point);\n}\n/**\n * @type {Projection|null}\n */ let userProjection = null;\n/**\n * Set the projection for coordinates supplied from and returned by API methods.\n * This includes all API methods except for those interacting with tile grids,\n * plus {@link import(\"./Map.js\").FrameState} and {@link import(\"./View.js\").State}.\n * @param {ProjectionLike} projection The user projection.\n * @api\n */ function setUserProjection(projection) {\n    userProjection = get(projection);\n}\n/**\n * Clear the user projection if set.\n * @api\n */ function clearUserProjection() {\n    userProjection = null;\n}\n/**\n * Get the projection for coordinates supplied from and returned by API methods.\n * @return {Projection|null} The user projection (or null if not set).\n * @api\n */ function getUserProjection() {\n    return userProjection;\n}\n/**\n * Use geographic coordinates (WGS-84 datum) in API methods.\n * This includes all API methods except for those interacting with tile grids,\n * plus {@link import(\"./Map.js\").FrameState} and {@link import(\"./View.js\").State}.\n * @api\n */ function useGeographic() {\n    setUserProjection(\"EPSG:4326\");\n}\n/**\n * Return a coordinate transformed into the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} sourceProjection The input coordinate projection.\n * @return {Array<number>} The input coordinate in the user projection.\n */ function toUserCoordinate(coordinate, sourceProjection) {\n    if (!userProjection) {\n        return coordinate;\n    }\n    return transform(coordinate, sourceProjection, userProjection);\n}\n/**\n * Return a coordinate transformed from the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {Array<number>} The input coordinate transformed.\n */ function fromUserCoordinate(coordinate, destProjection) {\n    if (!userProjection) {\n        if (showCoordinateWarning && !(0,_coordinate_js__WEBPACK_IMPORTED_MODULE_7__.equals)(coordinate, [\n            0,\n            0\n        ]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {\n            showCoordinateWarning = false;\n            (0,_console_js__WEBPACK_IMPORTED_MODULE_8__.warn)(\"Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.\");\n        }\n        return coordinate;\n    }\n    return transform(coordinate, userProjection, destProjection);\n}\n/**\n * Return an extent transformed into the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} sourceProjection The input extent projection.\n * @return {import(\"./extent.js\").Extent} The input extent in the user projection.\n */ function toUserExtent(extent, sourceProjection) {\n    if (!userProjection) {\n        return extent;\n    }\n    return transformExtent(extent, sourceProjection, userProjection);\n}\n/**\n * Return an extent transformed from the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {import(\"./extent.js\").Extent} The input extent transformed.\n */ function fromUserExtent(extent, destProjection) {\n    if (!userProjection) {\n        return extent;\n    }\n    return transformExtent(extent, userProjection, destProjection);\n}\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in input projection units per pixel.\n * @param {ProjectionLike} sourceProjection The input projection.\n * @return {number} Resolution in user projection units per pixel.\n */ function toUserResolution(resolution, sourceProjection) {\n    if (!userProjection) {\n        return resolution;\n    }\n    const sourceMetersPerUnit = get(sourceProjection).getMetersPerUnit();\n    const userMetersPerUnit = userProjection.getMetersPerUnit();\n    return sourceMetersPerUnit && userMetersPerUnit ? resolution * sourceMetersPerUnit / userMetersPerUnit : resolution;\n}\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in user projection units per pixel.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {number} Resolution in destination projection units per pixel.\n */ function fromUserResolution(resolution, destProjection) {\n    if (!userProjection) {\n        return resolution;\n    }\n    const destMetersPerUnit = get(destProjection).getMetersPerUnit();\n    const userMetersPerUnit = userProjection.getMetersPerUnit();\n    return destMetersPerUnit && userMetersPerUnit ? resolution * userMetersPerUnit / destMetersPerUnit : resolution;\n}\n/**\n * Creates a safe coordinate transform function from a coordinate transform function.\n * \"Safe\" means that it can handle wrapping of x-coordinates for global projections,\n * and that coordinates exceeding the source projection validity extent's range will be\n * clamped to the validity range.\n * @param {Projection} sourceProj Source projection.\n * @param {Projection} destProj Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} transform Transform function (source to destination).\n * @return {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} Safe transform function (source to destination).\n */ function createSafeCoordinateTransform(sourceProj, destProj, transform) {\n    return function(coord) {\n        let transformed, worldsAway;\n        if (sourceProj.canWrapX()) {\n            const sourceExtent = sourceProj.getExtent();\n            const sourceExtentWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.getWidth)(sourceExtent);\n            coord = coord.slice(0);\n            worldsAway = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_7__.getWorldsAway)(coord, sourceProj, sourceExtentWidth);\n            if (worldsAway) {\n                // Move x to the real world\n                coord[0] = coord[0] - worldsAway * sourceExtentWidth;\n            }\n            coord[0] = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.clamp)(coord[0], sourceExtent[0], sourceExtent[2]);\n            coord[1] = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.clamp)(coord[1], sourceExtent[1], sourceExtent[3]);\n            transformed = transform(coord);\n        } else {\n            transformed = transform(coord);\n        }\n        if (worldsAway && destProj.canWrapX()) {\n            // Move transformed coordinate back to the offset world\n            transformed[0] += worldsAway * (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.getWidth)(destProj.getExtent());\n        }\n        return transformed;\n    };\n}\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `clearAllProjections()` is called (e.g. in tests).\n */ function addCommon() {\n    // Add transformations that don't alter coordinates to convert within set of\n    // projections with equal meaning.\n    addEquivalentProjections(_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__.PROJECTIONS);\n    addEquivalentProjections(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_10__.PROJECTIONS);\n    // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n    // coordinates and back.\n    addEquivalentTransforms(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_10__.PROJECTIONS, _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__.PROJECTIONS, _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__.fromEPSG4326, _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__.toEPSG4326);\n}\naddCommon();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2wvcHJvai5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrREMsR0FDNkM7QUFLbEI7QUFDMkM7QUFDdkI7QUFLakI7QUFLRDtBQUN1QjtBQUNiO0FBQ2M7QUFDZDtBQUNOO0FBRWxDOzs7OztDQUtDLEdBRUQ7Ozs7Ozs7O0NBUUMsR0FFd0I7QUFFTDtBQUVwQixJQUFJd0Isd0JBQXdCO0FBRTVCOztDQUVDLEdBQ00sU0FBU0MseUJBQXlCQyxPQUFPO0lBQzlDLE1BQU1DLE9BQU9ELFlBQVlFLFlBQVksT0FBT0Y7SUFDNUNGLHdCQUF3QixDQUFDRztBQUMzQjtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU0UsZUFBZUMsS0FBSyxFQUFFQyxNQUFNO0lBQzFDLElBQUlBLFdBQVdILFdBQVc7UUFDeEIsSUFBSyxJQUFJSSxJQUFJLEdBQUdDLEtBQUtILE1BQU1JLE1BQU0sRUFBRUYsSUFBSUMsSUFBSSxFQUFFRCxFQUFHO1lBQzlDRCxNQUFNLENBQUNDLEVBQUUsR0FBR0YsS0FBSyxDQUFDRSxFQUFFO1FBQ3RCO1FBQ0FELFNBQVNBO0lBQ1gsT0FBTztRQUNMQSxTQUFTRCxNQUFNSyxLQUFLO0lBQ3RCO0lBQ0EsT0FBT0o7QUFDVDtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTSyxrQkFBa0JOLEtBQUssRUFBRUMsTUFBTTtJQUM3QyxJQUFJQSxXQUFXSCxhQUFhRSxVQUFVQyxRQUFRO1FBQzVDLElBQUssSUFBSUMsSUFBSSxHQUFHQyxLQUFLSCxNQUFNSSxNQUFNLEVBQUVGLElBQUlDLElBQUksRUFBRUQsRUFBRztZQUM5Q0QsTUFBTSxDQUFDQyxFQUFFLEdBQUdGLEtBQUssQ0FBQ0UsRUFBRTtRQUN0QjtRQUNBRixRQUFRQztJQUNWO0lBQ0EsT0FB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WUFDckM7WUFDQU4sS0FBSyxDQUFDLEVBQUUsR0FBR3BHLCtDQUFLQSxDQUFDb0csS0FBSyxDQUFDLEVBQUUsRUFBRUksWUFBWSxDQUFDLEVBQUUsRUFBRUEsWUFBWSxDQUFDLEVBQUU7WUFDM0RKLEtBQUssQ0FBQyxFQUFFLEdBQUdwRywrQ0FBS0EsQ0FBQ29HLEtBQUssQ0FBQyxFQUFFLEVBQUVJLFlBQVksQ0FBQyxFQUFFLEVBQUVBLFlBQVksQ0FBQyxFQUFFO1lBQzNESCxjQUFjakMsVUFBVWdDO1FBQzFCLE9BQU87WUFDTEMsY0FBY2pDLFVBQVVnQztRQUMxQjtRQUNBLElBQUlFLGNBQWNyQyxTQUFTc0MsUUFBUSxJQUFJO1lBQ3JDLHVEQUF1RDtZQUN2REYsV0FBVyxDQUFDLEVBQUUsSUFBSUMsYUFBYXZHLG9EQUFRQSxDQUFDa0UsU0FBU3dDLFNBQVM7UUFDNUQ7UUFDQSxPQUFPSjtJQUNUO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ00sU0FBU007SUFDZCw0RUFBNEU7SUFDNUUsa0NBQWtDO0lBQ2xDbEUseUJBQXlCekQsMERBQW9CQTtJQUM3Q3lELHlCQUF5QnRELDJEQUFvQkE7SUFDN0MsOEVBQThFO0lBQzlFLHdCQUF3QjtJQUN4QnlELHdCQUNFekQsMkRBQW9CQSxFQUNwQkgsMERBQW9CQSxFQUNwQkMsMkRBQVlBLEVBQ1pDLHlEQUFVQTtBQUVkO0FBRUF5SCIsInNvdXJjZXMiOlsid2VicGFjazovL21hcC8uL25vZGVfbW9kdWxlcy9vbC9wcm9qLmpzPzA1Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2pcbiAqL1xuXG4vKipcbiAqIFRoZSBvbC9wcm9qIG1vZHVsZSBzdG9yZXM6XG4gKiAqIGEgbGlzdCBvZiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufVxuICogb2JqZWN0cywgb25lIGZvciBlYWNoIHByb2plY3Rpb24gc3VwcG9ydGVkIGJ5IHRoZSBhcHBsaWNhdGlvblxuICogKiBhIGxpc3Qgb2YgdHJhbnNmb3JtIGZ1bmN0aW9ucyBuZWVkZWQgdG8gY29udmVydCBjb29yZGluYXRlcyBpbiBvbmUgcHJvamVjdGlvblxuICogaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBzdGF0aWMgZnVuY3Rpb25zIGFyZSB0aGUgbWV0aG9kcyB1c2VkIHRvIG1haW50YWluIHRoZXNlLlxuICogRWFjaCB0cmFuc2Zvcm0gZnVuY3Rpb24gY2FuIGhhbmRsZSBub3Qgb25seSBzaW1wbGUgY29vcmRpbmF0ZSBwYWlycywgYnV0IGFsc29cbiAqIGxhcmdlIGFycmF5cyBvZiBjb29yZGluYXRlcyBzdWNoIGFzIHZlY3RvciBnZW9tZXRyaWVzLlxuICpcbiAqIFdoZW4gbG9hZGVkLCB0aGUgbGlicmFyeSBhZGRzIHByb2plY3Rpb24gb2JqZWN0cyBmb3IgRVBTRzo0MzI2IChXR1M4NFxuICogZ2VvZ3JhcGhpYyBjb29yZGluYXRlcykgYW5kIEVQU0c6Mzg1NyAoV2ViIG9yIFNwaGVyaWNhbCBNZXJjYXRvciwgYXMgdXNlZFxuICogZm9yIGV4YW1wbGUgYnkgQmluZyBNYXBzIG9yIE9wZW5TdHJlZXRNYXApLCB0b2dldGhlciB3aXRoIHRoZSByZWxldmFudFxuICogdHJhbnNmb3JtIGZ1bmN0aW9ucy5cbiAqXG4gKiBBZGRpdGlvbmFsIHRyYW5zZm9ybXMgbWF5IGJlIGFkZGVkIGJ5IHVzaW5nIHRoZSBodHRwOi8vcHJvajRqcy5vcmcvXG4gKiBsaWJyYXJ5ICh2ZXJzaW9uIDIuMiBvciBsYXRlcikuIFlvdSBjYW4gdXNlIHRoZSBmdWxsIGJ1aWxkIHN1cHBsaWVkIGJ5XG4gKiBQcm9qNGpzLCBvciBjcmVhdGUgYSBjdXN0b20gYnVpbGQgdG8gc3VwcG9ydCB0aG9zZSBwcm9qZWN0aW9ucyB5b3UgbmVlZDsgc2VlXG4gKiB0aGUgUHJvajRqcyB3ZWJzaXRlIGZvciBob3cgdG8gZG8gdGhpcy4gWW91IGFsc28gbmVlZCB0aGUgUHJvajRqcyBkZWZpbml0aW9uc1xuICogZm9yIHRoZSByZXF1aXJlZCBwcm9qZWN0aW9ucy4gVGhlc2UgZGVmaW5pdGlvbnMgY2FuIGJlIG9idGFpbmVkIGZyb21cbiAqIGh0dHBzOi8vZXBzZy5pby8sIGFuZCBhcmUgYSBKUyBmdW5jdGlvbiwgc28gY2FuIGJlIGxvYWRlZCBpbiBhIHNjcmlwdFxuICogdGFnIChhcyBpbiB0aGUgZXhhbXBsZXMpIG9yIHBhc3RlZCBpbnRvIHlvdXIgYXBwbGljYXRpb24uXG4gKlxuICogQWZ0ZXIgYWxsIHJlcXVpcmVkIHByb2plY3Rpb24gZGVmaW5pdGlvbnMgYXJlIGFkZGVkIHRvIHByb2o0J3MgcmVnaXN0cnkgKGJ5XG4gKiB1c2luZyBgcHJvajQuZGVmcygpYCksIHNpbXBseSBjYWxsIGByZWdpc3Rlcihwcm9qNClgIGZyb20gdGhlIGBvbC9wcm9qL3Byb2o0YFxuICogcGFja2FnZS4gRXhpc3RpbmcgdHJhbnNmb3JtcyBhcmUgbm90IGNoYW5nZWQgYnkgdGhpcyBmdW5jdGlvbi4gU2VlXG4gKiBleGFtcGxlcy93bXMtaW1hZ2UtY3VzdG9tLXByb2ogZm9yIGFuIGV4YW1wbGUgb2YgdGhpcy5cbiAqXG4gKiBBZGRpdGlvbmFsIHByb2plY3Rpb24gZGVmaW5pdGlvbnMgY2FuIGJlIHJlZ2lzdGVyZWQgd2l0aCBgcHJvajQuZGVmcygpYCBhbnlcbiAqIHRpbWUuIEp1c3QgbWFrZSBzdXJlIHRvIGNhbGwgYHJlZ2lzdGVyKHByb2o0KWAgYWdhaW47IGZvciBleGFtcGxlLCB3aXRoIHVzZXItc3VwcGxpZWQgZGF0YSB3aGVyZSB5b3UgZG9uJ3RcbiAqIGtub3cgaW4gYWR2YW5jZSB3aGF0IHByb2plY3Rpb25zIGFyZSBuZWVkZWQsIHlvdSBjYW4gaW5pdGlhbGx5IGxvYWQgbWluaW1hbFxuICogc3VwcG9ydCBhbmQgdGhlbiBsb2FkIHdoaWNoZXZlciBhcmUgcmVxdWVzdGVkLlxuICpcbiAqIE5vdGUgdGhhdCBQcm9qNGpzIGRvZXMgbm90IHN1cHBvcnQgcHJvamVjdGlvbiBleHRlbnRzLiBJZiB5b3Ugd2FudCB0byBhZGRcbiAqIG9uZSBmb3IgY3JlYXRpbmcgZGVmYXVsdCB0aWxlIGdyaWRzLCB5b3UgY2FuIGFkZCBpdCBhZnRlciB0aGUgUHJvamVjdGlvblxuICogb2JqZWN0IGhhcyBiZWVuIGNyZWF0ZWQgd2l0aCBgc2V0RXh0ZW50YCwgZm9yIGV4YW1wbGUsXG4gKiBgZ2V0KCdFUFNHOjEyMzQnKS5zZXRFeHRlbnQoZXh0ZW50KWAuXG4gKlxuICogSW4gYWRkaXRpb24gdG8gUHJvajRqcyBzdXBwb3J0LCBhbnkgdHJhbnNmb3JtIGZ1bmN0aW9ucyBjYW4gYmUgYWRkZWQgd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qLmFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zfS4gVG8gdXNlIHRoaXMsIHlvdSBtdXN0IGZpcnN0IGNyZWF0ZVxuICogYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBvYmplY3QgZm9yIHRoZSBuZXcgcHJvamVjdGlvbiBhbmQgYWRkIGl0IHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai5hZGRQcm9qZWN0aW9ufS4gWW91IGNhbiB0aGVuIGFkZCB0aGUgZm9yd2FyZCBhbmQgaW52ZXJzZVxuICogZnVuY3Rpb25zIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9wcm9qLmFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zfS4gU2VlXG4gKiBleGFtcGxlcy93bXMtY3VzdG9tLXByb2ogZm9yIGFuIGV4YW1wbGUgb2YgdGhpcy5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgbm8gdHJhbnNmb3JtcyBhcmUgbmVlZGVkIGFuZCB5b3Ugb25seSBuZWVkIHRvIGRlZmluZSB0aGVcbiAqIHByb2plY3Rpb24sIGp1c3QgYWRkIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qLmFkZFByb2plY3Rpb259LiBTZWUgZXhhbXBsZXMvd21zLW5vLXByb2ogZm9yIGFuIGV4YW1wbGUgb2ZcbiAqIHRoaXMuXG4gKi9cbmltcG9ydCBQcm9qZWN0aW9uIGZyb20gJy4vcHJvai9Qcm9qZWN0aW9uLmpzJztcbmltcG9ydCB7XG4gIFBST0pFQ1RJT05TIGFzIEVQU0czODU3X1BST0pFQ1RJT05TLFxuICBmcm9tRVBTRzQzMjYsXG4gIHRvRVBTRzQzMjYsXG59IGZyb20gJy4vcHJvai9lcHNnMzg1Ny5qcyc7XG5pbXBvcnQge1BST0pFQ1RJT05TIGFzIEVQU0c0MzI2X1BST0pFQ1RJT05TfSBmcm9tICcuL3Byb2ovZXBzZzQzMjYuanMnO1xuaW1wb3J0IHtNRVRFUlNfUEVSX1VOSVR9IGZyb20gJy4vcHJvai9Vbml0cy5qcyc7XG5pbXBvcnQge1xuICBhZGQgYXMgYWRkUHJvaixcbiAgY2xlYXIgYXMgY2xlYXJQcm9qLFxuICBnZXQgYXMgZ2V0UHJvaixcbn0gZnJvbSAnLi9wcm9qL3Byb2plY3Rpb25zLmpzJztcbmltcG9ydCB7XG4gIGFkZCBhcyBhZGRUcmFuc2Zvcm1GdW5jLFxuICBjbGVhciBhcyBjbGVhclRyYW5zZm9ybUZ1bmNzLFxuICBnZXQgYXMgZ2V0VHJhbnNmb3JtRnVuYyxcbn0gZnJvbSAnLi9wcm9qL3RyYW5zZm9ybXMuanMnO1xuaW1wb3J0IHthcHBseVRyYW5zZm9ybSwgZ2V0V2lkdGh9IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCB7Y2xhbXAsIG1vZHVsb30gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7ZXF1YWxzLCBnZXRXb3JsZHNBd2F5fSBmcm9tICcuL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHtnZXREaXN0YW5jZX0gZnJvbSAnLi9zcGhlcmUuanMnO1xuaW1wb3J0IHt3YXJufSBmcm9tICcuL2NvbnNvbGUuanMnO1xuXG4vKipcbiAqIEEgcHJvamVjdGlvbiBhcyB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSwgU1JTIGlkZW50aWZpZXJcbiAqIHN0cmluZyBvciB1bmRlZmluZWQuXG4gKiBAdHlwZWRlZiB7UHJvamVjdGlvbnxzdHJpbmd8dW5kZWZpbmVkfSBQcm9qZWN0aW9uTGlrZVxuICogQGFwaVxuICovXG5cbi8qKlxuICogQSB0cmFuc2Zvcm0gZnVuY3Rpb24gYWNjZXB0cyBhbiBhcnJheSBvZiBpbnB1dCBjb29yZGluYXRlIHZhbHVlcywgYW4gb3B0aW9uYWxcbiAqIG91dHB1dCBhcnJheSwgYW5kIGFuIG9wdGlvbmFsIGRpbWVuc2lvbiAoZGVmYXVsdCBzaG91bGQgYmUgMikuICBUaGUgZnVuY3Rpb25cbiAqIHRyYW5zZm9ybXMgdGhlIGlucHV0IGNvb3JkaW5hdGUgdmFsdWVzLCBwb3B1bGF0ZXMgdGhlIG91dHB1dCBhcnJheSwgYW5kXG4gKiByZXR1cm5zIHRoZSBvdXRwdXQgYXJyYXkuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEFycmF5PG51bWJlcj4sIEFycmF5PG51bWJlcj49LCBudW1iZXI9KTogQXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG5leHBvcnQge01FVEVSU19QRVJfVU5JVH07XG5cbmV4cG9ydCB7UHJvamVjdGlvbn07XG5cbmxldCBzaG93Q29vcmRpbmF0ZVdhcm5pbmcgPSB0cnVlO1xuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Rpc2FibGUgPSB0cnVlXSBEaXNhYmxlIGNvbnNvbGUgaW5mbyBhYm91dCBgdXNlR2VvZ3JhcGhpYygpYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUNvb3JkaW5hdGVXYXJuaW5nKGRpc2FibGUpIHtcbiAgY29uc3QgaGlkZSA9IGRpc2FibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBkaXNhYmxlO1xuICBzaG93Q29vcmRpbmF0ZVdhcm5pbmcgPSAhaGlkZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0IGNvb3JkaW5hdGUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvdXRwdXRdIE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE91dHB1dCBjb29yZGluYXRlIGFycmF5IChuZXcgYXJyYXksIHNhbWUgY29vcmRpbmF0ZVxuICogICAgIHZhbHVlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVRyYW5zZm9ybShpbnB1dCwgb3V0cHV0KSB7XG4gIGlmIChvdXRwdXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlucHV0Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG91dHB1dFtpXSA9IGlucHV0W2ldO1xuICAgIH1cbiAgICBvdXRwdXQgPSBvdXRwdXQ7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gaW5wdXQuc2xpY2UoKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQgY29vcmRpbmF0ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW291dHB1dF0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gSW5wdXQgY29vcmRpbmF0ZSBhcnJheSAoc2FtZSBhcnJheSBhcyBpbnB1dCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eVRyYW5zZm9ybShpbnB1dCwgb3V0cHV0KSB7XG4gIGlmIChvdXRwdXQgIT09IHVuZGVmaW5lZCAmJiBpbnB1dCAhPT0gb3V0cHV0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5wdXQubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgb3V0cHV0W2ldID0gaW5wdXRbaV07XG4gICAgfVxuICAgIGlucHV0ID0gb3V0cHV0O1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cblxuLyoqXG4gKiBBZGQgYSBQcm9qZWN0aW9uIG9iamVjdCB0byB0aGUgbGlzdCBvZiBzdXBwb3J0ZWQgcHJvamVjdGlvbnMgdGhhdCBjYW4gYmVcbiAqIGxvb2tlZCB1cCBieSB0aGVpciBjb2RlLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uIGluc3RhbmNlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIGFkZFByb2oocHJvamVjdGlvbi5nZXRDb2RlKCksIHByb2plY3Rpb24pO1xuICBhZGRUcmFuc2Zvcm1GdW5jKHByb2plY3Rpb24sIHByb2plY3Rpb24sIGNsb25lVHJhbnNmb3JtKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9ucyBQcm9qZWN0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb2plY3Rpb25zKHByb2plY3Rpb25zKSB7XG4gIHByb2plY3Rpb25zLmZvckVhY2goYWRkUHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogRmV0Y2hlcyBhIFByb2plY3Rpb24gb2JqZWN0IGZvciB0aGUgY29kZSBzcGVjaWZpZWQuXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbkxpa2UgRWl0aGVyIGEgY29kZSBzdHJpbmcgd2hpY2ggaXNcbiAqICAgICBhIGNvbWJpbmF0aW9uIG9mIGF1dGhvcml0eSBhbmQgaWRlbnRpZmllciBzdWNoIGFzIFwiRVBTRzo0MzI2XCIsIG9yIGFuXG4gKiAgICAgZXhpc3RpbmcgcHJvamVjdGlvbiBvYmplY3QsIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm4ge1Byb2plY3Rpb258bnVsbH0gUHJvamVjdGlvbiBvYmplY3QsIG9yIG51bGwgaWYgbm90IGluIGxpc3QuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQocHJvamVjdGlvbkxpa2UpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9qZWN0aW9uTGlrZSA9PT0gJ3N0cmluZydcbiAgICA/IGdldFByb2ooLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwcm9qZWN0aW9uTGlrZSkpXG4gICAgOiAvKiogQHR5cGUge1Byb2plY3Rpb259ICovIChwcm9qZWN0aW9uTGlrZSkgfHwgbnVsbDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJlc29sdXRpb24gb2YgdGhlIHBvaW50IGluIGRlZ3JlZXMgb3IgZGlzdGFuY2UgdW5pdHMuXG4gKiBGb3IgcHJvamVjdGlvbnMgd2l0aCBkZWdyZWVzIGFzIHRoZSB1bml0IHRoaXMgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZVxuICogcHJvdmlkZWQgcmVzb2x1dGlvbi4gRm9yIG90aGVyIHByb2plY3Rpb25zIHRoZSBwb2ludCByZXNvbHV0aW9uIGlzXG4gKiBieSBkZWZhdWx0IGVzdGltYXRlZCBieSB0cmFuc2Zvcm1pbmcgdGhlIGBwb2ludGAgcGl4ZWwgdG8gRVBTRzo0MzI2LFxuICogbWVhc3VyaW5nIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBub3JtYWwgc3BoZXJlLFxuICogYW5kIHRha2luZyB0aGUgYXZlcmFnZSBvZiB0aGUgd2lkdGggYW5kIGhlaWdodC5cbiAqIEEgY3VzdG9tIGZ1bmN0aW9uIGNhbiBiZSBwcm92aWRlZCBmb3IgYSBzcGVjaWZpYyBwcm9qZWN0aW9uLCBlaXRoZXJcbiAqIGJ5IHNldHRpbmcgdGhlIGBnZXRQb2ludFJlc29sdXRpb25gIG9wdGlvbiBpbiB0aGVcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IGNvbnN0cnVjdG9yIG9yIGJ5IHVzaW5nXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9uI3NldEdldFBvaW50UmVzb2x1dGlvbn0gdG8gY2hhbmdlIGFuIGV4aXN0aW5nXG4gKiBwcm9qZWN0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gVGhlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBOb21pbmFsIHJlc29sdXRpb24gaW4gcHJvamVjdGlvbiB1bml0cy5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50IFBvaW50IHRvIGZpbmQgYWRqdXN0ZWQgcmVzb2x1dGlvbiBhdC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1VuaXRzLmpzXCIpLlVuaXRzfSBbdW5pdHNdIFVuaXRzIHRvIGdldCB0aGUgcG9pbnQgcmVzb2x1dGlvbiBpbi5cbiAqIERlZmF1bHQgaXMgdGhlIHByb2plY3Rpb24ncyB1bml0cy5cbiAqIEByZXR1cm4ge251bWJlcn0gUG9pbnQgcmVzb2x1dGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBvaW50UmVzb2x1dGlvbihwcm9qZWN0aW9uLCByZXNvbHV0aW9uLCBwb2ludCwgdW5pdHMpIHtcbiAgcHJvamVjdGlvbiA9IGdldChwcm9qZWN0aW9uKTtcbiAgbGV0IHBvaW50UmVzb2x1dGlvbjtcbiAgY29uc3QgZ2V0dGVyID0gcHJvamVjdGlvbi5nZXRQb2ludFJlc29sdXRpb25GdW5jKCk7XG4gIGlmIChnZXR0ZXIpIHtcbiAgICBwb2ludFJlc29sdXRpb24gPSBnZXR0ZXIocmVzb2x1dGlvbiwgcG9pbnQpO1xuICAgIGlmICh1bml0cyAmJiB1bml0cyAhPT0gcHJvamVjdGlvbi5nZXRVbml0cygpKSB7XG4gICAgICBjb25zdCBtZXRlcnNQZXJVbml0ID0gcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgICBpZiAobWV0ZXJzUGVyVW5pdCkge1xuICAgICAgICBwb2ludFJlc29sdXRpb24gPVxuICAgICAgICAgIChwb2ludFJlc29sdXRpb24gKiBtZXRlcnNQZXJVbml0KSAvIE1FVEVSU19QRVJfVU5JVFt1bml0c107XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByb2pVbml0cyA9IHByb2plY3Rpb24uZ2V0VW5pdHMoKTtcbiAgICBpZiAoKHByb2pVbml0cyA9PSAnZGVncmVlcycgJiYgIXVuaXRzKSB8fCB1bml0cyA9PSAnZGVncmVlcycpIHtcbiAgICAgIHBvaW50UmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVzdGltYXRlIHBvaW50IHJlc29sdXRpb24gYnkgdHJhbnNmb3JtaW5nIHRoZSBjZW50ZXIgcGl4ZWwgdG8gRVBTRzo0MzI2LFxuICAgICAgLy8gbWVhc3VyaW5nIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBub3JtYWwgc3BoZXJlLCBhbmQgdGFraW5nIHRoZVxuICAgICAgLy8gYXZlcmFnZSBvZiB0aGUgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgIGNvbnN0IHRvRVBTRzQzMjYgPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoXG4gICAgICAgIHByb2plY3Rpb24sXG4gICAgICAgIGdldCgnRVBTRzo0MzI2JylcbiAgICAgICk7XG4gICAgICBpZiAodG9FUFNHNDMyNiA9PT0gaWRlbnRpdHlUcmFuc2Zvcm0gJiYgcHJvalVuaXRzICE9PSAnZGVncmVlcycpIHtcbiAgICAgICAgLy8gbm8gdHJhbnNmb3JtIGlzIGF2YWlsYWJsZVxuICAgICAgICBwb2ludFJlc29sdXRpb24gPSByZXNvbHV0aW9uICogcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdmVydGljZXMgPSBbXG4gICAgICAgICAgcG9pbnRbMF0gLSByZXNvbHV0aW9uIC8gMixcbiAgICAgICAgICBwb2ludFsxXSxcbiAgICAgICAgICBwb2ludFswXSArIHJlc29sdXRpb24gLyAyLFxuICAgICAgICAgIHBvaW50WzFdLFxuICAgICAgICAgIHBvaW50WzBdLFxuICAgICAgICAgIHBvaW50WzFdIC0gcmVzb2x1dGlvbiAvIDIsXG4gICAgICAgICAgcG9pbnRbMF0sXG4gICAgICAgICAgcG9pbnRbMV0gKyByZXNvbHV0aW9uIC8gMixcbiAgICAgICAgXTtcbiAgICAgICAgdmVydGljZXMgPSB0b0VQU0c0MzI2KHZlcnRpY2VzLCB2ZXJ0aWNlcywgMik7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0RGlzdGFuY2UodmVydGljZXMuc2xpY2UoMCwgMiksIHZlcnRpY2VzLnNsaWNlKDIsIDQpKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZ2V0RGlzdGFuY2UodmVydGljZXMuc2xpY2UoNCwgNiksIHZlcnRpY2VzLnNsaWNlKDYsIDgpKTtcbiAgICAgICAgcG9pbnRSZXNvbHV0aW9uID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXRlcnNQZXJVbml0ID0gdW5pdHNcbiAgICAgICAgPyBNRVRFUlNfUEVSX1VOSVRbdW5pdHNdXG4gICAgICAgIDogcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgICBpZiAobWV0ZXJzUGVyVW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50UmVzb2x1dGlvbiAvPSBtZXRlcnNQZXJVbml0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcG9pbnRSZXNvbHV0aW9uO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdGhhdCBkb24ndCBhbHRlciBjb29yZGluYXRlcy4gVGhvc2UgYWxsb3dcbiAqIHRvIHRyYW5zZm9ybSBiZXR3ZWVuIHByb2plY3Rpb25zIHdpdGggZXF1YWwgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9ucyBQcm9qZWN0aW9ucy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucykge1xuICBhZGRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucyk7XG4gIHByb2plY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIHByb2plY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gICAgICBpZiAoc291cmNlICE9PSBkZXN0aW5hdGlvbikge1xuICAgICAgICBhZGRUcmFuc2Zvcm1GdW5jKHNvdXJjZSwgZGVzdGluYXRpb24sIGNsb25lVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGluIGFueSBwcm9qZWN0aW9uXG4gKiBpbiBwcm9qZWN0aW9uMSB0byBhbnkgcHJvamVjdGlvbiBpbiBwcm9qZWN0aW9uMi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9uczEgUHJvamVjdGlvbnMgd2l0aCBlcXVhbFxuICogICAgIG1lYW5pbmcuXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9uczIgUHJvamVjdGlvbnMgd2l0aCBlcXVhbFxuICogICAgIG1lYW5pbmcuXG4gKiBAcGFyYW0ge1RyYW5zZm9ybUZ1bmN0aW9ufSBmb3J3YXJkVHJhbnNmb3JtIFRyYW5zZm9ybWF0aW9uIGZyb20gYW55XG4gKiAgIHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjEgdG8gYW55IHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjIuXG4gKiBAcGFyYW0ge1RyYW5zZm9ybUZ1bmN0aW9ufSBpbnZlcnNlVHJhbnNmb3JtIFRyYW5zZm9ybSBmcm9tIGFueSBwcm9qZWN0aW9uXG4gKiAgIGluIHByb2plY3Rpb24yIHRvIGFueSBwcm9qZWN0aW9uIGluIHByb2plY3Rpb24xLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVxdWl2YWxlbnRUcmFuc2Zvcm1zKFxuICBwcm9qZWN0aW9uczEsXG4gIHByb2plY3Rpb25zMixcbiAgZm9yd2FyZFRyYW5zZm9ybSxcbiAgaW52ZXJzZVRyYW5zZm9ybVxuKSB7XG4gIHByb2plY3Rpb25zMS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9qZWN0aW9uMSkge1xuICAgIHByb2plY3Rpb25zMi5mb3JFYWNoKGZ1bmN0aW9uIChwcm9qZWN0aW9uMikge1xuICAgICAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIsIGZvcndhcmRUcmFuc2Zvcm0pO1xuICAgICAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uMiwgcHJvamVjdGlvbjEsIGludmVyc2VUcmFuc2Zvcm0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDbGVhciBhbGwgY2FjaGVkIHByb2plY3Rpb25zIGFuZCB0cmFuc2Zvcm1zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJBbGxQcm9qZWN0aW9ucygpIHtcbiAgY2xlYXJQcm9qKCk7XG4gIGNsZWFyVHJhbnNmb3JtRnVuY3MoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb258c3RyaW5nfHVuZGVmaW5lZH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRDb2RlIERlZmF1bHQgY29kZS5cbiAqIEByZXR1cm4ge1Byb2plY3Rpb259IFByb2plY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm9qZWN0aW9uKHByb2plY3Rpb24sIGRlZmF1bHRDb2RlKSB7XG4gIGlmICghcHJvamVjdGlvbikge1xuICAgIHJldHVybiBnZXQoZGVmYXVsdENvZGUpO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvamVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZ2V0KHByb2plY3Rpb24pO1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUge1Byb2plY3Rpb259ICovIChwcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSBmcm9tIGEgc2ltcGxlIDJEIGNvb3JkaW5hdGUgdHJhbnNmb3JtXG4gKiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRUcmFuc2Zvcm0gQ29vcmRpbmF0ZVxuICogICAgIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge1RyYW5zZm9ybUZ1bmN0aW9ufSBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShjb29yZFRyYW5zZm9ybSkge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQuXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3V0cHV0XSBPdXRwdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkaW1lbnNpb25dIERpbWVuc2lvbi5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPdXRwdXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGlucHV0LCBvdXRwdXQsIGRpbWVuc2lvbikge1xuICAgICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgZGltZW5zaW9uID0gZGltZW5zaW9uICE9PSB1bmRlZmluZWQgPyBkaW1lbnNpb24gOiAyO1xuICAgICAgb3V0cHV0ID0gb3V0cHV0ICE9PSB1bmRlZmluZWQgPyBvdXRwdXQgOiBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGRpbWVuc2lvbikge1xuICAgICAgICBjb25zdCBwb2ludCA9IGNvb3JkVHJhbnNmb3JtKGlucHV0LnNsaWNlKGksIGkgKyBkaW1lbnNpb24pKTtcbiAgICAgICAgY29uc3QgcG9pbnRMZW5ndGggPSBwb2ludC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IGRpbWVuc2lvbjsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBvdXRwdXRbaSArIGpdID0gaiA+PSBwb2ludExlbmd0aCA/IGlucHV0W2kgKyBqXSA6IHBvaW50W2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgY29vcmRpbmF0ZSB0cmFuc2Zvcm0gZnVuY3Rpb25zIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgYmV0d2VlbiB0aGVcbiAqIHNvdXJjZSBwcm9qZWN0aW9uIGFuZCB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIFRoZSBmb3J3YXJkIGFuZCBpbnZlcnNlIGZ1bmN0aW9ucyBjb252ZXJ0IGNvb3JkaW5hdGUgcGFpcnM7IHRoaXMgZnVuY3Rpb25cbiAqIGNvbnZlcnRzIHRoZXNlIGludG8gdGhlIGZ1bmN0aW9ucyB1c2VkIGludGVybmFsbHkgd2hpY2ggYWxzbyBoYW5kbGVcbiAqIGV4dGVudHMgYW5kIGNvb3JkaW5hdGUgYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGZvcndhcmQgVGhlIGZvcndhcmQgdHJhbnNmb3JtXG4gKiAgICAgZnVuY3Rpb24gKHRoYXQgaXMsIGZyb20gdGhlIHNvdXJjZSBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvblxuICogICAgIHByb2plY3Rpb24pIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYXMgYXJndW1lbnQgYW5kIHJldHVybnNcbiAqICAgICB0aGUgdHJhbnNmb3JtZWQge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9LlxuICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBpbnZlcnNlIFRoZSBpbnZlcnNlIHRyYW5zZm9ybVxuICogICAgIGZ1bmN0aW9uICh0aGF0IGlzLCBmcm9tIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uIHRvIHRoZSBzb3VyY2VcbiAqICAgICBwcm9qZWN0aW9uKSB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGFzIGFyZ3VtZW50IGFuZCByZXR1cm5zXG4gKiAgICAgdGhlIHRyYW5zZm9ybWVkIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfS4gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiBjYW4gb25seVxuICogICAgIHRyYW5zZm9ybSBsZXNzIGRpbWVuc2lvbnMgdGhhbiB0aGUgaW5wdXQgY29vcmRpbmF0ZSwgaXQgaXMgc3VwcG9zZWVkIHRvIHJldHVybiBhIGNvb3JkaW5hdGVcbiAqICAgICB3aXRoIG9ubHkgdGhlIGxlbmd0aCBpdCBjYW4gdHJhbnNmb3JtLiBUaGUgb3RoZXIgZGltZW5zaW9ucyB3aWxsIGJlIHRha2VuIHVuY2hhbmdlZCBmcm9tIHRoZVxuICogICAgIHNvdXJjZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zKHNvdXJjZSwgZGVzdGluYXRpb24sIGZvcndhcmQsIGludmVyc2UpIHtcbiAgY29uc3Qgc291cmNlUHJvaiA9IGdldChzb3VyY2UpO1xuICBjb25zdCBkZXN0UHJvaiA9IGdldChkZXN0aW5hdGlvbik7XG4gIGFkZFRyYW5zZm9ybUZ1bmMoXG4gICAgc291cmNlUHJvaixcbiAgICBkZXN0UHJvaixcbiAgICBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShmb3J3YXJkKVxuICApO1xuICBhZGRUcmFuc2Zvcm1GdW5jKFxuICAgIGRlc3RQcm9qLFxuICAgIHNvdXJjZVByb2osXG4gICAgY3JlYXRlVHJhbnNmb3JtRnJvbUNvb3JkaW5hdGVUcmFuc2Zvcm0oaW52ZXJzZSlcbiAgKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgY29vcmRpbmF0ZSBmcm9tIGxvbmdpdHVkZS9sYXRpdHVkZSB0byBhIGRpZmZlcmVudCBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlIGFzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUsIGkuZS5cbiAqICAgICBhbiBhcnJheSB3aXRoIGxvbmdpdHVkZSBhcyAxc3QgYW5kIGxhdGl0dWRlIGFzIDJuZCBlbGVtZW50LlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dIFRhcmdldCBwcm9qZWN0aW9uLiBUaGVcbiAqICAgICBkZWZhdWx0IGlzIFdlYiBNZXJjYXRvciwgaS5lLiAnRVBTRzozODU3Jy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlIHByb2plY3RlZCB0byB0aGUgdGFyZ2V0IHByb2plY3Rpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTG9uTGF0KGNvb3JkaW5hdGUsIHByb2plY3Rpb24pIHtcbiAgZGlzYWJsZUNvb3JkaW5hdGVXYXJuaW5nKCk7XG4gIHJldHVybiB0cmFuc2Zvcm0oXG4gICAgY29vcmRpbmF0ZSxcbiAgICAnRVBTRzo0MzI2JyxcbiAgICBwcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgPyBwcm9qZWN0aW9uIDogJ0VQU0c6Mzg1NydcbiAgKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgY29vcmRpbmF0ZSB0byBsb25naXR1ZGUvbGF0aXR1ZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIFByb2plY3RlZCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24gb2YgdGhlIGNvb3JkaW5hdGUuXG4gKiAgICAgVGhlIGRlZmF1bHQgaXMgV2ViIE1lcmNhdG9yLCBpLmUuICdFUFNHOjM4NTcnLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUgYXMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSwgaS5lLiBhbiBhcnJheVxuICogICAgIHdpdGggbG9uZ2l0dWRlIGFzIDFzdCBhbmQgbGF0aXR1ZGUgYXMgMm5kIGVsZW1lbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0xvbkxhdChjb29yZGluYXRlLCBwcm9qZWN0aW9uKSB7XG4gIGNvbnN0IGxvbkxhdCA9IHRyYW5zZm9ybShcbiAgICBjb29yZGluYXRlLFxuICAgIHByb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/IHByb2plY3Rpb24gOiAnRVBTRzozODU3JyxcbiAgICAnRVBTRzo0MzI2J1xuICApO1xuICBjb25zdCBsb24gPSBsb25MYXRbMF07XG4gIGlmIChsb24gPCAtMTgwIHx8IGxvbiA+IDE4MCkge1xuICAgIGxvbkxhdFswXSA9IG1vZHVsbyhsb24gKyAxODAsIDM2MCkgLSAxODA7XG4gIH1cbiAgcmV0dXJuIGxvbkxhdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIHByb2plY3Rpb25zIGFyZSB0aGUgc2FtZSwgdGhhdCBpcyBldmVyeSBjb29yZGluYXRlIGluIG9uZVxuICogcHJvamVjdGlvbiBkb2VzIHJlcHJlc2VudCB0aGUgc2FtZSBnZW9ncmFwaGljIHBvaW50IGFzIHRoZSBzYW1lIGNvb3JkaW5hdGUgaW5cbiAqIHRoZSBvdGhlciBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gcHJvamVjdGlvbjEgUHJvamVjdGlvbiAxLlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBwcm9qZWN0aW9uMiBQcm9qZWN0aW9uIDIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBFcXVpdmFsZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1aXZhbGVudChwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIpIHtcbiAgaWYgKHByb2plY3Rpb24xID09PSBwcm9qZWN0aW9uMikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGVxdWFsVW5pdHMgPSBwcm9qZWN0aW9uMS5nZXRVbml0cygpID09PSBwcm9qZWN0aW9uMi5nZXRVbml0cygpO1xuICBpZiAocHJvamVjdGlvbjEuZ2V0Q29kZSgpID09PSBwcm9qZWN0aW9uMi5nZXRDb2RlKCkpIHtcbiAgICByZXR1cm4gZXF1YWxVbml0cztcbiAgfVxuICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHByb2plY3Rpb24xLCBwcm9qZWN0aW9uMik7XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jID09PSBjbG9uZVRyYW5zZm9ybSAmJiBlcXVhbFVuaXRzO1xufVxuXG4vKipcbiAqIFNlYXJjaGVzIGluIHRoZSBsaXN0IG9mIHRyYW5zZm9ybSBmdW5jdGlvbnMgZm9yIHRoZSBmdW5jdGlvbiBmb3IgY29udmVydGluZ1xuICogY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBzb3VyY2VQcm9qZWN0aW9uIFNvdXJjZSBQcm9qZWN0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gZGVzdGluYXRpb25Qcm9qZWN0aW9uIERlc3RpbmF0aW9uIFByb2plY3Rpb25cbiAqICAgICBvYmplY3QuXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1GdW5jdGlvbn0gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKFxuICBzb3VyY2VQcm9qZWN0aW9uLFxuICBkZXN0aW5hdGlvblByb2plY3Rpb25cbikge1xuICBjb25zdCBzb3VyY2VDb2RlID0gc291cmNlUHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uQ29kZSA9IGRlc3RpbmF0aW9uUHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gIGxldCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnVuYyhzb3VyY2VDb2RlLCBkZXN0aW5hdGlvbkNvZGUpO1xuICBpZiAoIXRyYW5zZm9ybUZ1bmMpIHtcbiAgICB0cmFuc2Zvcm1GdW5jID0gaWRlbnRpdHlUcmFuc2Zvcm07XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmM7XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIHByb2plY3Rpb24tbGlrZSBvYmplY3RzLCBzZWFyY2hlcyBmb3IgYSB0cmFuc2Zvcm1hdGlvblxuICogZnVuY3Rpb24gdG8gY29udmVydCBhIGNvb3JkaW5hdGVzIGFycmF5IGZyb20gdGhlIHNvdXJjZSBwcm9qZWN0aW9uIHRvIHRoZVxuICogZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1GdW5jdGlvbn0gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgY29uc3Qgc291cmNlUHJvamVjdGlvbiA9IGdldChzb3VyY2UpO1xuICBjb25zdCBkZXN0aW5hdGlvblByb2plY3Rpb24gPSBnZXQoZGVzdGluYXRpb24pO1xuICByZXR1cm4gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHNvdXJjZVByb2plY3Rpb24sIGRlc3RpbmF0aW9uUHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGNvb3JkaW5hdGUgZnJvbSBzb3VyY2UgcHJvamVjdGlvbiB0byBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogVGhpcyByZXR1cm5zIGEgbmV3IGNvb3JkaW5hdGUgKGFuZCBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsKS5cbiAqXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9wcm9qLnRyYW5zZm9ybUV4dGVudH0gZm9yIGV4dGVudCB0cmFuc2Zvcm1hdGlvbi5cbiAqIFNlZSB0aGUgdHJhbnNmb3JtIG1ldGhvZCBvZiB7QGxpbmsgbW9kdWxlOm9sL2dlb20vR2VvbWV0cnl+R2VvbWV0cnl9IGFuZCBpdHNcbiAqIHN1YmNsYXNzZXMgZm9yIGdlb21ldHJ5IHRyYW5zZm9ybXMuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlIFNvdXJjZSBwcm9qZWN0aW9uLWxpa2UuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLWxpa2UuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybShjb29yZGluYXRlLCBzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jKGNvb3JkaW5hdGUsIHVuZGVmaW5lZCwgY29vcmRpbmF0ZS5sZW5ndGgpO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gZXh0ZW50IGZyb20gc291cmNlIHByb2plY3Rpb24gdG8gZGVzdGluYXRpb24gcHJvamVjdGlvbi4gIFRoaXNcbiAqIHJldHVybnMgYSBuZXcgZXh0ZW50IChhbmQgZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50IHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wc10gTnVtYmVyIG9mIHN0b3BzIHBlciBzaWRlIHVzZWQgZm9yIHRoZSB0cmFuc2Zvcm0uXG4gKiBCeSBkZWZhdWx0IG9ubHkgdGhlIGNvcm5lcnMgYXJlIHVzZWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFRoZSB0cmFuc2Zvcm1lZCBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1FeHRlbnQoZXh0ZW50LCBzb3VyY2UsIGRlc3RpbmF0aW9uLCBzdG9wcykge1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZXR1cm4gYXBwbHlUcmFuc2Zvcm0oZXh0ZW50LCB0cmFuc2Zvcm1GdW5jLCB1bmRlZmluZWQsIHN0b3BzKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiBwb2ludCB0byB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludCBQb2ludC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gc291cmNlUHJvamVjdGlvbiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gZGVzdGluYXRpb25Qcm9qZWN0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gUG9pbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1XaXRoUHJvamVjdGlvbnMoXG4gIHBvaW50LFxuICBzb3VyY2VQcm9qZWN0aW9uLFxuICBkZXN0aW5hdGlvblByb2plY3Rpb25cbikge1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKFxuICAgIHNvdXJjZVByb2plY3Rpb24sXG4gICAgZGVzdGluYXRpb25Qcm9qZWN0aW9uXG4gICk7XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jKHBvaW50KTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7UHJvamVjdGlvbnxudWxsfVxuICovXG5sZXQgdXNlclByb2plY3Rpb24gPSBudWxsO1xuXG4vKipcbiAqIFNldCB0aGUgcHJvamVjdGlvbiBmb3IgY29vcmRpbmF0ZXMgc3VwcGxpZWQgZnJvbSBhbmQgcmV0dXJuZWQgYnkgQVBJIG1ldGhvZHMuXG4gKiBUaGlzIGluY2x1ZGVzIGFsbCBBUEkgbWV0aG9kcyBleGNlcHQgZm9yIHRob3NlIGludGVyYWN0aW5nIHdpdGggdGlsZSBncmlkcyxcbiAqIHBsdXMge0BsaW5rIGltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGFuZCB7QGxpbmsgaW1wb3J0KFwiLi9WaWV3LmpzXCIpLlN0YXRlfS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gVGhlIHVzZXIgcHJvamVjdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFVzZXJQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgdXNlclByb2plY3Rpb24gPSBnZXQocHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogQ2xlYXIgdGhlIHVzZXIgcHJvamVjdGlvbiBpZiBzZXQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclVzZXJQcm9qZWN0aW9uKCkge1xuICB1c2VyUHJvamVjdGlvbiA9IG51bGw7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9qZWN0aW9uIGZvciBjb29yZGluYXRlcyBzdXBwbGllZCBmcm9tIGFuZCByZXR1cm5lZCBieSBBUEkgbWV0aG9kcy5cbiAqIEByZXR1cm4ge1Byb2plY3Rpb258bnVsbH0gVGhlIHVzZXIgcHJvamVjdGlvbiAob3IgbnVsbCBpZiBub3Qgc2V0KS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJQcm9qZWN0aW9uKCkge1xuICByZXR1cm4gdXNlclByb2plY3Rpb247XG59XG5cbi8qKlxuICogVXNlIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMgKFdHUy04NCBkYXR1bSkgaW4gQVBJIG1ldGhvZHMuXG4gKiBUaGlzIGluY2x1ZGVzIGFsbCBBUEkgbWV0aG9kcyBleGNlcHQgZm9yIHRob3NlIGludGVyYWN0aW5nIHdpdGggdGlsZSBncmlkcyxcbiAqIHBsdXMge0BsaW5rIGltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGFuZCB7QGxpbmsgaW1wb3J0KFwiLi9WaWV3LmpzXCIpLlN0YXRlfS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUdlb2dyYXBoaWMoKSB7XG4gIHNldFVzZXJQcm9qZWN0aW9uKCdFUFNHOjQzMjYnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBjb29yZGluYXRlIHRyYW5zZm9ybWVkIGludG8gdGhlIHVzZXIgcHJvamVjdGlvbi4gIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCB0aGUgb3JpZ2luYWwgY29vcmRpbmF0ZSBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZSBJbnB1dCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlUHJvamVjdGlvbiBUaGUgaW5wdXQgY29vcmRpbmF0ZSBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIGlucHV0IGNvb3JkaW5hdGUgaW4gdGhlIHVzZXIgcHJvamVjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXNlckNvb3JkaW5hdGUoY29vcmRpbmF0ZSwgc291cmNlUHJvamVjdGlvbikge1xuICBpZiAoIXVzZXJQcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybShjb29yZGluYXRlLCBzb3VyY2VQcm9qZWN0aW9uLCB1c2VyUHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgY29vcmRpbmF0ZSB0cmFuc2Zvcm1lZCBmcm9tIHRoZSB1c2VyIHByb2plY3Rpb24uICBJZiBubyB1c2VyIHByb2plY3Rpb25cbiAqIGlzIHNldCwgdGhlIG9yaWdpbmFsIGNvb3JkaW5hdGUgaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGUgSW5wdXQgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IGRlc3RQcm9qZWN0aW9uIFRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIGlucHV0IGNvb3JkaW5hdGUgdHJhbnNmb3JtZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVXNlckNvb3JkaW5hdGUoY29vcmRpbmF0ZSwgZGVzdFByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIGlmIChcbiAgICAgIHNob3dDb29yZGluYXRlV2FybmluZyAmJlxuICAgICAgIWVxdWFscyhjb29yZGluYXRlLCBbMCwgMF0pICYmXG4gICAgICBjb29yZGluYXRlWzBdID49IC0xODAgJiZcbiAgICAgIGNvb3JkaW5hdGVbMF0gPD0gMTgwICYmXG4gICAgICBjb29yZGluYXRlWzFdID49IC05MCAmJlxuICAgICAgY29vcmRpbmF0ZVsxXSA8PSA5MFxuICAgICkge1xuICAgICAgc2hvd0Nvb3JkaW5hdGVXYXJuaW5nID0gZmFsc2U7XG4gICAgICB3YXJuKFxuICAgICAgICAnQ2FsbCB1c2VHZW9ncmFwaGljKCkgZnJvbSBvbC9wcm9qIG9uY2UgdG8gd29yayB3aXRoIFtsb25naXR1ZGUsIGxhdGl0dWRlXSBjb29yZGluYXRlcy4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtKGNvb3JkaW5hdGUsIHVzZXJQcm9qZWN0aW9uLCBkZXN0UHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGV4dGVudCB0cmFuc2Zvcm1lZCBpbnRvIHRoZSB1c2VyIHByb2plY3Rpb24uICBJZiBubyB1c2VyIHByb2plY3Rpb25cbiAqIGlzIHNldCwgdGhlIG9yaWdpbmFsIGV4dGVudCBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgSW5wdXQgZXh0ZW50LlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlUHJvamVjdGlvbiBUaGUgaW5wdXQgZXh0ZW50IHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFRoZSBpbnB1dCBleHRlbnQgaW4gdGhlIHVzZXIgcHJvamVjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXNlckV4dGVudChleHRlbnQsIHNvdXJjZVByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUV4dGVudChleHRlbnQsIHNvdXJjZVByb2plY3Rpb24sIHVzZXJQcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gZXh0ZW50IHRyYW5zZm9ybWVkIGZyb20gdGhlIHVzZXIgcHJvamVjdGlvbi4gIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCB0aGUgb3JpZ2luYWwgZXh0ZW50IGlzIHJldHVybmVkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBJbnB1dCBleHRlbnQuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0UHJvamVjdGlvbiBUaGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gVGhlIGlucHV0IGV4dGVudCB0cmFuc2Zvcm1lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Vc2VyRXh0ZW50KGV4dGVudCwgZGVzdFByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUV4dGVudChleHRlbnQsIHVzZXJQcm9qZWN0aW9uLCBkZXN0UHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSByZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCBvciBzb3VyY2Ugb3IgdXNlciBwcm9qZWN0aW9uIGFyZSBtaXNzaW5nIHVuaXRzLCB0aGUgb3JpZ2luYWwgcmVzb2x1dGlvblxuICogaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIGluIGlucHV0IHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlUHJvamVjdGlvbiBUaGUgaW5wdXQgcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbiBpbiB1c2VyIHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Vc2VyUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBzb3VyY2VQcm9qZWN0aW9uKSB7XG4gIGlmICghdXNlclByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgfVxuICBjb25zdCBzb3VyY2VNZXRlcnNQZXJVbml0ID0gZ2V0KHNvdXJjZVByb2plY3Rpb24pLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgY29uc3QgdXNlck1ldGVyc1BlclVuaXQgPSB1c2VyUHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIHJldHVybiBzb3VyY2VNZXRlcnNQZXJVbml0ICYmIHVzZXJNZXRlcnNQZXJVbml0XG4gICAgPyAocmVzb2x1dGlvbiAqIHNvdXJjZU1ldGVyc1BlclVuaXQpIC8gdXNlck1ldGVyc1BlclVuaXRcbiAgICA6IHJlc29sdXRpb247XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSByZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCBvciBzb3VyY2Ugb3IgdXNlciBwcm9qZWN0aW9uIGFyZSBtaXNzaW5nIHVuaXRzLCB0aGUgb3JpZ2luYWwgcmVzb2x1dGlvblxuICogaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0UHJvamVjdGlvbiBUaGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbiBpbiBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uIHVuaXRzIHBlciBwaXhlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Vc2VyUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBkZXN0UHJvamVjdGlvbikge1xuICBpZiAoIXVzZXJQcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlc29sdXRpb247XG4gIH1cbiAgY29uc3QgZGVzdE1ldGVyc1BlclVuaXQgPSBnZXQoZGVzdFByb2plY3Rpb24pLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgY29uc3QgdXNlck1ldGVyc1BlclVuaXQgPSB1c2VyUHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIHJldHVybiBkZXN0TWV0ZXJzUGVyVW5pdCAmJiB1c2VyTWV0ZXJzUGVyVW5pdFxuICAgID8gKHJlc29sdXRpb24gKiB1c2VyTWV0ZXJzUGVyVW5pdCkgLyBkZXN0TWV0ZXJzUGVyVW5pdFxuICAgIDogcmVzb2x1dGlvbjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2FmZSBjb29yZGluYXRlIHRyYW5zZm9ybSBmdW5jdGlvbiBmcm9tIGEgY29vcmRpbmF0ZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBcIlNhZmVcIiBtZWFucyB0aGF0IGl0IGNhbiBoYW5kbGUgd3JhcHBpbmcgb2YgeC1jb29yZGluYXRlcyBmb3IgZ2xvYmFsIHByb2plY3Rpb25zLFxuICogYW5kIHRoYXQgY29vcmRpbmF0ZXMgZXhjZWVkaW5nIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB2YWxpZGl0eSBleHRlbnQncyByYW5nZSB3aWxsIGJlXG4gKiBjbGFtcGVkIHRvIHRoZSB2YWxpZGl0eSByYW5nZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gZGVzdFByb2ogRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gdHJhbnNmb3JtIFRyYW5zZm9ybSBmdW5jdGlvbiAoc291cmNlIHRvIGRlc3RpbmF0aW9uKS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFNhZmUgdHJhbnNmb3JtIGZ1bmN0aW9uIChzb3VyY2UgdG8gZGVzdGluYXRpb24pLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2FmZUNvb3JkaW5hdGVUcmFuc2Zvcm0oc291cmNlUHJvaiwgZGVzdFByb2osIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgbGV0IHRyYW5zZm9ybWVkLCB3b3JsZHNBd2F5O1xuICAgIGlmIChzb3VyY2VQcm9qLmNhbldyYXBYKCkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZUV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gICAgICBjb25zdCBzb3VyY2VFeHRlbnRXaWR0aCA9IGdldFdpZHRoKHNvdXJjZUV4dGVudCk7XG4gICAgICBjb29yZCA9IGNvb3JkLnNsaWNlKDApO1xuICAgICAgd29ybGRzQXdheSA9IGdldFdvcmxkc0F3YXkoY29vcmQsIHNvdXJjZVByb2osIHNvdXJjZUV4dGVudFdpZHRoKTtcbiAgICAgIGlmICh3b3JsZHNBd2F5KSB7XG4gICAgICAgIC8vIE1vdmUgeCB0byB0aGUgcmVhbCB3b3JsZFxuICAgICAgICBjb29yZFswXSA9IGNvb3JkWzBdIC0gd29ybGRzQXdheSAqIHNvdXJjZUV4dGVudFdpZHRoO1xuICAgICAgfVxuICAgICAgY29vcmRbMF0gPSBjbGFtcChjb29yZFswXSwgc291cmNlRXh0ZW50WzBdLCBzb3VyY2VFeHRlbnRbMl0pO1xuICAgICAgY29vcmRbMV0gPSBjbGFtcChjb29yZFsxXSwgc291cmNlRXh0ZW50WzFdLCBzb3VyY2VFeHRlbnRbM10pO1xuICAgICAgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm0oY29vcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybShjb29yZCk7XG4gICAgfVxuICAgIGlmICh3b3JsZHNBd2F5ICYmIGRlc3RQcm9qLmNhbldyYXBYKCkpIHtcbiAgICAgIC8vIE1vdmUgdHJhbnNmb3JtZWQgY29vcmRpbmF0ZSBiYWNrIHRvIHRoZSBvZmZzZXQgd29ybGRcbiAgICAgIHRyYW5zZm9ybWVkWzBdICs9IHdvcmxkc0F3YXkgKiBnZXRXaWR0aChkZXN0UHJvai5nZXRFeHRlbnQoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBBZGQgdHJhbnNmb3JtcyB0byBhbmQgZnJvbSBFUFNHOjQzMjYgYW5kIEVQU0c6Mzg1Ny4gIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkXG4gKiBieSB3aGVuIHRoaXMgbW9kdWxlIGlzIGV4ZWN1dGVkIGFuZCBzaG91bGQgb25seSBuZWVkIHRvIGJlIGNhbGxlZCBhZ2FpbiBhZnRlclxuICogYGNsZWFyQWxsUHJvamVjdGlvbnMoKWAgaXMgY2FsbGVkIChlLmcuIGluIHRlc3RzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvbW1vbigpIHtcbiAgLy8gQWRkIHRyYW5zZm9ybWF0aW9ucyB0aGF0IGRvbid0IGFsdGVyIGNvb3JkaW5hdGVzIHRvIGNvbnZlcnQgd2l0aGluIHNldCBvZlxuICAvLyBwcm9qZWN0aW9ucyB3aXRoIGVxdWFsIG1lYW5pbmcuXG4gIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhFUFNHMzg1N19QUk9KRUNUSU9OUyk7XG4gIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhFUFNHNDMyNl9QUk9KRUNUSU9OUyk7XG4gIC8vIEFkZCB0cmFuc2Zvcm1hdGlvbnMgdG8gY29udmVydCBFUFNHOjQzMjYgbGlrZSBjb29yZGluYXRlcyB0byBFUFNHOjM4NTcgbGlrZVxuICAvLyBjb29yZGluYXRlcyBhbmQgYmFjay5cbiAgYWRkRXF1aXZhbGVudFRyYW5zZm9ybXMoXG4gICAgRVBTRzQzMjZfUFJPSkVDVElPTlMsXG4gICAgRVBTRzM4NTdfUFJPSkVDVElPTlMsXG4gICAgZnJvbUVQU0c0MzI2LFxuICAgIHRvRVBTRzQzMjZcbiAgKTtcbn1cblxuYWRkQ29tbW9uKCk7XG4iXSwibmFtZXMiOlsiUHJvamVjdGlvbiIsIlBST0pFQ1RJT05TIiwiRVBTRzM4NTdfUFJPSkVDVElPTlMiLCJmcm9tRVBTRzQzMjYiLCJ0b0VQU0c0MzI2IiwiRVBTRzQzMjZfUFJPSkVDVElPTlMiLCJNRVRFUlNfUEVSX1VOSVQiLCJhZGQiLCJhZGRQcm9qIiwiY2xlYXIiLCJjbGVhclByb2oiLCJnZXQiLCJnZXRQcm9qIiwiYWRkVHJhbnNmb3JtRnVuYyIsImNsZWFyVHJhbnNmb3JtRnVuY3MiLCJnZXRUcmFuc2Zvcm1GdW5jIiwiYXBwbHlUcmFuc2Zvcm0iLCJnZXRXaWR0aCIsImNsYW1wIiwibW9kdWxvIiwiZXF1YWxzIiwiZ2V0V29ybGRzQXdheSIsImdldERpc3RhbmNlIiwid2FybiIsInNob3dDb29yZGluYXRlV2FybmluZyIsImRpc2FibGVDb29yZGluYXRlV2FybmluZyIsImRpc2FibGUiLCJoaWRlIiwidW5kZWZpbmVkIiwiY2xvbmVUcmFuc2Zvcm0iLCJpbnB1dCIsIm91dHB1dCIsImkiLCJpaSIsImxlbmd0aCIsInNsaWNlIiwiaWRlbnRpdHlUcmFuc2Zvcm0iLCJhZGRQcm9qZWN0aW9uIiwicHJvamVjdGlvbiIsImdldENvZGUiLCJhZGRQcm9qZWN0aW9ucyIsInByb2plY3Rpb25zIiwiZm9yRWFjaCIsInByb2plY3Rpb25MaWtlIiwiZ2V0UG9pbnRSZXNvbHV0aW9uIiwicmVzb2x1dGlvbiIsInBvaW50IiwidW5pdHMiLCJwb2ludFJlc29sdXRpb24iLCJnZXR0ZXIiLCJnZXRQb2ludFJlc29sdXRpb25GdW5jIiwiZ2V0VW5pdHMiLCJtZXRlcnNQZXJVbml0IiwiZ2V0TWV0ZXJzUGVyVW5pdCIsInByb2pVbml0cyIsImdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyIsInZlcnRpY2VzIiwid2lkdGgiLCJoZWlnaHQiLCJhZGRFcXVpdmFsZW50UHJvamVjdGlvbnMiLCJzb3VyY2UiLCJkZXN0aW5hdGlvbiIsImFkZEVxdWl2YWxlbnRUcmFuc2Zvcm1zIiwicHJvamVjdGlvbnMxIiwicHJvamVjdGlvbnMyIiwiZm9yd2FyZFRyYW5zZm9ybSIsImludmVyc2VUcmFuc2Zvcm0iLCJwcm9qZWN0aW9uMSIsInByb2plY3Rpb24yIiwiY2xlYXJBbGxQcm9qZWN0aW9ucyIsImNyZWF0ZVByb2plY3Rpb24iLCJkZWZhdWx0Q29kZSIsImNyZWF0ZVRyYW5zZm9ybUZyb21Db29yZGluYXRlVHJhbnNmb3JtIiwiY29vcmRUcmFuc2Zvcm0iLCJkaW1lbnNpb24iLCJBcnJheSIsInBvaW50TGVuZ3RoIiwiaiIsImpqIiwiYWRkQ29vcmRpbmF0ZVRyYW5zZm9ybXMiLCJmb3J3YXJkIiwiaW52ZXJzZSIsInNvdXJjZVByb2oiLCJkZXN0UHJvaiIsImZyb21Mb25MYXQiLCJjb29yZGluYXRlIiwidHJhbnNmb3JtIiwidG9Mb25MYXQiLCJsb25MYXQiLCJsb24iLCJlcXVpdmFsZW50IiwiZXF1YWxVbml0cyIsInRyYW5zZm9ybUZ1bmMiLCJzb3VyY2VQcm9qZWN0aW9uIiwiZGVzdGluYXRpb25Qcm9qZWN0aW9uIiwic291cmNlQ29kZSIsImRlc3RpbmF0aW9uQ29kZSIsImdldFRyYW5zZm9ybSIsInRyYW5zZm9ybUV4dGVudCIsImV4dGVudCIsInN0b3BzIiwidHJhbnNmb3JtV2l0aFByb2plY3Rpb25zIiwidXNlclByb2plY3Rpb24iLCJzZXRVc2VyUHJvamVjdGlvbiIsImNsZWFyVXNlclByb2plY3Rpb24iLCJnZXRVc2VyUHJvamVjdGlvbiIsInVzZUdlb2dyYXBoaWMiLCJ0b1VzZXJDb29yZGluYXRlIiwiZnJvbVVzZXJDb29yZGluYXRlIiwiZGVzdFByb2plY3Rpb24iLCJ0b1VzZXJFeHRlbnQiLCJmcm9tVXNlckV4dGVudCIsInRvVXNlclJlc29sdXRpb24iLCJzb3VyY2VNZXRlcnNQZXJVbml0IiwidXNlck1ldGVyc1BlclVuaXQiLCJmcm9tVXNlclJlc29sdXRpb24iLCJkZXN0TWV0ZXJzUGVyVW5pdCIsImNyZWF0ZVNhZmVDb29yZGluYXRlVHJhbnNmb3JtIiwiY29vcmQiLCJ0cmFuc2Zvcm1lZCIsIndvcmxkc0F3YXkiLCJjYW5XcmFwWCIsInNvdXJjZUV4dGVudCIsImdldEV4dGVudCIsInNvdXJjZUV4dGVudFdpZHRoIiwiYWRkQ29tbW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/proj.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ol/proj/Projection.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/Projection.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Units.js */ \"(ssr)/./node_modules/ol/proj/Units.js\");\n/**\n * @module ol/proj/Projection\n */ \n/**\n * @typedef {Object} Options\n * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\n * @property {import(\"./Units.js\").Units} [units] Units. Required unless a\n * proj4 projection is defined for `code`.\n * @property {import(\"../extent.js\").Extent} [extent] The validity extent for the SRS.\n * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.\n * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\n * @property {number} [metersPerUnit] The meters per unit for the SRS.\n * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}\n * lookup table.\n * @property {import(\"../extent.js\").Extent} [worldExtent] The world extent for the SRS.\n * @property {function(number, import(\"../coordinate.js\").Coordinate):number} [getPointResolution]\n * Function to determine resolution at a point. The function is called with a\n * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns\n * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,\n * the default {@link module:ol/proj.getPointResolution} function will be used.\n */ /**\n * @classdesc\n * Projection definition class. One of these is created for each projection\n * supported in the application and stored in the {@link module:ol/proj} namespace.\n * You can use these in applications, but this is not required, as API params\n * and options use {@link module:ol/proj~ProjectionLike} which means the simple string\n * code will suffice.\n *\n * You can use {@link module:ol/proj.get} to retrieve the object for a particular\n * projection.\n *\n * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\n * with the following aliases:\n * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\n *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\n *     http://www.opengis.net/gml/srs/epsg.xml#4326,\n *     urn:x-ogc:def:crs:EPSG:4326\n * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\n *     urn:ogc:def:crs:EPSG:6.18:3:3857,\n *     http://www.opengis.net/gml/srs/epsg.xml#3857\n *\n * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can\n * be added using `proj4.defs()`. After all required projection definitions are\n * added, call the {@link module:ol/proj/proj4.register} function.\n *\n * @api\n */ class Projection {\n    /**\n   * @param {Options} options Projection options.\n   */ constructor(options){\n        /**\n     * @private\n     * @type {string}\n     */ this.code_ = options.code;\n        /**\n     * Units of projected coordinates. When set to `TILE_PIXELS`, a\n     * `this.extent_` and `this.worldExtent_` must be configured properly for each\n     * tile.\n     * @private\n     * @type {import(\"./Units.js\").Units}\n     */ this.units_ = /** @type {import(\"./Units.js\").Units} */ options.units;\n        /**\n     * Validity extent of the projection in projected coordinates. For projections\n     * with `TILE_PIXELS` units, this is the extent of the tile in\n     * tile pixel space.\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */ this.extent_ = options.extent !== undefined ? options.extent : null;\n        /**\n     * Extent of the world in EPSG:4326. For projections with\n     * `TILE_PIXELS` units, this is the extent of the tile in\n     * projected coordinate space.\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */ this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;\n        /**\n     * @private\n     * @type {string}\n     */ this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : \"enu\";\n        /**\n     * @private\n     * @type {boolean}\n     */ this.global_ = options.global !== undefined ? options.global : false;\n        /**\n     * @private\n     * @type {boolean}\n     */ this.canWrapX_ = !!(this.global_ && this.extent_);\n        /**\n     * @private\n     * @type {function(number, import(\"../coordinate.js\").Coordinate):number|undefined}\n     */ this.getPointResolutionFunc_ = options.getPointResolution;\n        /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */ this.defaultTileGrid_ = null;\n        /**\n     * @private\n     * @type {number|undefined}\n     */ this.metersPerUnit_ = options.metersPerUnit;\n    }\n    /**\n   * @return {boolean} The projection is suitable for wrapping the x-axis\n   */ canWrapX() {\n        return this.canWrapX_;\n    }\n    /**\n   * Get the code for this projection, e.g. 'EPSG:4326'.\n   * @return {string} Code.\n   * @api\n   */ getCode() {\n        return this.code_;\n    }\n    /**\n   * Get the validity extent for this projection.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */ getExtent() {\n        return this.extent_;\n    }\n    /**\n   * Get the units of this projection.\n   * @return {import(\"./Units.js\").Units} Units.\n   * @api\n   */ getUnits() {\n        return this.units_;\n    }\n    /**\n   * Get the amount of meters per unit of this projection.  If the projection is\n   * not configured with `metersPerUnit` or a units identifier, the return is\n   * `undefined`.\n   * @return {number|undefined} Meters.\n   * @api\n   */ getMetersPerUnit() {\n        return this.metersPerUnit_ || _Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[this.units_];\n    }\n    /**\n   * Get the world extent for this projection.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */ getWorldExtent() {\n        return this.worldExtent_;\n    }\n    /**\n   * Get the axis orientation of this projection.\n   * Example values are:\n   * enu - the default easting, northing, elevation.\n   * neu - northing, easting, up - useful for \"lat/long\" geographic coordinates,\n   *     or south orientated transverse mercator.\n   * wnu - westing, northing, up - some planetary coordinate systems have\n   *     \"west positive\" coordinate systems\n   * @return {string} Axis orientation.\n   * @api\n   */ getAxisOrientation() {\n        return this.axisOrientation_;\n    }\n    /**\n   * Is this projection a global projection which spans the whole world?\n   * @return {boolean} Whether the projection is global.\n   * @api\n   */ isGlobal() {\n        return this.global_;\n    }\n    /**\n   * Set if the projection is a global projection which spans the whole world\n   * @param {boolean} global Whether the projection is global.\n   * @api\n   */ setGlobal(global) {\n        this.global_ = global;\n        this.canWrapX_ = !!(global && this.extent_);\n    }\n    /**\n   * @return {import(\"../tilegrid/TileGrid.js\").default} The default tile grid.\n   */ getDefaultTileGrid() {\n        return this.defaultTileGrid_;\n    }\n    /**\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid The default tile grid.\n   */ setDefaultTileGrid(tileGrid) {\n        this.defaultTileGrid_ = tileGrid;\n    }\n    /**\n   * Set the validity extent for this projection.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */ setExtent(extent) {\n        this.extent_ = extent;\n        this.canWrapX_ = !!(this.global_ && extent);\n    }\n    /**\n   * Set the world extent for this projection.\n   * @param {import(\"../extent.js\").Extent} worldExtent World extent\n   *     [minlon, minlat, maxlon, maxlat].\n   * @api\n   */ setWorldExtent(worldExtent) {\n        this.worldExtent_ = worldExtent;\n    }\n    /**\n   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}\n   * for this projection.\n   * @param {function(number, import(\"../coordinate.js\").Coordinate):number} func Function\n   * @api\n   */ setGetPointResolution(func) {\n        this.getPointResolutionFunc_ = func;\n    }\n    /**\n   * Get the custom point resolution function for this projection (if set).\n   * @return {function(number, import(\"../coordinate.js\").Coordinate):number|undefined} The custom point\n   * resolution function (if set).\n   */ getPointResolutionFunc() {\n        return this.getPointResolutionFunc_;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Projection);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9Qcm9qZWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0NBRUMsR0FDMEM7QUFFM0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMEJDLEdBQ0QsTUFBTUM7SUFDSjs7R0FFQyxHQUNEQyxZQUFZQyxPQUFPLENBQUU7UUFDbkI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxLQUFLLEdBQUdELFFBQVFFLElBQUk7UUFFekI7Ozs7OztLQU1DLEdBQ0QsSUFBSSxDQUFDQyxNQUFNLEdBQUcsdUNBQXVDLEdBQUlILFFBQVFJLEtBQUs7UUFFdEU7Ozs7OztLQU1DLEdBQ0QsSUFBSSxDQUFDQyxPQUFPLEdBQUdMLFFBQVFNLE1BQU0sS0FBS0MsWUFBWVAsUUFBUU0sTUFBTSxHQUFHO1FBRS9EOzs7Ozs7S0FNQyxHQUNELElBQUksQ0FBQ0UsWUFBWSxHQUNmUixRQUFRUyxXQUFXLEtBQUtGLFlBQVlQLFFBQVFTLFdBQVcsR0FBRztRQUU1RDs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLGdCQUFnQixHQUNuQlYsUUFBUVcsZUFBZSxLQUFLSixZQUFZUCxRQUFRVyxlQUFlLEdBQUc7UUFFcEU7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxPQUFPLEdBQUdaLFFBQVFhLE1BQU0sS0FBS04sWUFBWVAsUUFBUWEsTUFBTSxHQUFHO1FBRS9EOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsU0FBUyxHQUFHLENBQUMsQ0FBRSxLQUFJLENBQUNGLE9BQU8sSUFBSSxJQUFJLENBQUNQLE9BQU87UUFFaEQ7OztLQUdDLEdBQ0QsSUFBSSxDQUFDVSx1QkFBdUIsR0FBR2YsUUFBUWdCLGtCQUFrQjtRQUV6RDs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBRXhCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsY0FBYyxHQUFHbEIsUUFBUW1CLGFBQWE7SUFDN0M7SUFFQTs7R0FFQyxHQUNEQyxXQUFXO1FBQ1QsT0FBTyxJQUFJLENBQUNOLFNBQVM7SUFDdkI7SUFFQTs7OztHQUlDLEdBQ0RPLFVBQVU7UUFDUixPQUFPLElBQUksQ0FBQ3BCLEtBQUs7SUFDbkI7SUFFQTs7OztHQUlDLEdBQ0RxQixZQUFZO1FBQ1YsT0FBTyxJQUFJLENBQUNqQixPQUFPO0lBQ3JCO0lBRUE7Ozs7R0FJQyxHQUNEa0IsV0FBVztRQUNULE9BQU8sSUFBSSxDQUFDcEIsTUFBTTtJQUNwQjtJQUVBOzs7Ozs7R0FNQyxHQUNEcUIsbUJBQW1CO1FBQ2pCLE9BQU8sSUFBSSxDQUFDTixjQUFjLElBQUlyQixzREFBZSxDQUFDLElBQUksQ0FBQ00sTUFBTSxDQUFDO0lBQzVEO0lBRUE7Ozs7R0FJQyxHQUNEc0IsaUJBQWlCO1FBQ2YsT0FBTyxJQUFJLENBQUNqQixZQUFZO0lBQzFCO0lBRUE7Ozs7Ozs7Ozs7R0FVQyxHQUNEa0IscUJBQXFCO1FBQ25CLE9BQU8sSUFBSSxDQUFDaEIsZ0JBQWdCO0lBQzlCO0lBRUE7Ozs7R0FJQyxHQUNEaUIsV0FBVztRQUNULE9BQU8sSUFBSSxDQUFDZixPQUFPO0lBQ3JCO0lBRUE7Ozs7R0FJQyxHQUNEZ0IsVUFBVWYsTUFBTSxFQUFFO1FBQ2hCLElBQUksQ0FBQ0QsT0FBTyxHQUFHQztRQUNmLElBQUksQ0FBQ0MsU0FBUyxHQUFHLENBQUMsQ0FBRUQsQ0FBQUEsVUFBVSxJQUFJLENBQUNSLE9BQU87SUFDNUM7SUFFQTs7R0FFQyxHQUNEd0IscUJBQXFCO1FBQ25CLE9BQU8sSUFBSSxDQUFDWixnQkFBZ0I7SUFDOUI7SUFFQTs7R0FFQyxHQUNEYSxtQkFBbUJDLFFBQVEsRUFBRTtRQUMzQixJQUFJLENBQUNkLGdCQUFnQixHQUFHYztJQUMxQjtJQUVBOzs7O0dBSUMsR0FDREMsVUFBVTFCLE1BQU0sRUFBRTtRQUNoQixJQUFJLENBQUNELE9BQU8sR0FBR0M7UUFDZixJQUFJLENBQUNRLFNBQVMsR0FBRyxDQUFDLENBQUUsS0FBSSxDQUFDRixPQUFPLElBQUlOLE1BQUs7SUFDM0M7SUFFQTs7Ozs7R0FLQyxHQUNEMkIsZUFBZXhCLFdBQVcsRUFBRTtRQUMxQixJQUFJLENBQUNELFlBQVksR0FBR0M7SUFDdEI7SUFFQTs7Ozs7R0FLQyxHQUNEeUIsc0JBQXNCQyxJQUFJLEVBQUU7UUFDMUIsSUFBSSxDQUFDcEIsdUJBQXVCLEdBQUdvQjtJQUNqQztJQUVBOzs7O0dBSUMsR0FDREMseUJBQXlCO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDckIsdUJBQXVCO0lBQ3JDO0FBQ0Y7QUFFQSxpRUFBZWpCLFVBQVVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXAvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9Qcm9qZWN0aW9uLmpzP2RiNmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovUHJvamVjdGlvblxuICovXG5pbXBvcnQge01FVEVSU19QRVJfVU5JVH0gZnJvbSAnLi9Vbml0cy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgVGhlIFNSUyBpZGVudGlmaWVyIGNvZGUsIGUuZy4gYEVQU0c6NDMyNmAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vVW5pdHMuanNcIikuVW5pdHN9IFt1bml0c10gVW5pdHMuIFJlcXVpcmVkIHVubGVzcyBhXG4gKiBwcm9qNCBwcm9qZWN0aW9uIGlzIGRlZmluZWQgZm9yIGBjb2RlYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhlIFNSUy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXhpc09yaWVudGF0aW9uPSdlbnUnXSBUaGUgYXhpcyBvcmllbnRhdGlvbiBhcyBzcGVjaWZpZWQgaW4gUHJvajQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtnbG9iYWw9ZmFsc2VdIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgdmFsaWQgZm9yIHRoZSB3aG9sZSBnbG9iZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWV0ZXJzUGVyVW5pdF0gVGhlIG1ldGVycyBwZXIgdW5pdCBmb3IgdGhlIFNSUy5cbiAqIElmIG5vdCBwcm92aWRlZCwgdGhlIGB1bml0c2AgYXJlIHVzZWQgdG8gZ2V0IHRoZSBtZXRlcnMgcGVyIHVuaXQgZnJvbSB0aGUge0BsaW5rIE1FVEVSU19QRVJfVU5JVH1cbiAqIGxvb2t1cCB0YWJsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW3dvcmxkRXh0ZW50XSBUaGUgd29ybGQgZXh0ZW50IGZvciB0aGUgU1JTLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihudW1iZXIsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6bnVtYmVyfSBbZ2V0UG9pbnRSZXNvbHV0aW9uXVxuICogRnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHJlc29sdXRpb24gYXQgYSBwb2ludC4gVGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAqIGBudW1iZXJgIHZpZXcgcmVzb2x1dGlvbiBhbmQgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYXMgYXJndW1lbnRzLCBhbmQgcmV0dXJuc1xuICogdGhlIGBudW1iZXJgIHJlc29sdXRpb24gaW4gcHJvamVjdGlvbiB1bml0cyBhdCB0aGUgcGFzc2VkIGNvb3JkaW5hdGUuIElmIHRoaXMgaXMgYHVuZGVmaW5lZGAsXG4gKiB0aGUgZGVmYXVsdCB7QGxpbmsgbW9kdWxlOm9sL3Byb2ouZ2V0UG9pbnRSZXNvbHV0aW9ufSBmdW5jdGlvbiB3aWxsIGJlIHVzZWQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcm9qZWN0aW9uIGRlZmluaXRpb24gY2xhc3MuIE9uZSBvZiB0aGVzZSBpcyBjcmVhdGVkIGZvciBlYWNoIHByb2plY3Rpb25cbiAqIHN1cHBvcnRlZCBpbiB0aGUgYXBwbGljYXRpb24gYW5kIHN0b3JlZCBpbiB0aGUge0BsaW5rIG1vZHVsZTpvbC9wcm9qfSBuYW1lc3BhY2UuXG4gKiBZb3UgY2FuIHVzZSB0aGVzZSBpbiBhcHBsaWNhdGlvbnMsIGJ1dCB0aGlzIGlzIG5vdCByZXF1aXJlZCwgYXMgQVBJIHBhcmFtc1xuICogYW5kIG9wdGlvbnMgdXNlIHtAbGluayBtb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gd2hpY2ggbWVhbnMgdGhlIHNpbXBsZSBzdHJpbmdcbiAqIGNvZGUgd2lsbCBzdWZmaWNlLlxuICpcbiAqIFlvdSBjYW4gdXNlIHtAbGluayBtb2R1bGU6b2wvcHJvai5nZXR9IHRvIHJldHJpZXZlIHRoZSBvYmplY3QgZm9yIGEgcGFydGljdWxhclxuICogcHJvamVjdGlvbi5cbiAqXG4gKiBUaGUgbGlicmFyeSBpbmNsdWRlcyBkZWZpbml0aW9ucyBmb3IgYEVQU0c6NDMyNmAgYW5kIGBFUFNHOjM4NTdgLCB0b2dldGhlclxuICogd2l0aCB0aGUgZm9sbG93aW5nIGFsaWFzZXM6XG4gKiAqIGBFUFNHOjQzMjZgOiBDUlM6ODQsIHVybjpvZ2M6ZGVmOmNyczpFUFNHOjYuNjo0MzI2LFxuICogICAgIHVybjpvZ2M6ZGVmOmNyczpPR0M6MS4zOkNSUzg0LCB1cm46b2djOmRlZjpjcnM6T0dDOjI6ODQsXG4gKiAgICAgaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzQzMjYsXG4gKiAgICAgdXJuOngtb2djOmRlZjpjcnM6RVBTRzo0MzI2XG4gKiAqIGBFUFNHOjM4NTdgOiBFUFNHOjEwMjEwMCwgRVBTRzoxMDIxMTMsIEVQU0c6OTAwOTEzLFxuICogICAgIHVybjpvZ2M6ZGVmOmNyczpFUFNHOjYuMTg6MzozODU3LFxuICogICAgIGh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sL3Nycy9lcHNnLnhtbCMzODU3XG4gKlxuICogSWYgeW91IHVzZSBbcHJvajRqc10oaHR0cHM6Ly9naXRodWIuY29tL3Byb2o0anMvcHJvajRqcyksIGFsaWFzZXMgY2FuXG4gKiBiZSBhZGRlZCB1c2luZyBgcHJvajQuZGVmcygpYC4gQWZ0ZXIgYWxsIHJlcXVpcmVkIHByb2plY3Rpb24gZGVmaW5pdGlvbnMgYXJlXG4gKiBhZGRlZCwgY2FsbCB0aGUge0BsaW5rIG1vZHVsZTpvbC9wcm9qL3Byb2o0LnJlZ2lzdGVyfSBmdW5jdGlvbi5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFByb2plY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIFByb2plY3Rpb24gb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jb2RlXyA9IG9wdGlvbnMuY29kZTtcblxuICAgIC8qKlxuICAgICAqIFVuaXRzIG9mIHByb2plY3RlZCBjb29yZGluYXRlcy4gV2hlbiBzZXQgdG8gYFRJTEVfUElYRUxTYCwgYVxuICAgICAqIGB0aGlzLmV4dGVudF9gIGFuZCBgdGhpcy53b3JsZEV4dGVudF9gIG11c3QgYmUgY29uZmlndXJlZCBwcm9wZXJseSBmb3IgZWFjaFxuICAgICAqIHRpbGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9Vbml0cy5qc1wiKS5Vbml0c31cbiAgICAgKi9cbiAgICB0aGlzLnVuaXRzXyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9Vbml0cy5qc1wiKS5Vbml0c30gKi8gKG9wdGlvbnMudW5pdHMpO1xuXG4gICAgLyoqXG4gICAgICogVmFsaWRpdHkgZXh0ZW50IG9mIHRoZSBwcm9qZWN0aW9uIGluIHByb2plY3RlZCBjb29yZGluYXRlcy4gRm9yIHByb2plY3Rpb25zXG4gICAgICogd2l0aCBgVElMRV9QSVhFTFNgIHVuaXRzLCB0aGlzIGlzIHRoZSBleHRlbnQgb2YgdGhlIHRpbGUgaW5cbiAgICAgKiB0aWxlIHBpeGVsIHNwYWNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnRfID0gb3B0aW9ucy5leHRlbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZXh0ZW50IDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEV4dGVudCBvZiB0aGUgd29ybGQgaW4gRVBTRzo0MzI2LiBGb3IgcHJvamVjdGlvbnMgd2l0aFxuICAgICAqIGBUSUxFX1BJWEVMU2AgdW5pdHMsIHRoaXMgaXMgdGhlIGV4dGVudCBvZiB0aGUgdGlsZSBpblxuICAgICAqIHByb2plY3RlZCBjb29yZGluYXRlIHNwYWNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy53b3JsZEV4dGVudF8gPVxuICAgICAgb3B0aW9ucy53b3JsZEV4dGVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53b3JsZEV4dGVudCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5heGlzT3JpZW50YXRpb25fID1cbiAgICAgIG9wdGlvbnMuYXhpc09yaWVudGF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmF4aXNPcmllbnRhdGlvbiA6ICdlbnUnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmdsb2JhbF8gPSBvcHRpb25zLmdsb2JhbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5nbG9iYWwgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jYW5XcmFwWF8gPSAhISh0aGlzLmdsb2JhbF8gJiYgdGhpcy5leHRlbnRfKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTpudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY18gPSBvcHRpb25zLmdldFBvaW50UmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0VGlsZUdyaWRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5tZXRlcnNQZXJVbml0XyA9IG9wdGlvbnMubWV0ZXJzUGVyVW5pdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgcHJvamVjdGlvbiBpcyBzdWl0YWJsZSBmb3Igd3JhcHBpbmcgdGhlIHgtYXhpc1xuICAgKi9cbiAgY2FuV3JhcFgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FuV3JhcFhfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29kZSBmb3IgdGhpcyBwcm9qZWN0aW9uLCBlLmcuICdFUFNHOjQzMjYnLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvZGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29kZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWxpZGl0eSBleHRlbnQgZm9yIHRoaXMgcHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFeHRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVuaXRzIG9mIHRoaXMgcHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9Vbml0cy5qc1wiKS5Vbml0c30gVW5pdHMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFVuaXRzKCkge1xuICAgIHJldHVybiB0aGlzLnVuaXRzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFtb3VudCBvZiBtZXRlcnMgcGVyIHVuaXQgb2YgdGhpcyBwcm9qZWN0aW9uLiAgSWYgdGhlIHByb2plY3Rpb24gaXNcbiAgICogbm90IGNvbmZpZ3VyZWQgd2l0aCBgbWV0ZXJzUGVyVW5pdGAgb3IgYSB1bml0cyBpZGVudGlmaWVyLCB0aGUgcmV0dXJuIGlzXG4gICAqIGB1bmRlZmluZWRgLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBNZXRlcnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1ldGVyc1BlclVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0ZXJzUGVyVW5pdF8gfHwgTUVURVJTX1BFUl9VTklUW3RoaXMudW5pdHNfXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdvcmxkIGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFdvcmxkRXh0ZW50KCkge1xuICAgIHJldHVybiB0aGlzLndvcmxkRXh0ZW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGF4aXMgb3JpZW50YXRpb24gb2YgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBFeGFtcGxlIHZhbHVlcyBhcmU6XG4gICAqIGVudSAtIHRoZSBkZWZhdWx0IGVhc3RpbmcsIG5vcnRoaW5nLCBlbGV2YXRpb24uXG4gICAqIG5ldSAtIG5vcnRoaW5nLCBlYXN0aW5nLCB1cCAtIHVzZWZ1bCBmb3IgXCJsYXQvbG9uZ1wiIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMsXG4gICAqICAgICBvciBzb3V0aCBvcmllbnRhdGVkIHRyYW5zdmVyc2UgbWVyY2F0b3IuXG4gICAqIHdudSAtIHdlc3RpbmcsIG5vcnRoaW5nLCB1cCAtIHNvbWUgcGxhbmV0YXJ5IGNvb3JkaW5hdGUgc3lzdGVtcyBoYXZlXG4gICAqICAgICBcIndlc3QgcG9zaXRpdmVcIiBjb29yZGluYXRlIHN5c3RlbXNcbiAgICogQHJldHVybiB7c3RyaW5nfSBBeGlzIG9yaWVudGF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBeGlzT3JpZW50YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhpc09yaWVudGF0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGlzIHByb2plY3Rpb24gYSBnbG9iYWwgcHJvamVjdGlvbiB3aGljaCBzcGFucyB0aGUgd2hvbGUgd29ybGQ/XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgZ2xvYmFsLlxuICAgKiBAYXBpXG4gICAqL1xuICBpc0dsb2JhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nbG9iYWxfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBpZiB0aGUgcHJvamVjdGlvbiBpcyBhIGdsb2JhbCBwcm9qZWN0aW9uIHdoaWNoIHNwYW5zIHRoZSB3aG9sZSB3b3JsZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGdsb2JhbCBXaGV0aGVyIHRoZSBwcm9qZWN0aW9uIGlzIGdsb2JhbC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0R2xvYmFsKGdsb2JhbCkge1xuICAgIHRoaXMuZ2xvYmFsXyA9IGdsb2JhbDtcbiAgICB0aGlzLmNhbldyYXBYXyA9ICEhKGdsb2JhbCAmJiB0aGlzLmV4dGVudF8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFRoZSBkZWZhdWx0IHRpbGUgZ3JpZC5cbiAgICovXG4gIGdldERlZmF1bHRUaWxlR3JpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0VGlsZUdyaWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGhlIGRlZmF1bHQgdGlsZSBncmlkLlxuICAgKi9cbiAgc2V0RGVmYXVsdFRpbGVHcmlkKHRpbGVHcmlkKSB7XG4gICAgdGhpcy5kZWZhdWx0VGlsZUdyaWRfID0gdGlsZUdyaWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB2YWxpZGl0eSBleHRlbnQgZm9yIHRoaXMgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRFeHRlbnQoZXh0ZW50KSB7XG4gICAgdGhpcy5leHRlbnRfID0gZXh0ZW50O1xuICAgIHRoaXMuY2FuV3JhcFhfID0gISEodGhpcy5nbG9iYWxfICYmIGV4dGVudCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB3b3JsZCBleHRlbnQgZm9yIHRoaXMgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSB3b3JsZEV4dGVudCBXb3JsZCBleHRlbnRcbiAgICogICAgIFttaW5sb24sIG1pbmxhdCwgbWF4bG9uLCBtYXhsYXRdLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRXb3JsZEV4dGVudCh3b3JsZEV4dGVudCkge1xuICAgIHRoaXMud29ybGRFeHRlbnRfID0gd29ybGRFeHRlbnQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBnZXRQb2ludFJlc29sdXRpb24gZnVuY3Rpb24gKHNlZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ouZ2V0UG9pbnRSZXNvbHV0aW9ufVxuICAgKiBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTpudW1iZXJ9IGZ1bmMgRnVuY3Rpb25cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0R2V0UG9pbnRSZXNvbHV0aW9uKGZ1bmMpIHtcbiAgICB0aGlzLmdldFBvaW50UmVzb2x1dGlvbkZ1bmNfID0gZnVuYztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1c3RvbSBwb2ludCByZXNvbHV0aW9uIGZ1bmN0aW9uIGZvciB0aGlzIHByb2plY3Rpb24gKGlmIHNldCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTpudW1iZXJ8dW5kZWZpbmVkfSBUaGUgY3VzdG9tIHBvaW50XG4gICAqIHJlc29sdXRpb24gZnVuY3Rpb24gKGlmIHNldCkuXG4gICAqL1xuICBnZXRQb2ludFJlc29sdXRpb25GdW5jKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UmVzb2x1dGlvbkZ1bmNfO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb2plY3Rpb247XG4iXSwibmFtZXMiOlsiTUVURVJTX1BFUl9VTklUIiwiUHJvamVjdGlvbiIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNvZGVfIiwiY29kZSIsInVuaXRzXyIsInVuaXRzIiwiZXh0ZW50XyIsImV4dGVudCIsInVuZGVmaW5lZCIsIndvcmxkRXh0ZW50XyIsIndvcmxkRXh0ZW50IiwiYXhpc09yaWVudGF0aW9uXyIsImF4aXNPcmllbnRhdGlvbiIsImdsb2JhbF8iLCJnbG9iYWwiLCJjYW5XcmFwWF8iLCJnZXRQb2ludFJlc29sdXRpb25GdW5jXyIsImdldFBvaW50UmVzb2x1dGlvbiIsImRlZmF1bHRUaWxlR3JpZF8iLCJtZXRlcnNQZXJVbml0XyIsIm1ldGVyc1BlclVuaXQiLCJjYW5XcmFwWCIsImdldENvZGUiLCJnZXRFeHRlbnQiLCJnZXRVbml0cyIsImdldE1ldGVyc1BlclVuaXQiLCJnZXRXb3JsZEV4dGVudCIsImdldEF4aXNPcmllbnRhdGlvbiIsImlzR2xvYmFsIiwic2V0R2xvYmFsIiwiZ2V0RGVmYXVsdFRpbGVHcmlkIiwic2V0RGVmYXVsdFRpbGVHcmlkIiwidGlsZUdyaWQiLCJzZXRFeHRlbnQiLCJzZXRXb3JsZEV4dGVudCIsInNldEdldFBvaW50UmVzb2x1dGlvbiIsImZ1bmMiLCJnZXRQb2ludFJlc29sdXRpb25GdW5jIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/proj/Projection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ol/proj/Units.js":
/*!***************************************!*\
  !*** ./node_modules/ol/proj/Units.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   METERS_PER_UNIT: () => (/* binding */ METERS_PER_UNIT),\n/* harmony export */   fromCode: () => (/* binding */ fromCode)\n/* harmony export */ });\n/**\n * @module ol/proj/Units\n */ /**\n * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units\n * Projection units.\n */ /**\n * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt\n * @type {Object<number, Units>}\n */ const unitByCode = {\n    \"9001\": \"m\",\n    \"9002\": \"ft\",\n    \"9003\": \"us-ft\",\n    \"9101\": \"radians\",\n    \"9102\": \"degrees\"\n};\n/**\n * @param {number} code Unit code.\n * @return {Units} Units.\n */ function fromCode(code) {\n    return unitByCode[code];\n}\n/**\n * @typedef {Object} MetersPerUnitLookup\n * @property {number} radians Radians\n * @property {number} degrees Degrees\n * @property {number} ft  Feet\n * @property {number} m Meters\n * @property {number} us-ft US feet\n */ /**\n * Meters per unit lookup table.\n * @const\n * @type {MetersPerUnitLookup}\n * @api\n */ const METERS_PER_UNIT = {\n    // use the radius of the Normal sphere\n    \"radians\": 6370997 / (2 * Math.PI),\n    \"degrees\": 2 * Math.PI * 6370997 / 360,\n    \"ft\": 0.3048,\n    \"m\": 1,\n    \"us-ft\": 1200 / 3937\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9Vbml0cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztDQUVDLEdBRUQ7OztDQUdDLEdBRUQ7OztDQUdDLEdBQ0QsTUFBTUEsYUFBYTtJQUNqQixRQUFRO0lBQ1IsUUFBUTtJQUNSLFFBQVE7SUFDUixRQUFRO0lBQ1IsUUFBUTtBQUNWO0FBRUE7OztDQUdDLEdBQ00sU0FBU0MsU0FBU0MsSUFBSTtJQUMzQixPQUFPRixVQUFVLENBQUNFLEtBQUs7QUFDekI7QUFFQTs7Ozs7OztDQU9DLEdBRUQ7Ozs7O0NBS0MsR0FDTSxNQUFNQyxrQkFBa0I7SUFDN0Isc0NBQXNDO0lBQ3RDLFdBQVcsVUFBVyxLQUFJQyxLQUFLQyxFQUFFO0lBQ2pDLFdBQVcsSUFBS0QsS0FBS0MsRUFBRSxHQUFHLFVBQVc7SUFDckMsTUFBTTtJQUNOLEtBQUs7SUFDTCxTQUFTLE9BQU87QUFDbEIsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL21hcC8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL1VuaXRzLmpzPzM3OTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovVW5pdHNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsncmFkaWFucycgfCAnZGVncmVlcycgfCAnZnQnIHwgJ20nIHwgJ3BpeGVscycgfCAndGlsZS1waXhlbHMnIHwgJ3VzLWZ0J30gVW5pdHNcbiAqIFByb2plY3Rpb24gdW5pdHMuXG4gKi9cblxuLyoqXG4gKiBTZWUgaHR0cDovL2R1ZmYuZXNzLndhc2hpbmd0b24uZWR1L2RhdGEvcmFzdGVyL2RyZy9kb2NzL2dlb3RpZmYudHh0XG4gKiBAdHlwZSB7T2JqZWN0PG51bWJlciwgVW5pdHM+fVxuICovXG5jb25zdCB1bml0QnlDb2RlID0ge1xuICAnOTAwMSc6ICdtJyxcbiAgJzkwMDInOiAnZnQnLFxuICAnOTAwMyc6ICd1cy1mdCcsXG4gICc5MTAxJzogJ3JhZGlhbnMnLFxuICAnOTEwMic6ICdkZWdyZWVzJyxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGUgVW5pdCBjb2RlLlxuICogQHJldHVybiB7VW5pdHN9IFVuaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUNvZGUoY29kZSkge1xuICByZXR1cm4gdW5pdEJ5Q29kZVtjb2RlXTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRlcnNQZXJVbml0TG9va3VwXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmFkaWFucyBSYWRpYW5zXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVncmVlcyBEZWdyZWVzXG4gKiBAcHJvcGVydHkge251bWJlcn0gZnQgIEZlZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtIE1ldGVyc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHVzLWZ0IFVTIGZlZXRcbiAqL1xuXG4vKipcbiAqIE1ldGVycyBwZXIgdW5pdCBsb29rdXAgdGFibGUuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtNZXRlcnNQZXJVbml0TG9va3VwfVxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgTUVURVJTX1BFUl9VTklUID0ge1xuICAvLyB1c2UgdGhlIHJhZGl1cyBvZiB0aGUgTm9ybWFsIHNwaGVyZVxuICAncmFkaWFucyc6IDYzNzA5OTcgLyAoMiAqIE1hdGguUEkpLFxuICAnZGVncmVlcyc6ICgyICogTWF0aC5QSSAqIDYzNzA5OTcpIC8gMzYwLFxuICAnZnQnOiAwLjMwNDgsXG4gICdtJzogMSxcbiAgJ3VzLWZ0JzogMTIwMCAvIDM5MzcsXG59O1xuIl0sIm5hbWVzIjpbInVuaXRCeUNvZGUiLCJmcm9tQ29kZSIsImNvZGUiLCJNRVRFUlNfUEVSX1VOSVQiLCJNYXRoIiwiUEkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/proj/Units.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ol/proj/epsg3857.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg3857.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXTENT: () => (/* binding */ EXTENT),\n/* harmony export */   HALF_SIZE: () => (/* binding */ HALF_SIZE),\n/* harmony export */   MAX_SAFE_Y: () => (/* binding */ MAX_SAFE_Y),\n/* harmony export */   PROJECTIONS: () => (/* binding */ PROJECTIONS),\n/* harmony export */   RADIUS: () => (/* binding */ RADIUS),\n/* harmony export */   WORLD_EXTENT: () => (/* binding */ WORLD_EXTENT),\n/* harmony export */   fromEPSG4326: () => (/* binding */ fromEPSG4326),\n/* harmony export */   toEPSG4326: () => (/* binding */ toEPSG4326)\n/* harmony export */ });\n/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Projection.js */ \"(ssr)/./node_modules/ol/proj/Projection.js\");\n/**\n * @module ol/proj/epsg3857\n */ \n/**\n * Radius of WGS84 sphere\n *\n * @const\n * @type {number}\n */ const RADIUS = 6378137;\n/**\n * @const\n * @type {number}\n */ const HALF_SIZE = Math.PI * RADIUS;\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */ const EXTENT = [\n    -HALF_SIZE,\n    -HALF_SIZE,\n    HALF_SIZE,\n    HALF_SIZE\n];\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */ const WORLD_EXTENT = [\n    -180,\n    -85,\n    180,\n    85\n];\n/**\n * Maximum safe value in y direction\n * @const\n * @type {number}\n */ const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));\n/**\n * @classdesc\n * Projection object for web/spherical Mercator (EPSG:3857).\n */ class EPSG3857Projection extends _Projection_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\n   * @param {string} code Code.\n   */ constructor(code){\n        super({\n            code: code,\n            units: \"m\",\n            extent: EXTENT,\n            global: true,\n            worldExtent: WORLD_EXTENT,\n            getPointResolution: function(resolution, point) {\n                return resolution / Math.cosh(point[1] / RADIUS);\n            }\n        });\n    }\n}\n/**\n * Projections equal to EPSG:3857.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */ const PROJECTIONS = [\n    new EPSG3857Projection(\"EPSG:3857\"),\n    new EPSG3857Projection(\"EPSG:102100\"),\n    new EPSG3857Projection(\"EPSG:102113\"),\n    new EPSG3857Projection(\"EPSG:900913\"),\n    new EPSG3857Projection(\"http://www.opengis.net/def/crs/EPSG/0/3857\"),\n    new EPSG3857Projection(\"http://www.opengis.net/gml/srs/epsg.xml#3857\")\n];\n/**\n * Transformation from EPSG:4326 to EPSG:3857.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */ function fromEPSG4326(input, output, dimension) {\n    const length = input.length;\n    dimension = dimension > 1 ? dimension : 2;\n    if (output === undefined) {\n        if (dimension > 2) {\n            // preserve values beyond second dimension\n            output = input.slice();\n        } else {\n            output = new Array(length);\n        }\n    }\n    for(let i = 0; i < length; i += dimension){\n        output[i] = HALF_SIZE * input[i] / 180;\n        let y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));\n        if (y > MAX_SAFE_Y) {\n            y = MAX_SAFE_Y;\n        } else if (y < -MAX_SAFE_Y) {\n            y = -MAX_SAFE_Y;\n        }\n        output[i + 1] = y;\n    }\n    return output;\n}\n/**\n * Transformation from EPSG:3857 to EPSG:4326.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */ function toEPSG4326(input, output, dimension) {\n    const length = input.length;\n    dimension = dimension > 1 ? dimension : 2;\n    if (output === undefined) {\n        if (dimension > 2) {\n            // preserve values beyond second dimension\n            output = input.slice();\n        } else {\n            output = new Array(length);\n        }\n    }\n    for(let i = 0; i < length; i += dimension){\n        output[i] = 180 * input[i] / HALF_SIZE;\n        output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;\n    }\n    return output;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9lcHNnMzg1Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUN3QztBQUV6Qzs7Ozs7Q0FLQyxHQUNNLE1BQU1DLFNBQVMsUUFBUTtBQUU5Qjs7O0NBR0MsR0FDTSxNQUFNQyxZQUFZQyxLQUFLQyxFQUFFLEdBQUdILE9BQU87QUFFMUM7OztDQUdDLEdBQ00sTUFBTUksU0FBUztJQUFDLENBQUNIO0lBQVcsQ0FBQ0E7SUFBV0E7SUFBV0E7Q0FBVSxDQUFDO0FBRXJFOzs7Q0FHQyxHQUNNLE1BQU1JLGVBQWU7SUFBQyxDQUFDO0lBQUssQ0FBQztJQUFJO0lBQUs7Q0FBRyxDQUFDO0FBRWpEOzs7O0NBSUMsR0FDTSxNQUFNQyxhQUFhTixTQUFTRSxLQUFLSyxHQUFHLENBQUNMLEtBQUtNLEdBQUcsQ0FBQ04sS0FBS0MsRUFBRSxHQUFHLElBQUk7QUFFbkU7OztDQUdDLEdBQ0QsTUFBTU0sMkJBQTJCVixzREFBVUE7SUFDekM7O0dBRUMsR0FDRFcsWUFBWUMsSUFBSSxDQUFFO1FBQ2hCLEtBQUssQ0FBQztZQUNKQSxNQUFNQTtZQUNOQyxPQUFPO1lBQ1BDLFFBQVFUO1lBQ1JVLFFBQVE7WUFDUkMsYUFBYVY7WUFDYlcsb0JBQW9CLFNBQVVDLFVBQVUsRUFBRUMsS0FBSztnQkFDN0MsT0FBT0QsYUFBYWYsS0FBS2lCLElBQUksQ0FBQ0QsS0FBSyxDQUFDLEVBQUUsR0FBR2xCO1lBQzNDO1FBQ0Y7SUFDRjtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDTSxNQUFNb0IsY0FBYztJQUN6QixJQUFJWCxtQkFBbUI7SUFDdkIsSUFBSUEsbUJBQW1CO0lBQ3ZCLElBQUlBLG1CQUFtQjtJQUN2QixJQUFJQSxtQkFBbUI7SUFDdkIsSUFBSUEsbUJBQW1CO0lBQ3ZCLElBQUlBLG1CQUFtQjtDQUN4QixDQUFDO0FBRUY7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNZLGFBQWFDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxTQUFTO0lBQ25ELE1BQU1DLFNBQVNILE1BQU1HLE1BQU07SUFDM0JELFlBQVlBLFlBQVksSUFBSUEsWUFBWTtJQUN4QyxJQUFJRCxXQUFXRyxXQUFXO1FBQ3hCLElBQUlGLFlBQVksR0FBRztZQUNqQiwwQ0FBMEM7WUFDMUNELFNBQVNELE1BQU1LLEtBQUs7UUFDdEIsT0FBTztZQUNMSixTQUFTLElBQUlLLE1BQU1IO1FBQ3JCO0lBQ0Y7SUFDQSxJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSUosUUFBUUksS0FBS0wsVUFBVztRQUMxQ0QsTUFBTSxDQUFDTSxFQUFFLEdBQUcsWUFBYVAsS0FBSyxDQUFDTyxFQUFFLEdBQUk7UUFDckMsSUFBSUMsSUFBSTlCLFNBQVNFLEtBQUtLLEdBQUcsQ0FBQ0wsS0FBS00sR0FBRyxDQUFDLEtBQU1MLEVBQUUsR0FBSSxFQUFDbUIsS0FBSyxDQUFDTyxJQUFJLEVBQUUsR0FBRyxFQUFDLElBQU07UUFDdEUsSUFBSUMsSUFBSXhCLFlBQVk7WUFDbEJ3QixJQUFJeEI7UUFDTixPQUFPLElBQUl3QixJQUFJLENBQUN4QixZQUFZO1lBQzFCd0IsSUFBSSxDQUFDeEI7UUFDUDtRQUNBaUIsTUFBTSxDQUFDTSxJQUFJLEVBQUUsR0FBR0M7SUFDbEI7SUFDQSxPQUFPUDtBQUNUO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNRLFdBQVdULEtBQUssRUFBRUMsTUFBTSxFQUFFQyxTQUFTO0lBQ2pELE1BQU1DLFNBQVNILE1BQU1HLE1BQU07SUFDM0JELFlBQVlBLFlBQVksSUFBSUEsWUFBWTtJQUN4QyxJQUFJRCxXQUFXRyxXQUFXO1FBQ3hCLElBQUlGLFlBQVksR0FBRztZQUNqQiwwQ0FBMEM7WUFDMUNELFNBQVNELE1BQU1LLEtBQUs7UUFDdEIsT0FBTztZQUNMSixTQUFTLElBQUlLLE1BQU1IO1FBQ3JCO0lBQ0Y7SUFDQSxJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSUosUUFBUUksS0FBS0wsVUFBVztRQUMxQ0QsTUFBTSxDQUFDTSxFQUFFLEdBQUcsTUFBT1AsS0FBSyxDQUFDTyxFQUFFLEdBQUk1QjtRQUMvQnNCLE1BQU0sQ0FBQ00sSUFBSSxFQUFFLEdBQ1gsTUFBTzNCLEtBQUs4QixJQUFJLENBQUM5QixLQUFLK0IsR0FBRyxDQUFDWCxLQUFLLENBQUNPLElBQUksRUFBRSxHQUFHN0IsV0FBWUUsS0FBS0MsRUFBRSxHQUFHO0lBQ25FO0lBQ0EsT0FBT29CO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXAvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9lcHNnMzg1Ny5qcz9mMmVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL2Vwc2czODU3XG4gKi9cbmltcG9ydCBQcm9qZWN0aW9uIGZyb20gJy4vUHJvamVjdGlvbi5qcyc7XG5cbi8qKlxuICogUmFkaXVzIG9mIFdHUzg0IHNwaGVyZVxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFJBRElVUyA9IDYzNzgxMzc7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgSEFMRl9TSVpFID0gTWF0aC5QSSAqIFJBRElVUztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICovXG5leHBvcnQgY29uc3QgRVhURU5UID0gWy1IQUxGX1NJWkUsIC1IQUxGX1NJWkUsIEhBTEZfU0laRSwgSEFMRl9TSVpFXTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICovXG5leHBvcnQgY29uc3QgV09STERfRVhURU5UID0gWy0xODAsIC04NSwgMTgwLCA4NV07XG5cbi8qKlxuICogTWF4aW11bSBzYWZlIHZhbHVlIGluIHkgZGlyZWN0aW9uXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBNQVhfU0FGRV9ZID0gUkFESVVTICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDIpKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcm9qZWN0aW9uIG9iamVjdCBmb3Igd2ViL3NwaGVyaWNhbCBNZXJjYXRvciAoRVBTRzozODU3KS5cbiAqL1xuY2xhc3MgRVBTRzM4NTdQcm9qZWN0aW9uIGV4dGVuZHMgUHJvamVjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZSBDb2RlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29kZSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICB1bml0czogJ20nLFxuICAgICAgZXh0ZW50OiBFWFRFTlQsXG4gICAgICBnbG9iYWw6IHRydWUsXG4gICAgICB3b3JsZEV4dGVudDogV09STERfRVhURU5ULFxuICAgICAgZ2V0UG9pbnRSZXNvbHV0aW9uOiBmdW5jdGlvbiAocmVzb2x1dGlvbiwgcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gLyBNYXRoLmNvc2gocG9pbnRbMV0gLyBSQURJVVMpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFByb2plY3Rpb25zIGVxdWFsIHRvIEVQU0c6Mzg1Ny5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdD59XG4gKi9cbmV4cG9ydCBjb25zdCBQUk9KRUNUSU9OUyA9IFtcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzozODU3JyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ0VQU0c6MTAyMTAwJyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ0VQU0c6MTAyMTEzJyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ0VQU0c6OTAwOTEzJyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZGVmL2Nycy9FUFNHLzAvMzg1NycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjMzg1NycpLFxuXTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1hdGlvbiBmcm9tIEVQU0c6NDMyNiB0byBFUFNHOjM4NTcuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dCBJbnB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW291dHB1dF0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtkaW1lbnNpb25dIERpbWVuc2lvbiAoZGVmYXVsdCBpcyBgMmApLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUVQU0c0MzI2KGlucHV0LCBvdXRwdXQsIGRpbWVuc2lvbikge1xuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIGRpbWVuc2lvbiA9IGRpbWVuc2lvbiA+IDEgPyBkaW1lbnNpb24gOiAyO1xuICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGltZW5zaW9uID4gMikge1xuICAgICAgLy8gcHJlc2VydmUgdmFsdWVzIGJleW9uZCBzZWNvbmQgZGltZW5zaW9uXG4gICAgICBvdXRwdXQgPSBpbnB1dC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gZGltZW5zaW9uKSB7XG4gICAgb3V0cHV0W2ldID0gKEhBTEZfU0laRSAqIGlucHV0W2ldKSAvIDE4MDtcbiAgICBsZXQgeSA9IFJBRElVUyAqIE1hdGgubG9nKE1hdGgudGFuKChNYXRoLlBJICogKCtpbnB1dFtpICsgMV0gKyA5MCkpIC8gMzYwKSk7XG4gICAgaWYgKHkgPiBNQVhfU0FGRV9ZKSB7XG4gICAgICB5ID0gTUFYX1NBRkVfWTtcbiAgICB9IGVsc2UgaWYgKHkgPCAtTUFYX1NBRkVfWSkge1xuICAgICAgeSA9IC1NQVhfU0FGRV9ZO1xuICAgIH1cbiAgICBvdXRwdXRbaSArIDFdID0geTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIGZyb20gRVBTRzozODU3IHRvIEVQU0c6NDMyNi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3V0cHV0XSBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2RpbWVuc2lvbl0gRGltZW5zaW9uIChkZWZhdWx0IGlzIGAyYCkuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0VQU0c0MzI2KGlucHV0LCBvdXRwdXQsIGRpbWVuc2lvbikge1xuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIGRpbWVuc2lvbiA9IGRpbWVuc2lvbiA+IDEgPyBkaW1lbnNpb24gOiAyO1xuICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGltZW5zaW9uID4gMikge1xuICAgICAgLy8gcHJlc2VydmUgdmFsdWVzIGJleW9uZCBzZWNvbmQgZGltZW5zaW9uXG4gICAgICBvdXRwdXQgPSBpbnB1dC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gZGltZW5zaW9uKSB7XG4gICAgb3V0cHV0W2ldID0gKDE4MCAqIGlucHV0W2ldKSAvIEhBTEZfU0laRTtcbiAgICBvdXRwdXRbaSArIDFdID1cbiAgICAgICgzNjAgKiBNYXRoLmF0YW4oTWF0aC5leHAoaW5wdXRbaSArIDFdIC8gUkFESVVTKSkpIC8gTWF0aC5QSSAtIDkwO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG4iXSwibmFtZXMiOlsiUHJvamVjdGlvbiIsIlJBRElVUyIsIkhBTEZfU0laRSIsIk1hdGgiLCJQSSIsIkVYVEVOVCIsIldPUkxEX0VYVEVOVCIsIk1BWF9TQUZFX1kiLCJsb2ciLCJ0YW4iLCJFUFNHMzg1N1Byb2plY3Rpb24iLCJjb25zdHJ1Y3RvciIsImNvZGUiLCJ1bml0cyIsImV4dGVudCIsImdsb2JhbCIsIndvcmxkRXh0ZW50IiwiZ2V0UG9pbnRSZXNvbHV0aW9uIiwicmVzb2x1dGlvbiIsInBvaW50IiwiY29zaCIsIlBST0pFQ1RJT05TIiwiZnJvbUVQU0c0MzI2IiwiaW5wdXQiLCJvdXRwdXQiLCJkaW1lbnNpb24iLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJzbGljZSIsIkFycmF5IiwiaSIsInkiLCJ0b0VQU0c0MzI2IiwiYXRhbiIsImV4cCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/proj/epsg3857.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ol/proj/epsg4326.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg4326.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXTENT: () => (/* binding */ EXTENT),\n/* harmony export */   METERS_PER_UNIT: () => (/* binding */ METERS_PER_UNIT),\n/* harmony export */   PROJECTIONS: () => (/* binding */ PROJECTIONS),\n/* harmony export */   RADIUS: () => (/* binding */ RADIUS)\n/* harmony export */ });\n/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Projection.js */ \"(ssr)/./node_modules/ol/proj/Projection.js\");\n/**\n * @module ol/proj/epsg4326\n */ \n/**\n * Semi-major radius of the WGS84 ellipsoid.\n *\n * @const\n * @type {number}\n */ const RADIUS = 6378137;\n/**\n * Extent of the EPSG:4326 projection which is the whole world.\n *\n * @const\n * @type {import(\"../extent.js\").Extent}\n */ const EXTENT = [\n    -180,\n    -90,\n    180,\n    90\n];\n/**\n * @const\n * @type {number}\n */ const METERS_PER_UNIT = Math.PI * RADIUS / 180;\n/**\n * @classdesc\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\n *\n * Note that OpenLayers does not strictly comply with the EPSG definition.\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\n */ class EPSG4326Projection extends _Projection_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\n   * @param {string} code Code.\n   * @param {string} [axisOrientation] Axis orientation.\n   */ constructor(code, axisOrientation){\n        super({\n            code: code,\n            units: \"degrees\",\n            extent: EXTENT,\n            axisOrientation: axisOrientation,\n            global: true,\n            metersPerUnit: METERS_PER_UNIT,\n            worldExtent: EXTENT\n        });\n    }\n}\n/**\n * Projections equal to EPSG:4326.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */ const PROJECTIONS = [\n    new EPSG4326Projection(\"CRS:84\"),\n    new EPSG4326Projection(\"EPSG:4326\", \"neu\"),\n    new EPSG4326Projection(\"urn:ogc:def:crs:OGC:1.3:CRS84\"),\n    new EPSG4326Projection(\"urn:ogc:def:crs:OGC:2:84\"),\n    new EPSG4326Projection(\"http://www.opengis.net/def/crs/OGC/1.3/CRS84\"),\n    new EPSG4326Projection(\"http://www.opengis.net/gml/srs/epsg.xml#4326\", \"neu\"),\n    new EPSG4326Projection(\"http://www.opengis.net/def/crs/EPSG/0/4326\", \"neu\")\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9lcHNnNDMyNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOztDQUVDLEdBQ3dDO0FBRXpDOzs7OztDQUtDLEdBQ00sTUFBTUMsU0FBUyxRQUFRO0FBRTlCOzs7OztDQUtDLEdBQ00sTUFBTUMsU0FBUztJQUFDLENBQUM7SUFBSyxDQUFDO0lBQUk7SUFBSztDQUFHLENBQUM7QUFFM0M7OztDQUdDLEdBQ00sTUFBTUMsa0JBQWtCLEtBQU1FLEVBQUUsR0FBR0osU0FBVSxJQUFJO0FBRXhEOzs7Ozs7O0NBT0MsR0FDRCxNQUFNSywyQkFBMkJOLHNEQUFVQTtJQUN6Qzs7O0dBR0MsR0FDRE8sWUFBWUMsSUFBSSxFQUFFQyxlQUFlLENBQUU7UUFDakMsS0FBSyxDQUFDO1lBQ0pELE1BQU1BO1lBQ05FLE9BQU87WUFDUEMsUUFBUVQ7WUFDUk8saUJBQWlCQTtZQUNqQkcsUUFBUTtZQUNSQyxlQUFlVjtZQUNmVyxhQUFhWjtRQUNmO0lBQ0Y7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ00sTUFBTWEsY0FBYztJQUN6QixJQUFJVCxtQkFBbUI7SUFDdkIsSUFBSUEsbUJBQW1CLGFBQWE7SUFDcEMsSUFBSUEsbUJBQW1CO0lBQ3ZCLElBQUlBLG1CQUFtQjtJQUN2QixJQUFJQSxtQkFBbUI7SUFDdkIsSUFBSUEsbUJBQW1CLGdEQUFnRDtJQUN2RSxJQUFJQSxtQkFBbUIsOENBQThDO0NBQ3RFLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXAvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9lcHNnNDMyNi5qcz9hOGE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL2Vwc2c0MzI2XG4gKi9cbmltcG9ydCBQcm9qZWN0aW9uIGZyb20gJy4vUHJvamVjdGlvbi5qcyc7XG5cbi8qKlxuICogU2VtaS1tYWpvciByYWRpdXMgb2YgdGhlIFdHUzg0IGVsbGlwc29pZC5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBSQURJVVMgPSA2Mzc4MTM3O1xuXG4vKipcbiAqIEV4dGVudCBvZiB0aGUgRVBTRzo0MzI2IHByb2plY3Rpb24gd2hpY2ggaXMgdGhlIHdob2xlIHdvcmxkLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBFWFRFTlQgPSBbLTE4MCwgLTkwLCAxODAsIDkwXTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBNRVRFUlNfUEVSX1VOSVQgPSAoTWF0aC5QSSAqIFJBRElVUykgLyAxODA7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBvYmplY3QgZm9yIFdHUzg0IGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMgKEVQU0c6NDMyNikuXG4gKlxuICogTm90ZSB0aGF0IE9wZW5MYXllcnMgZG9lcyBub3Qgc3RyaWN0bHkgY29tcGx5IHdpdGggdGhlIEVQU0cgZGVmaW5pdGlvbi5cbiAqIFRoZSBFUFNHIHJlZ2lzdHJ5IGRlZmluZXMgNDMyNiBhcyBhIENSUyBmb3IgTGF0aXR1ZGUsTG9uZ2l0dWRlICh5LHgpLlxuICogT3BlbkxheWVycyB0cmVhdHMgRVBTRzo0MzI2IGFzIGEgcHNldWRvLXByb2plY3Rpb24sIHdpdGggeCx5IGNvb3JkaW5hdGVzLlxuICovXG5jbGFzcyBFUFNHNDMyNlByb2plY3Rpb24gZXh0ZW5kcyBQcm9qZWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIENvZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXhpc09yaWVudGF0aW9uXSBBeGlzIG9yaWVudGF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29kZSwgYXhpc09yaWVudGF0aW9uKSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29kZTogY29kZSxcbiAgICAgIHVuaXRzOiAnZGVncmVlcycsXG4gICAgICBleHRlbnQ6IEVYVEVOVCxcbiAgICAgIGF4aXNPcmllbnRhdGlvbjogYXhpc09yaWVudGF0aW9uLFxuICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgbWV0ZXJzUGVyVW5pdDogTUVURVJTX1BFUl9VTklULFxuICAgICAgd29ybGRFeHRlbnQ6IEVYVEVOVCxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFByb2plY3Rpb25zIGVxdWFsIHRvIEVQU0c6NDMyNi5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdD59XG4gKi9cbmV4cG9ydCBjb25zdCBQUk9KRUNUSU9OUyA9IFtcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignQ1JTOjg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ0VQU0c6NDMyNicsICduZXUnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOk9HQzoxLjM6Q1JTODQnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOk9HQzoyOjg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZGVmL2Nycy9PR0MvMS4zL0NSUzg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sL3Nycy9lcHNnLnhtbCM0MzI2JywgJ25ldScpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2RlZi9jcnMvRVBTRy8wLzQzMjYnLCAnbmV1JyksXG5dO1xuIl0sIm5hbWVzIjpbIlByb2plY3Rpb24iLCJSQURJVVMiLCJFWFRFTlQiLCJNRVRFUlNfUEVSX1VOSVQiLCJNYXRoIiwiUEkiLCJFUFNHNDMyNlByb2plY3Rpb24iLCJjb25zdHJ1Y3RvciIsImNvZGUiLCJheGlzT3JpZW50YXRpb24iLCJ1bml0cyIsImV4dGVudCIsImdsb2JhbCIsIm1ldGVyc1BlclVuaXQiLCJ3b3JsZEV4dGVudCIsIlBST0pFQ1RJT05TIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/proj/epsg4326.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ol/proj/projections.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/proj/projections.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   clear: () => (/* binding */ clear),\n/* harmony export */   get: () => (/* binding */ get)\n/* harmony export */ });\n/**\n * @module ol/proj/projections\n */ /**\n * @type {Object<string, import(\"./Projection.js\").default>}\n */ let cache = {};\n/**\n * Clear the projections cache.\n */ function clear() {\n    cache = {};\n}\n/**\n * Get a cached projection by code.\n * @param {string} code The code for the projection.\n * @return {import(\"./Projection.js\").default} The projection (if cached).\n */ function get(code) {\n    return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\\w+)$/, \"EPSG:$3\")] || null;\n}\n/**\n * Add a projection to the cache.\n * @param {string} code The projection code.\n * @param {import(\"./Projection.js\").default} projection The projection to cache.\n */ function add(code, projection) {\n    cache[code] = projection;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9wcm9qZWN0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Q0FFQyxHQUVEOztDQUVDLEdBQ0QsSUFBSUEsUUFBUSxDQUFDO0FBRWI7O0NBRUMsR0FDTSxTQUFTQztJQUNkRCxRQUFRLENBQUM7QUFDWDtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTRSxJQUFJQyxJQUFJO0lBQ3RCLE9BQ0VILEtBQUssQ0FBQ0csS0FBSyxJQUNYSCxLQUFLLENBQUNHLEtBQUtDLE9BQU8sQ0FBQywwQ0FBMEMsV0FBVyxJQUN4RTtBQUVKO0FBRUE7Ozs7Q0FJQyxHQUNNLFNBQVNDLElBQUlGLElBQUksRUFBRUcsVUFBVTtJQUNsQ04sS0FBSyxDQUFDRyxLQUFLLEdBQUdHO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFwLy4vbm9kZV9tb2R1bGVzL29sL3Byb2ovcHJvamVjdGlvbnMuanM/NGM0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9wcm9qZWN0aW9uc1xuICovXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIGltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0Pn1cbiAqL1xubGV0IGNhY2hlID0ge307XG5cbi8qKlxuICogQ2xlYXIgdGhlIHByb2plY3Rpb25zIGNhY2hlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoKSB7XG4gIGNhY2hlID0ge307XG59XG5cbi8qKlxuICogR2V0IGEgY2FjaGVkIHByb2plY3Rpb24gYnkgY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIFRoZSBjb2RlIGZvciB0aGUgcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBUaGUgcHJvamVjdGlvbiAoaWYgY2FjaGVkKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgY2FjaGVbY29kZV0gfHxcbiAgICBjYWNoZVtjb2RlLnJlcGxhY2UoL3VybjooeC0pP29nYzpkZWY6Y3JzOkVQU0c6KC4qOik/KFxcdyspJC8sICdFUFNHOiQzJyldIHx8XG4gICAgbnVsbFxuICApO1xufVxuXG4vKipcbiAqIEFkZCBhIHByb2plY3Rpb24gdG8gdGhlIGNhY2hlLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgVGhlIHByb2plY3Rpb24gY29kZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gVGhlIHByb2plY3Rpb24gdG8gY2FjaGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQoY29kZSwgcHJvamVjdGlvbikge1xuICBjYWNoZVtjb2RlXSA9IHByb2plY3Rpb247XG59XG4iXSwibmFtZXMiOlsiY2FjaGUiLCJjbGVhciIsImdldCIsImNvZGUiLCJyZXBsYWNlIiwiYWRkIiwicHJvamVjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/proj/projections.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ol/proj/transforms.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/transforms.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   clear: () => (/* binding */ clear),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   remove: () => (/* binding */ remove)\n/* harmony export */ });\n/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ \"(ssr)/./node_modules/ol/obj.js\");\n/**\n * @module ol/proj/transforms\n */ \n/**\n * @private\n * @type {!Object<string, Object<string, import(\"../proj.js\").TransformFunction>>}\n */ let transforms = {};\n/**\n * Clear the transform cache.\n */ function clear() {\n    transforms = {};\n}\n/**\n * Registers a conversion function to convert coordinates from the source\n * projection to the destination projection.\n *\n * @param {import(\"./Projection.js\").default} source Source.\n * @param {import(\"./Projection.js\").default} destination Destination.\n * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n */ function add(source, destination, transformFn) {\n    const sourceCode = source.getCode();\n    const destinationCode = destination.getCode();\n    if (!(sourceCode in transforms)) {\n        transforms[sourceCode] = {};\n    }\n    transforms[sourceCode][destinationCode] = transformFn;\n}\n/**\n * Unregisters the conversion function to convert coordinates from the source\n * projection to the destination projection.  This method is used to clean up\n * cached transforms during testing.\n *\n * @param {import(\"./Projection.js\").default} source Source projection.\n * @param {import(\"./Projection.js\").default} destination Destination projection.\n * @return {import(\"../proj.js\").TransformFunction} transformFn The unregistered transform.\n */ function remove(source, destination) {\n    const sourceCode = source.getCode();\n    const destinationCode = destination.getCode();\n    const transform = transforms[sourceCode][destinationCode];\n    delete transforms[sourceCode][destinationCode];\n    if ((0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(transforms[sourceCode])) {\n        delete transforms[sourceCode];\n    }\n    return transform;\n}\n/**\n * Get a transform given a source code and a destination code.\n * @param {string} sourceCode The code for the source projection.\n * @param {string} destinationCode The code for the destination projection.\n * @return {import(\"../proj.js\").TransformFunction|undefined} The transform function (if found).\n */ function get(sourceCode, destinationCode) {\n    let transform;\n    if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n        transform = transforms[sourceCode][destinationCode];\n    }\n    return transform;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2wvcHJvai90cmFuc2Zvcm1zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FDaUM7QUFFbEM7OztDQUdDLEdBQ0QsSUFBSUMsYUFBYSxDQUFDO0FBRWxCOztDQUVDLEdBQ00sU0FBU0M7SUFDZEQsYUFBYSxDQUFDO0FBQ2hCO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNFLElBQUlDLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxXQUFXO0lBQ2xELE1BQU1DLGFBQWFILE9BQU9JLE9BQU87SUFDakMsTUFBTUMsa0JBQWtCSixZQUFZRyxPQUFPO0lBQzNDLElBQUksQ0FBRUQsQ0FBQUEsY0FBY04sVUFBUyxHQUFJO1FBQy9CQSxVQUFVLENBQUNNLFdBQVcsR0FBRyxDQUFDO0lBQzVCO0lBQ0FOLFVBQVUsQ0FBQ00sV0FBVyxDQUFDRSxnQkFBZ0IsR0FBR0g7QUFDNUM7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNNLFNBQVNJLE9BQU9OLE1BQU0sRUFBRUMsV0FBVztJQUN4QyxNQUFNRSxhQUFhSCxPQUFPSSxPQUFPO0lBQ2pDLE1BQU1DLGtCQUFrQkosWUFBWUcsT0FBTztJQUMzQyxNQUFNRyxZQUFZVixVQUFVLENBQUNNLFdBQVcsQ0FBQ0UsZ0JBQWdCO0lBQ3pELE9BQU9SLFVBQVUsQ0FBQ00sV0FBVyxDQUFDRSxnQkFBZ0I7SUFDOUMsSUFBSVQsZ0RBQU9BLENBQUNDLFVBQVUsQ0FBQ00sV0FBVyxHQUFHO1FBQ25DLE9BQU9OLFVBQVUsQ0FBQ00sV0FBVztJQUMvQjtJQUNBLE9BQU9JO0FBQ1Q7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVNDLElBQUlMLFVBQVUsRUFBRUUsZUFBZTtJQUM3QyxJQUFJRTtJQUNKLElBQUlKLGNBQWNOLGNBQWNRLG1CQUFtQlIsVUFBVSxDQUFDTSxXQUFXLEVBQUU7UUFDekVJLFlBQVlWLFVBQVUsQ0FBQ00sV0FBVyxDQUFDRSxnQkFBZ0I7SUFDckQ7SUFDQSxPQUFPRTtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFwLy4vbm9kZV9tb2R1bGVzL29sL3Byb2ovdHJhbnNmb3Jtcy5qcz82YWY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL3RyYW5zZm9ybXNcbiAqL1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi9vYmouanMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb24+Pn1cbiAqL1xubGV0IHRyYW5zZm9ybXMgPSB7fTtcblxuLyoqXG4gKiBDbGVhciB0aGUgdHJhbnNmb3JtIGNhY2hlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoKSB7XG4gIHRyYW5zZm9ybXMgPSB7fTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHNvdXJjZSBTb3VyY2UuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKHNvdXJjZSwgZGVzdGluYXRpb24sIHRyYW5zZm9ybUZuKSB7XG4gIGNvbnN0IHNvdXJjZUNvZGUgPSBzb3VyY2UuZ2V0Q29kZSgpO1xuICBjb25zdCBkZXN0aW5hdGlvbkNvZGUgPSBkZXN0aW5hdGlvbi5nZXRDb2RlKCk7XG4gIGlmICghKHNvdXJjZUNvZGUgaW4gdHJhbnNmb3JtcykpIHtcbiAgICB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdID0ge307XG4gIH1cbiAgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXVtkZXN0aW5hdGlvbkNvZGVdID0gdHJhbnNmb3JtRm47XG59XG5cbi8qKlxuICogVW5yZWdpc3RlcnMgdGhlIGNvbnZlcnNpb24gZnVuY3Rpb24gdG8gY29udmVydCBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uICBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGNsZWFuIHVwXG4gKiBjYWNoZWQgdHJhbnNmb3JtcyBkdXJpbmcgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2UgU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVGhlIHVucmVnaXN0ZXJlZCB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoc291cmNlLCBkZXN0aW5hdGlvbikge1xuICBjb25zdCBzb3VyY2VDb2RlID0gc291cmNlLmdldENvZGUoKTtcbiAgY29uc3QgZGVzdGluYXRpb25Db2RlID0gZGVzdGluYXRpb24uZ2V0Q29kZSgpO1xuICBjb25zdCB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV07XG4gIGRlbGV0ZSB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV07XG4gIGlmIChpc0VtcHR5KHRyYW5zZm9ybXNbc291cmNlQ29kZV0pKSB7XG4gICAgZGVsZXRlIHRyYW5zZm9ybXNbc291cmNlQ29kZV07XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuLyoqXG4gKiBHZXQgYSB0cmFuc2Zvcm0gZ2l2ZW4gYSBzb3VyY2UgY29kZSBhbmQgYSBkZXN0aW5hdGlvbiBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZUNvZGUgVGhlIGNvZGUgZm9yIHRoZSBzb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0aW5hdGlvbkNvZGUgVGhlIGNvZGUgZm9yIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbnx1bmRlZmluZWR9IFRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gKGlmIGZvdW5kKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChzb3VyY2VDb2RlLCBkZXN0aW5hdGlvbkNvZGUpIHtcbiAgbGV0IHRyYW5zZm9ybTtcbiAgaWYgKHNvdXJjZUNvZGUgaW4gdHJhbnNmb3JtcyAmJiBkZXN0aW5hdGlvbkNvZGUgaW4gdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXSkge1xuICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuIl0sIm5hbWVzIjpbImlzRW1wdHkiLCJ0cmFuc2Zvcm1zIiwiY2xlYXIiLCJhZGQiLCJzb3VyY2UiLCJkZXN0aW5hdGlvbiIsInRyYW5zZm9ybUZuIiwic291cmNlQ29kZSIsImdldENvZGUiLCJkZXN0aW5hdGlvbkNvZGUiLCJyZW1vdmUiLCJ0cmFuc2Zvcm0iLCJnZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/proj/transforms.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ol/sphere.js":
/*!***********************************!*\
  !*** ./node_modules/ol/sphere.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_RADIUS: () => (/* binding */ DEFAULT_RADIUS),\n/* harmony export */   getArea: () => (/* binding */ getArea),\n/* harmony export */   getDistance: () => (/* binding */ getDistance),\n/* harmony export */   getLength: () => (/* binding */ getLength),\n/* harmony export */   offset: () => (/* binding */ offset)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/ol/math.js\");\n/**\n * @module ol/sphere\n */ \n/**\n * Object literal with options for the {@link getLength} or {@link getArea}\n * functions.\n * @typedef {Object} SphereMetricOptions\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\n * Projection of the  geometry.  By default, the geometry is assumed to be in\n * Web Mercator.\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\n * for the WGS84 ellipsoid is used.\n */ /**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */ const DEFAULT_RADIUS = 6371008.8;\n/**\n * Get the great circle distance (in meters) between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {number} The great circle distance between the points (in meters).\n * @api\n */ function getDistance(c1, c2, radius) {\n    radius = radius || DEFAULT_RADIUS;\n    const lat1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[1]);\n    const lat2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c2[1]);\n    const deltaLatBy2 = (lat2 - lat1) / 2;\n    const deltaLonBy2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c2[0] - c1[0]) / 2;\n    const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);\n    return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */ function getLengthInternal(coordinates, radius) {\n    let length = 0;\n    for(let i = 0, ii = coordinates.length; i < ii - 1; ++i){\n        length += getDistance(coordinates[i], coordinates[i + 1], radius);\n    }\n    return length;\n}\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [options] Options for the\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n * You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */ function getLength(geometry, options) {\n    options = options || {};\n    const radius = options.radius || DEFAULT_RADIUS;\n    const projection = options.projection || \"EPSG:3857\";\n    const type = geometry.getType();\n    if (type !== \"GeometryCollection\") {\n        geometry = geometry.clone().transform(projection, \"EPSG:4326\");\n    }\n    let length = 0;\n    let coordinates, coords, i, ii, j, jj;\n    switch(type){\n        case \"Point\":\n        case \"MultiPoint\":\n            {\n                break;\n            }\n        case \"LineString\":\n        case \"LinearRing\":\n            {\n                coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ geometry.getCoordinates();\n                length = getLengthInternal(coordinates, radius);\n                break;\n            }\n        case \"MultiLineString\":\n        case \"Polygon\":\n            {\n                coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ geometry.getCoordinates();\n                for(i = 0, ii = coordinates.length; i < ii; ++i){\n                    length += getLengthInternal(coordinates[i], radius);\n                }\n                break;\n            }\n        case \"MultiPolygon\":\n            {\n                coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ geometry.getCoordinates();\n                for(i = 0, ii = coordinates.length; i < ii; ++i){\n                    coords = coordinates[i];\n                    for(j = 0, jj = coords.length; j < jj; ++j){\n                        length += getLengthInternal(coords[j], radius);\n                    }\n                }\n                break;\n            }\n        case \"GeometryCollection\":\n            {\n                const geometries = /** @type {import(\"./geom/GeometryCollection.js\").default} */ geometry.getGeometries();\n                for(i = 0, ii = geometries.length; i < ii; ++i){\n                    length += getLength(geometries[i], options);\n                }\n                break;\n            }\n        default:\n            {\n                throw new Error(\"Unsupported geometry type: \" + type);\n            }\n    }\n    return length;\n}\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */ function getAreaInternal(coordinates, radius) {\n    let area = 0;\n    const len = coordinates.length;\n    let x1 = coordinates[len - 1][0];\n    let y1 = coordinates[len - 1][1];\n    for(let i = 0; i < len; i++){\n        const x2 = coordinates[i][0];\n        const y2 = coordinates[i][1];\n        area += (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(x2 - x1) * (2 + Math.sin((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(y1)) + Math.sin((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(y2)));\n        x1 = x2;\n        y1 = y2;\n    }\n    return area * radius * radius / 2.0;\n}\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [options] Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */ function getArea(geometry, options) {\n    options = options || {};\n    const radius = options.radius || DEFAULT_RADIUS;\n    const projection = options.projection || \"EPSG:3857\";\n    const type = geometry.getType();\n    if (type !== \"GeometryCollection\") {\n        geometry = geometry.clone().transform(projection, \"EPSG:4326\");\n    }\n    let area = 0;\n    let coordinates, coords, i, ii, j, jj;\n    switch(type){\n        case \"Point\":\n        case \"MultiPoint\":\n        case \"LineString\":\n        case \"MultiLineString\":\n        case \"LinearRing\":\n            {\n                break;\n            }\n        case \"Polygon\":\n            {\n                coordinates = /** @type {import(\"./geom/Polygon.js\").default} */ geometry.getCoordinates();\n                area = Math.abs(getAreaInternal(coordinates[0], radius));\n                for(i = 1, ii = coordinates.length; i < ii; ++i){\n                    area -= Math.abs(getAreaInternal(coordinates[i], radius));\n                }\n                break;\n            }\n        case \"MultiPolygon\":\n            {\n                coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ geometry.getCoordinates();\n                for(i = 0, ii = coordinates.length; i < ii; ++i){\n                    coords = coordinates[i];\n                    area += Math.abs(getAreaInternal(coords[0], radius));\n                    for(j = 1, jj = coords.length; j < jj; ++j){\n                        area -= Math.abs(getAreaInternal(coords[j], radius));\n                    }\n                }\n                break;\n            }\n        case \"GeometryCollection\":\n            {\n                const geometries = /** @type {import(\"./geom/GeometryCollection.js\").default} */ geometry.getGeometries();\n                for(i = 0, ii = geometries.length; i < ii; ++i){\n                    area += getArea(geometries[i], options);\n                }\n                break;\n            }\n        default:\n            {\n                throw new Error(\"Unsupported geometry type: \" + type);\n            }\n    }\n    return area;\n}\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\n */ function offset(c1, distance, bearing, radius) {\n    radius = radius || DEFAULT_RADIUS;\n    const lat1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[1]);\n    const lon1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[0]);\n    const dByR = distance / radius;\n    const lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n    const lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n    return [\n        (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toDegrees)(lon),\n        (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toDegrees)(lat)\n    ];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFBQ25ELG1EQUFTQSxDQUFDcUQ7UUFBTXJELG1EQUFTQSxDQUFDbUQ7S0FBSztBQUN6QyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcC8uL25vZGVfbW9kdWxlcy9vbC9zcGhlcmUuanM/NTZlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvc3BoZXJlXG4gKi9cbmltcG9ydCB7dG9EZWdyZWVzLCB0b1JhZGlhbnN9IGZyb20gJy4vbWF0aC5qcyc7XG5cbi8qKlxuICogT2JqZWN0IGxpdGVyYWwgd2l0aCBvcHRpb25zIGZvciB0aGUge0BsaW5rIGdldExlbmd0aH0gb3Ige0BsaW5rIGdldEFyZWF9XG4gKiBmdW5jdGlvbnMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTcGhlcmVNZXRyaWNPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb249J0VQU0c6Mzg1NyddXG4gKiBQcm9qZWN0aW9uIG9mIHRoZSAgZ2VvbWV0cnkuICBCeSBkZWZhdWx0LCB0aGUgZ2VvbWV0cnkgaXMgYXNzdW1lZCB0byBiZSBpblxuICogV2ViIE1lcmNhdG9yLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRpdXM9NjM3MTAwOC44XSBTcGhlcmUgcmFkaXVzLiAgQnkgZGVmYXVsdCwgdGhlXG4gKiBbbWVhbiBFYXJ0aCByYWRpdXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VhcnRoX3JhZGl1cyNNZWFuX3JhZGl1cylcbiAqIGZvciB0aGUgV0dTODQgZWxsaXBzb2lkIGlzIHVzZWQuXG4gKi9cblxuLyoqXG4gKiBUaGUgbWVhbiBFYXJ0aCByYWRpdXMgKDEvMyAqICgyYSArIGIpKSBmb3IgdGhlIFdHUzg0IGVsbGlwc29pZC5cbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VhcnRoX3JhZGl1cyNNZWFuX3JhZGl1c1xuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkFESVVTID0gNjM3MTAwOC44O1xuXG4vKipcbiAqIEdldCB0aGUgZ3JlYXQgY2lyY2xlIGRpc3RhbmNlIChpbiBtZXRlcnMpIGJldHdlZW4gdHdvIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBjMSBTdGFydGluZyBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheX0gYzIgRW5kaW5nIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3JhZGl1c10gVGhlIHNwaGVyZSByYWRpdXMgdG8gdXNlLiAgRGVmYXVsdHMgdG8gdGhlIEVhcnRoJ3NcbiAqICAgICBtZWFuIHJhZGl1cyB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZ3JlYXQgY2lyY2xlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cyAoaW4gbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlKGMxLCBjMiwgcmFkaXVzKSB7XG4gIHJhZGl1cyA9IHJhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgY29uc3QgbGF0MSA9IHRvUmFkaWFucyhjMVsxXSk7XG4gIGNvbnN0IGxhdDIgPSB0b1JhZGlhbnMoYzJbMV0pO1xuICBjb25zdCBkZWx0YUxhdEJ5MiA9IChsYXQyIC0gbGF0MSkgLyAyO1xuICBjb25zdCBkZWx0YUxvbkJ5MiA9IHRvUmFkaWFucyhjMlswXSAtIGMxWzBdKSAvIDI7XG4gIGNvbnN0IGEgPVxuICAgIE1hdGguc2luKGRlbHRhTGF0QnkyKSAqIE1hdGguc2luKGRlbHRhTGF0QnkyKSArXG4gICAgTWF0aC5zaW4oZGVsdGFMb25CeTIpICpcbiAgICAgIE1hdGguc2luKGRlbHRhTG9uQnkyKSAqXG4gICAgICBNYXRoLmNvcyhsYXQxKSAqXG4gICAgICBNYXRoLmNvcyhsYXQyKTtcbiAgcmV0dXJuIDIgKiByYWRpdXMgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdW11bGF0aXZlIGdyZWF0IGNpcmNsZSBsZW5ndGggb2YgbGluZXN0cmluZyBjb29yZGluYXRlcyAoZ2VvZ3JhcGhpYykuXG4gKiBAcGFyYW0ge0FycmF5fSBjb29yZGluYXRlcyBMaW5lc3RyaW5nIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgc3BoZXJlIHJhZGl1cyB0byB1c2UuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsZW5ndGggKGluIG1ldGVycykuXG4gKi9cbmZ1bmN0aW9uIGdldExlbmd0aEludGVybmFsKGNvb3JkaW5hdGVzLCByYWRpdXMpIHtcbiAgbGV0IGxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpIC0gMTsgKytpKSB7XG4gICAgbGVuZ3RoICs9IGdldERpc3RhbmNlKGNvb3JkaW5hdGVzW2ldLCBjb29yZGluYXRlc1tpICsgMV0sIHJhZGl1cyk7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNwaGVyaWNhbCBsZW5ndGggb2YgYSBnZW9tZXRyeS4gIFRoaXMgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlXG4gKiBncmVhdCBjaXJjbGUgZGlzdGFuY2VzIGJldHdlZW4gY29vcmRpbmF0ZXMuICBGb3IgcG9seWdvbnMsIHRoZSBsZW5ndGggaXNcbiAqIHRoZSBzdW0gb2YgYWxsIHJpbmdzLiAgRm9yIHBvaW50cywgdGhlIGxlbmd0aCBpcyB6ZXJvLiAgRm9yIG11bHRpLXBhcnRcbiAqIGdlb21ldHJpZXMsIHRoZSBsZW5ndGggaXMgdGhlIHN1bSBvZiB0aGUgbGVuZ3RoIG9mIGVhY2ggcGFydC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEEgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge1NwaGVyZU1ldHJpY09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGVcbiAqIGxlbmd0aCBjYWxjdWxhdGlvbi4gIEJ5IGRlZmF1bHQsIGdlb21ldHJpZXMgYXJlIGFzc3VtZWQgdG8gYmUgaW4gJ0VQU0c6Mzg1NycuXG4gKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHByb3ZpZGluZyBhIGBwcm9qZWN0aW9uYCBvcHRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcGhlcmljYWwgbGVuZ3RoIChpbiBtZXRlcnMpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVuZ3RoKGdlb21ldHJ5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgY29uc3QgcHJvamVjdGlvbiA9IG9wdGlvbnMucHJvamVjdGlvbiB8fCAnRVBTRzozODU3JztcbiAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgaWYgKHR5cGUgIT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgZ2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpLnRyYW5zZm9ybShwcm9qZWN0aW9uLCAnRVBTRzo0MzI2Jyk7XG4gIH1cbiAgbGV0IGxlbmd0aCA9IDA7XG4gIGxldCBjb29yZGluYXRlcywgY29vcmRzLCBpLCBpaSwgaiwgamo7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BvaW50JzpcbiAgICBjYXNlICdNdWx0aVBvaW50Jzoge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ0xpbmVhclJpbmcnOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnlcbiAgICAgICkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGxlbmd0aCA9IGdldExlbmd0aEludGVybmFsKGNvb3JkaW5hdGVzLCByYWRpdXMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgY2FzZSAnUG9seWdvbic6IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBnZW9tZXRyeVxuICAgICAgKS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGxlbmd0aCArPSBnZXRMZW5ndGhJbnRlcm5hbChjb29yZGluYXRlc1tpXSwgcmFkaXVzKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnlcbiAgICAgICkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgZm9yIChqID0gMCwgamogPSBjb29yZHMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIGxlbmd0aCArPSBnZXRMZW5ndGhJbnRlcm5hbChjb29yZHNbal0sIHJhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOiB7XG4gICAgICBjb25zdCBnZW9tZXRyaWVzID1cbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICApLmdldEdlb21ldHJpZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGxlbmd0aCArPSBnZXRMZW5ndGgoZ2VvbWV0cmllc1tpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW5ndGg7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3BoZXJpY2FsIGFyZWEgZm9yIGEgbGlzdCBvZiBjb29yZGluYXRlcy5cbiAqXG4gKiBbUmVmZXJlbmNlXShodHRwczovL3Rycy5qcGwubmFzYS5nb3YvaGFuZGxlLzIwMTQvNDA0MDkpXG4gKiBSb2JlcnQuIEcuIENoYW1iZXJsYWluIGFuZCBXaWxsaWFtIEguIER1cXVldHRlLCBcIlNvbWUgQWxnb3JpdGhtcyBmb3JcbiAqIFBvbHlnb25zIG9uIGEgU3BoZXJlXCIsIEpQTCBQdWJsaWNhdGlvbiAwNy0wMywgSmV0IFByb3B1bHNpb25cbiAqIExhYm9yYXRvcnksIFBhc2FkZW5hLCBDQSwgSnVuZSAyMDA3XG4gKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIExpc3Qgb2YgY29vcmRpbmF0ZXMgb2YgYSBsaW5lYXJcbiAqIHJpbmcuIElmIHRoZSByaW5nIGlzIG9yaWVudGVkIGNsb2Nrd2lzZSwgdGhlIGFyZWEgd2lsbCBiZSBwb3NpdGl2ZSxcbiAqIG90aGVyd2lzZSBpdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgc3BoZXJlIHJhZGl1cy5cbiAqIEByZXR1cm4ge251bWJlcn0gQXJlYSAoaW4gc3F1YXJlIG1ldGVycykuXG4gKi9cbmZ1bmN0aW9uIGdldEFyZWFJbnRlcm5hbChjb29yZGluYXRlcywgcmFkaXVzKSB7XG4gIGxldCBhcmVhID0gMDtcbiAgY29uc3QgbGVuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICBsZXQgeDEgPSBjb29yZGluYXRlc1tsZW4gLSAxXVswXTtcbiAgbGV0IHkxID0gY29vcmRpbmF0ZXNbbGVuIC0gMV1bMV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCB4MiA9IGNvb3JkaW5hdGVzW2ldWzBdO1xuICAgIGNvbnN0IHkyID0gY29vcmRpbmF0ZXNbaV1bMV07XG4gICAgYXJlYSArPVxuICAgICAgdG9SYWRpYW5zKHgyIC0geDEpICpcbiAgICAgICgyICsgTWF0aC5zaW4odG9SYWRpYW5zKHkxKSkgKyBNYXRoLnNpbih0b1JhZGlhbnMoeTIpKSk7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiAoYXJlYSAqIHJhZGl1cyAqIHJhZGl1cykgLyAyLjA7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzcGhlcmljYWwgYXJlYSBvZiBhIGdlb21ldHJ5LiAgVGhpcyBpcyB0aGUgYXJlYSAoaW4gbWV0ZXJzKSBhc3N1bWluZ1xuICogdGhhdCBwb2x5Z29uIGVkZ2VzIGFyZSBzZWdtZW50cyBvZiBncmVhdCBjaXJjbGVzIG9uIGEgc3BoZXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgQSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7U3BoZXJlTWV0cmljT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSBhcmVhXG4gKiAgICAgY2FsY3VsYXRpb24uICBCeSBkZWZhdWx0LCBnZW9tZXRyaWVzIGFyZSBhc3N1bWVkIHRvIGJlIGluICdFUFNHOjM4NTcnLlxuICogICAgIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgcHJvdmlkaW5nIGEgYHByb2plY3Rpb25gIG9wdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNwaGVyaWNhbCBhcmVhIChpbiBzcXVhcmUgbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFyZWEoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IERFRkFVTFRfUkFESVVTO1xuICBjb25zdCBwcm9qZWN0aW9uID0gb3B0aW9ucy5wcm9qZWN0aW9uIHx8ICdFUFNHOjM4NTcnO1xuICBjb25zdCB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICBpZiAodHlwZSAhPT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICBnZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCkudHJhbnNmb3JtKHByb2plY3Rpb24sICdFUFNHOjQzMjYnKTtcbiAgfVxuICBsZXQgYXJlYSA9IDA7XG4gIGxldCBjb29yZGluYXRlcywgY29vcmRzLCBpLCBpaSwgaiwgamo7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BvaW50JzpcbiAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ0xpbmVhclJpbmcnOiB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnUG9seWdvbic6IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICApLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBhcmVhID0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3JkaW5hdGVzWzBdLCByYWRpdXMpKTtcbiAgICAgIGZvciAoaSA9IDEsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBhcmVhIC09IE1hdGguYWJzKGdldEFyZWFJbnRlcm5hbChjb29yZGluYXRlc1tpXSwgcmFkaXVzKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICApLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgIGFyZWEgKz0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3Jkc1swXSwgcmFkaXVzKSk7XG4gICAgICAgIGZvciAoaiA9IDEsIGpqID0gY29vcmRzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBhcmVhIC09IE1hdGguYWJzKGdldEFyZWFJbnRlcm5hbChjb29yZHNbal0sIHJhZGl1cykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzoge1xuICAgICAgY29uc3QgZ2VvbWV0cmllcyA9XG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgKS5nZXRHZW9tZXRyaWVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBhcmVhICs9IGdldEFyZWEoZ2VvbWV0cmllc1tpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmVhO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGUgYXQgdGhlIGdpdmVuIGRpc3RhbmNlIGFuZCBiZWFyaW5nIGZyb20gYGMxYC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjMSBUaGUgb3JpZ2luIHBvaW50IChgW2xvbiwgbGF0XWAgaW4gZGVncmVlcykuXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgVGhlIGdyZWF0LWNpcmNsZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBvcmlnaW5cbiAqICAgICBwb2ludCBhbmQgdGhlIHRhcmdldCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nIFRoZSBiZWFyaW5nIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzXSBUaGUgc3BoZXJlIHJhZGl1cyB0byB1c2UuICBEZWZhdWx0cyB0byB0aGUgRWFydGgnc1xuICogICAgIG1lYW4gcmFkaXVzIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVGhlIHRhcmdldCBwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mZnNldChjMSwgZGlzdGFuY2UsIGJlYXJpbmcsIHJhZGl1cykge1xuICByYWRpdXMgPSByYWRpdXMgfHwgREVGQVVMVF9SQURJVVM7XG4gIGNvbnN0IGxhdDEgPSB0b1JhZGlhbnMoYzFbMV0pO1xuICBjb25zdCBsb24xID0gdG9SYWRpYW5zKGMxWzBdKTtcbiAgY29uc3QgZEJ5UiA9IGRpc3RhbmNlIC8gcmFkaXVzO1xuICBjb25zdCBsYXQgPSBNYXRoLmFzaW4oXG4gICAgTWF0aC5zaW4obGF0MSkgKiBNYXRoLmNvcyhkQnlSKSArXG4gICAgICBNYXRoLmNvcyhsYXQxKSAqIE1hdGguc2luKGRCeVIpICogTWF0aC5jb3MoYmVhcmluZylcbiAgKTtcbiAgY29uc3QgbG9uID1cbiAgICBsb24xICtcbiAgICBNYXRoLmF0YW4yKFxuICAgICAgTWF0aC5zaW4oYmVhcmluZykgKiBNYXRoLnNpbihkQnlSKSAqIE1hdGguY29zKGxhdDEpLFxuICAgICAgTWF0aC5jb3MoZEJ5UikgLSBNYXRoLnNpbihsYXQxKSAqIE1hdGguc2luKGxhdClcbiAgICApO1xuICByZXR1cm4gW3RvRGVncmVlcyhsb24pLCB0b0RlZ3JlZXMobGF0KV07XG59XG4iXSwibmFtZXMiOlsidG9EZWdyZWVzIiwidG9SYWRpYW5zIiwiREVGQVVMVF9SQURJVVMiLCJnZXREaXN0YW5jZSIsImMxIiwiYzIiLCJyYWRpdXMiLCJsYXQxIiwibGF0MiIsImRlbHRhTGF0QnkyIiwiZGVsdGFMb25CeTIiLCJhIiwiTWF0aCIsInNpbiIsImNvcyIsImF0YW4yIiwic3FydCIsImdldExlbmd0aEludGVybmFsIiwiY29vcmRpbmF0ZXMiLCJsZW5ndGgiLCJpIiwiaWkiLCJnZXRMZW5ndGgiLCJnZW9tZXRyeSIsIm9wdGlvbnMiLCJwcm9qZWN0aW9uIiwidHlwZSIsImdldFR5cGUiLCJjbG9uZSIsInRyYW5zZm9ybSIsImNvb3JkcyIsImoiLCJqaiIsImdldENvb3JkaW5hdGVzIiwiZ2VvbWV0cmllcyIsImdldEdlb21ldHJpZXMiLCJFcnJvciIsImdldEFyZWFJbnRlcm5hbCIsImFyZWEiLCJsZW4iLCJ4MSIsInkxIiwieDIiLCJ5MiIsImdldEFyZWEiLCJhYnMiLCJvZmZzZXQiLCJkaXN0YW5jZSIsImJlYXJpbmciLCJsb24xIiwiZEJ5UiIsImxhdCIsImFzaW4iLCJsb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/sphere.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ol/string.js":
/*!***********************************!*\
  !*** ./node_modules/ol/string.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareVersions: () => (/* binding */ compareVersions),\n/* harmony export */   padNumber: () => (/* binding */ padNumber)\n/* harmony export */ });\n/**\n * @module ol/string\n */ /**\n * @param {number} number Number to be formatted\n * @param {number} width The desired width\n * @param {number} [precision] Precision of the output string (i.e. number of decimal places)\n * @return {string} Formatted string\n */ function padNumber(number, width, precision) {\n    const numberString = precision !== undefined ? number.toFixed(precision) : \"\" + number;\n    let decimal = numberString.indexOf(\".\");\n    decimal = decimal === -1 ? numberString.length : decimal;\n    return decimal > width ? numberString : new Array(1 + width - decimal).join(\"0\") + numberString;\n}\n/**\n * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js\n * @param {string|number} v1 First version\n * @param {string|number} v2 Second version\n * @return {number} Value\n */ function compareVersions(v1, v2) {\n    const s1 = (\"\" + v1).split(\".\");\n    const s2 = (\"\" + v2).split(\".\");\n    for(let i = 0; i < Math.max(s1.length, s2.length); i++){\n        const n1 = parseInt(s1[i] || \"0\", 10);\n        const n2 = parseInt(s2[i] || \"0\", 10);\n        if (n1 > n2) {\n            return 1;\n        }\n        if (n2 > n1) {\n            return -1;\n        }\n    }\n    return 0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2wvc3RyaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0NBRUMsR0FFRDs7Ozs7Q0FLQyxHQUNNLFNBQVNBLFVBQVVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxTQUFTO0lBQ2hELE1BQU1DLGVBQ0pELGNBQWNFLFlBQVlKLE9BQU9LLE9BQU8sQ0FBQ0gsYUFBYSxLQUFLRjtJQUM3RCxJQUFJTSxVQUFVSCxhQUFhSSxPQUFPLENBQUM7SUFDbkNELFVBQVVBLFlBQVksQ0FBQyxJQUFJSCxhQUFhSyxNQUFNLEdBQUdGO0lBQ2pELE9BQU9BLFVBQVVMLFFBQ2JFLGVBQ0EsSUFBSU0sTUFBTSxJQUFJUixRQUFRSyxTQUFTSSxJQUFJLENBQUMsT0FBT1A7QUFDakQ7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVNRLGdCQUFnQkMsRUFBRSxFQUFFQyxFQUFFO0lBQ3BDLE1BQU1DLEtBQUssQ0FBQyxLQUFLRixFQUFDLEVBQUdHLEtBQUssQ0FBQztJQUMzQixNQUFNQyxLQUFLLENBQUMsS0FBS0gsRUFBQyxFQUFHRSxLQUFLLENBQUM7SUFFM0IsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlDLEtBQUtDLEdBQUcsQ0FBQ0wsR0FBR04sTUFBTSxFQUFFUSxHQUFHUixNQUFNLEdBQUdTLElBQUs7UUFDdkQsTUFBTUcsS0FBS0MsU0FBU1AsRUFBRSxDQUFDRyxFQUFFLElBQUksS0FBSztRQUNsQyxNQUFNSyxLQUFLRCxTQUFTTCxFQUFFLENBQUNDLEVBQUUsSUFBSSxLQUFLO1FBRWxDLElBQUlHLEtBQUtFLElBQUk7WUFDWCxPQUFPO1FBQ1Q7UUFDQSxJQUFJQSxLQUFLRixJQUFJO1lBQ1gsT0FBTyxDQUFDO1FBQ1Y7SUFDRjtJQUVBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL21hcC8uL25vZGVfbW9kdWxlcy9vbC9zdHJpbmcuanM/NmI5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvc3RyaW5nXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIE51bWJlciB0byBiZSBmb3JtYXR0ZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgZGVzaXJlZCB3aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb25dIFByZWNpc2lvbiBvZiB0aGUgb3V0cHV0IHN0cmluZyAoaS5lLiBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMpXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZvcm1hdHRlZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZE51bWJlcihudW1iZXIsIHdpZHRoLCBwcmVjaXNpb24pIHtcbiAgY29uc3QgbnVtYmVyU3RyaW5nID1cbiAgICBwcmVjaXNpb24gIT09IHVuZGVmaW5lZCA/IG51bWJlci50b0ZpeGVkKHByZWNpc2lvbikgOiAnJyArIG51bWJlcjtcbiAgbGV0IGRlY2ltYWwgPSBudW1iZXJTdHJpbmcuaW5kZXhPZignLicpO1xuICBkZWNpbWFsID0gZGVjaW1hbCA9PT0gLTEgPyBudW1iZXJTdHJpbmcubGVuZ3RoIDogZGVjaW1hbDtcbiAgcmV0dXJuIGRlY2ltYWwgPiB3aWR0aFxuICAgID8gbnVtYmVyU3RyaW5nXG4gICAgOiBuZXcgQXJyYXkoMSArIHdpZHRoIC0gZGVjaW1hbCkuam9pbignMCcpICsgbnVtYmVyU3RyaW5nO1xufVxuXG4vKipcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vb21pY2hlbHNlbi9jb21wYXJlLXZlcnNpb25zL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHYxIEZpcnN0IHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdjIgU2Vjb25kIHZlcnNpb25cbiAqIEByZXR1cm4ge251bWJlcn0gVmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyh2MSwgdjIpIHtcbiAgY29uc3QgczEgPSAoJycgKyB2MSkuc3BsaXQoJy4nKTtcbiAgY29uc3QgczIgPSAoJycgKyB2Mikuc3BsaXQoJy4nKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHMxLmxlbmd0aCwgczIubGVuZ3RoKTsgaSsrKSB7XG4gICAgY29uc3QgbjEgPSBwYXJzZUludChzMVtpXSB8fCAnMCcsIDEwKTtcbiAgICBjb25zdCBuMiA9IHBhcnNlSW50KHMyW2ldIHx8ICcwJywgMTApO1xuXG4gICAgaWYgKG4xID4gbjIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAobjIgPiBuMSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuIl0sIm5hbWVzIjpbInBhZE51bWJlciIsIm51bWJlciIsIndpZHRoIiwicHJlY2lzaW9uIiwibnVtYmVyU3RyaW5nIiwidW5kZWZpbmVkIiwidG9GaXhlZCIsImRlY2ltYWwiLCJpbmRleE9mIiwibGVuZ3RoIiwiQXJyYXkiLCJqb2luIiwiY29tcGFyZVZlcnNpb25zIiwidjEiLCJ2MiIsInMxIiwic3BsaXQiLCJzMiIsImkiLCJNYXRoIiwibWF4IiwibjEiLCJwYXJzZUludCIsIm4yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ol/string.js\n");

/***/ })

};
;